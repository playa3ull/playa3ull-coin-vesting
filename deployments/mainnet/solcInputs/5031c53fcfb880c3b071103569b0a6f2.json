{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/rewards/BaseGameRewardHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IRewardManager} from \"./interfaces/IRewardManager.sol\";\r\nimport {IGameRewardHandler} from \"./interfaces/IGameRewardHandler.sol\";\r\nimport {ITokenAirdropHandler} from \"./interfaces/ITokenAirdropHandler.sol\";\r\n\r\n/**\r\n * @title BaseGameRewardHandler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Handles reward payments for games by funneling\r\n *         requests to the reward manager.\r\n * @dev    This contract is inherited by other contracts\r\n *         which can implement their own security measures.\r\n */\r\nabstract contract BaseGameRewardHandler is Ownable, IGameRewardHandler {\r\n    /// @notice The total reward payments that have been added\r\n    uint256 public totalRewards;\r\n\r\n    /// @notice The reward manager contract\r\n    IRewardManager public rewardManager;\r\n\r\n    /// @notice The token airdrop handler contract\r\n    ITokenAirdropHandler public tokenAirdropHandler;\r\n\r\n    /// @notice Addresses who are authorised to reward\r\n    mapping(address => bool) public authorisedRewarders;\r\n\r\n    modifier onlyAuthorisedRewarder() {\r\n        require(\r\n            authorisedRewarders[msg.sender],\r\n            \"BaseGameRewardHandler: Not authorised to reward\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyRewardManager() {\r\n        require(\r\n            msg.sender == address(rewardManager),\r\n            \"BaseGameRewardHandler: Not authorised to reward\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _rewardManager) {\r\n        rewardManager = IRewardManager(_rewardManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Submits a coin reward request to the reward manager\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     */\r\n    function rewardCoin(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external virtual override onlyAuthorisedRewarder {\r\n        _reward(_to, _amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Submits an NFT reward request to the reward manager\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function rewardToken(\r\n        address _to,\r\n        bytes memory _data\r\n    ) external virtual override onlyAuthorisedRewarder {\r\n        _reward(_to, 1, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Handles the reward from the reward manager\r\n     *\r\n     * @dev This function is to be implemented by the child contract\r\n     *\r\n     * @param _to The address to mint the NFT to\r\n     * @param _data The data to send with the mint\r\n     */\r\n    function handleReward(\r\n        address _to,\r\n        bytes memory _data\r\n    ) external virtual override onlyRewardManager {\r\n        if (tokenAirdropHandler == ITokenAirdropHandler(address(0))) return;\r\n\r\n        tokenAirdropHandler.airdrop(_to, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether an address is authorised to reward or not\r\n     *\r\n     * @param _rewarder The address to toggle\r\n     */\r\n    function toggleAuthorisedRewarder(address _rewarder) external onlyOwner {\r\n        authorisedRewarders[_rewarder] = !authorisedRewarders[_rewarder];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the reward manager\r\n     *\r\n     * @param _rewardManager The reward manager to set\r\n     */\r\n    function setRewardManager(address _rewardManager) external onlyOwner {\r\n        rewardManager = IRewardManager(_rewardManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the token airdrop handler\r\n     *\r\n     * @param _tokenAirdropHandler The token airdrop handler to set\r\n     */\r\n    function setTokenAirdropHandler(\r\n        address _tokenAirdropHandler\r\n    ) external onlyOwner {\r\n        tokenAirdropHandler = ITokenAirdropHandler(_tokenAirdropHandler);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to handle the reward\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function _reward(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    ) internal {\r\n        // If there is no attached data, we assume it is a rewardCoin request\r\n        if (_data.length == 0) {\r\n            _beforeRewardCoin(_to, _amount);\r\n        } else {\r\n            _beforeRewardToken(_to, _data);\r\n        }\r\n\r\n        rewardManager.reward(_to, _amount, _data);\r\n\r\n        if (_data.length == 0) {\r\n            _afterRewardCoin(_to, _amount);\r\n        } else {\r\n            _afterRewardToken(_to, _data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied before a reward is sent.\r\n     *\r\n     * @param _to The address that will be rewarded\r\n     * @param _amount The amount that will be rewarded\r\n     */\r\n    function _beforeRewardCoin(address _to, uint256 _amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied after a reward is sent.\r\n     *\r\n     * @param _to The address that was rewarded\r\n     * @param _amount The amount that was rewarded\r\n     */\r\n    function _afterRewardCoin(address _to, uint256 _amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called before a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied before a reward is sent.\r\n     *\r\n     * @param _to The address that will be rewarded\r\n     * @param _data The data that will be sent with the reward\r\n     */\r\n    function _beforeRewardToken(\r\n        address _to,\r\n        bytes memory _data\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied after a reward is sent.\r\n     *\r\n     * @param _to The address that was rewarded\r\n     * @param _data The data that was sent with the reward\r\n     */\r\n    function _afterRewardToken(\r\n        address _to,\r\n        bytes memory _data\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IGameRewardHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Game Reward Handler Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Game Reward Handler contracts.\r\n */\r\ninterface IGameRewardHandler {\r\n    /**\r\n     * @notice Reward a user with coins\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     */\r\n    function rewardCoin(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Reward a user with tokens\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _data The data to pass to the reward manager\r\n     */\r\n    function rewardToken(address _to, bytes memory _data) external;\r\n\r\n    /**\r\n     * @notice Handles the reward after being authorised\r\n     *         by the reward manager.\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _data The data received from the reward manager\r\n     */\r\n    function handleReward(address _to, bytes memory _data) external;\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IRewardManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Reward Manager Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Reward Manager contract.\r\n */\r\ninterface IRewardManager {\r\n    /**\r\n     * @notice A stored reward that was sent to an address\r\n     *\r\n     * @param to The address that was rewarded\r\n     * @param from The address that sent the reward\r\n     * @param amount The amount that was rewarded\r\n     * @param data The data that was sent with the reward\r\n     * @param timestamp The timestamp of the reward\r\n     */\r\n    struct Reward {\r\n        address to;\r\n        address from;\r\n        uint256 amount;\r\n        bytes data;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Emitted when a reward is sent\r\n     *\r\n     * @param _to The address that was rewarded\r\n     * @param _from The address that sent the reward\r\n     * @param _amount The amount that was rewarded\r\n     * @param _data The data that was sent with the reward\r\n     * @param _timestamp The timestamp of the reward\r\n     */\r\n    event RewardSent(\r\n        address indexed _to,\r\n        address indexed _from,\r\n        uint256 _amount,\r\n        bytes _data,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n     * @notice Sends a reward to the recipient\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function reward(address _to, uint256 _amount, bytes memory _data) external;\r\n}\r\n"
    },
    "contracts/rewards/interfaces/ITokenAirdropHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Token Airdrop Handler Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Token Airdrop Handler contract.\r\n */\r\ninterface ITokenAirdropHandler {\r\n    /**\r\n     * @notice Airdrops a token to the recipient\r\n     *\r\n     * @param _to The address to airdrop to\r\n     * @param _data The data to send with the airdrop\r\n     */\r\n    function airdrop(address _to, bytes memory _data) external;\r\n}\r\n"
    },
    "contracts/rewards/NexusAirdropRewardHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"./BaseGameRewardHandler.sol\";\r\n\r\n/**\r\n * @title NexusAirdropRewardHandler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Handles the reward payments for Nexus, specifically\r\n *         the 3ULL airdrop component.\r\n */\r\ncontract NexusAirdropRewardHandler is BaseGameRewardHandler {\r\n    /// @notice The time period in which rewards are tracked\r\n    uint256 public epochPeriod = 1 days;\r\n\r\n    /// @notice The maximum amount of rewards that can be paid out per epoch\r\n    uint256 public maxRewardPerEpoch = 1_000_000 ether;\r\n\r\n    /// @notice The timestamp of the last epoch\r\n    uint256 public lastEpochTimestamp = 0;\r\n\r\n    /// @notice The amount of funds released in the current epoch\r\n    uint256 public fundsReleasedInCurrentEpoch = 0;\r\n\r\n    /// @notice Tracks the last epoch an address was rewarded in\r\n    mapping(address => uint256) public lastAddressRewardEpoch;\r\n\r\n    constructor(address _rewardManager) BaseGameRewardHandler(_rewardManager) {}\r\n\r\n    /**\r\n     * @notice Allows the owner to set the epoch period\r\n     *\r\n     * @param _epochPeriod The epoch period\r\n     */\r\n    function setEpochPeriod(uint256 _epochPeriod) external onlyOwner {\r\n        epochPeriod = _epochPeriod;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the max reward per epoch\r\n     *\r\n     * @param _maxRewardPerEpoch The max reward per epoch\r\n     */\r\n    function setMaxRewardPerEpoch(\r\n        uint256 _maxRewardPerEpoch\r\n    ) external onlyOwner {\r\n        maxRewardPerEpoch = _maxRewardPerEpoch;\r\n    }\r\n\r\n    /**\r\n     * @notice Submits many coin reward requests to the reward manager\r\n     *\r\n     * @param _to The addresses to reward\r\n     * @param _amount The amounts to reward\r\n     */\r\n    function rewardCoinMany(\r\n        address[] calldata _to,\r\n        uint256[] calldata _amount\r\n    ) external onlyAuthorisedRewarder {\r\n        require(\r\n            _to.length == _amount.length,\r\n            \"NexusAirdropRewardHandler: Invalid input lengths\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < _to.length; i++) {\r\n            _reward(_to[i], _amount[i], \"\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Overrides the hook that is called before the reward is sent\r\n     *      in order to implement custom security measures.\r\n     *\r\n     * @param _to The address to be rewarded\r\n     * @param _amount The amount to be rewarded\r\n     */\r\n    function _beforeRewardCoin(\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal virtual override onlyAuthorisedRewarder {\r\n        // Calculate the current epoch\r\n        uint256 currentEpoch = block.timestamp -\r\n            (block.timestamp % epochPeriod);\r\n\r\n        // If the current epoch is greater than the last epoch timestamp,\r\n        // then we need to reset the funds released in the current epoch\r\n        if (currentEpoch > lastEpochTimestamp) {\r\n            lastEpochTimestamp = currentEpoch;\r\n            fundsReleasedInCurrentEpoch = 0;\r\n        }\r\n\r\n        // The funds released in the current epoch must be less than the max\r\n        // reward per epoch\r\n        require(\r\n            fundsReleasedInCurrentEpoch < maxRewardPerEpoch,\r\n            \"NexusAirdropRewardHandler: Max reward per epoch reached\"\r\n        );\r\n\r\n        // We only allow an address to be rewarded once per epoch\r\n        require(\r\n            lastAddressRewardEpoch[_to] < currentEpoch,\r\n            \"NexusAirdropRewardHandler: Address already rewarded in this epoch\"\r\n        );\r\n\r\n        fundsReleasedInCurrentEpoch += _amount;\r\n        lastAddressRewardEpoch[_to] = currentEpoch;\r\n\r\n        super._beforeRewardCoin(_to, _amount);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}