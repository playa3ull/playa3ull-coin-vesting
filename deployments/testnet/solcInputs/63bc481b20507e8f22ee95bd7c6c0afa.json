{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initialized`\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Internal function that returns the initialized version. Returns `_initializing`\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256, /* firstTokenId */\n        uint256 batchSize\n    ) internal virtual {\n        if (batchSize > 1) {\n            if (from != address(0)) {\n                _balances[from] -= batchSize;\n            }\n            if (to != address(0)) {\n                _balances[to] += batchSize;\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10**64) {\n                value /= 10**64;\n                result += 64;\n            }\n            if (value >= 10**32) {\n                value /= 10**32;\n                result += 32;\n            }\n            if (value >= 10**16) {\n                value /= 10**16;\n                result += 16;\n            }\n            if (value >= 10**8) {\n                value /= 10**8;\n                result += 8;\n            }\n            if (value >= 10**4) {\n                value /= 10**4;\n                result += 4;\n            }\n            if (value >= 10**2) {\n                value /= 10**2;\n                result += 2;\n            }\n            if (value >= 10**1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = MathUpgradeable.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, MathUpgradeable.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC2981.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (interfaces/IERC2981.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface for the NFT Royalty Standard.\n *\n * A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs) to enable universal\n * support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * _Available since v4.5._\n */\ninterface IERC2981 is IERC165 {\n    /**\n     * @dev Returns how much royalty is owed and to whom, based on a sale price that may be denominated in any unit of\n     * exchange. The royalty amount is denominated and should be paid in that same unit of exchange.\n     */\n    function royaltyInfo(uint256 tokenId, uint256 salePrice)\n        external\n        view\n        returns (address receiver, uint256 royaltyAmount);\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/ERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/ERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC1155.sol\";\nimport \"./IERC1155Receiver.sol\";\nimport \"./extensions/IERC1155MetadataURI.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of the basic standard multi-token.\n * See https://eips.ethereum.org/EIPS/eip-1155\n * Originally based on code by Enjin: https://github.com/enjin/erc-1155\n *\n * _Available since v3.1._\n */\ncontract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {\n    using Address for address;\n\n    // Mapping from token ID to account balances\n    mapping(uint256 => mapping(address => uint256)) private _balances;\n\n    // Mapping from account to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    // Used as the URI for all token types by relying on ID substitution, e.g. https://token-cdn-domain/{id}.json\n    string private _uri;\n\n    /**\n     * @dev See {_setURI}.\n     */\n    constructor(string memory uri_) {\n        _setURI(uri_);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC1155).interfaceId ||\n            interfaceId == type(IERC1155MetadataURI).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC1155MetadataURI-uri}.\n     *\n     * This implementation returns the same URI for *all* token types. It relies\n     * on the token type ID substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * Clients calling this function must replace the `\\{id\\}` substring with the\n     * actual token type ID.\n     */\n    function uri(uint256) public view virtual override returns (string memory) {\n        return _uri;\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) public view virtual override returns (uint256) {\n        require(account != address(0), \"ERC1155: address zero is not a valid owner\");\n        return _balances[id][account];\n    }\n\n    /**\n     * @dev See {IERC1155-balanceOfBatch}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] memory accounts, uint256[] memory ids)\n        public\n        view\n        virtual\n        override\n        returns (uint256[] memory)\n    {\n        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");\n\n        uint256[] memory batchBalances = new uint256[](accounts.length);\n\n        for (uint256 i = 0; i < accounts.length; ++i) {\n            batchBalances[i] = balanceOf(accounts[i], ids[i]);\n        }\n\n        return batchBalances;\n    }\n\n    /**\n     * @dev See {IERC1155-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC1155-isApprovedForAll}.\n     */\n    function isApprovedForAll(address account, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[account][operator];\n    }\n\n    /**\n     * @dev See {IERC1155-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeTransferFrom(from, to, id, amount, data);\n    }\n\n    /**\n     * @dev See {IERC1155-safeBatchTransferFrom}.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) public virtual override {\n        require(\n            from == _msgSender() || isApprovedForAll(from, _msgSender()),\n            \"ERC1155: caller is not token owner nor approved\"\n        );\n        _safeBatchTransferFrom(from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n        _balances[id][to] += amount;\n\n        emit TransferSingle(operator, from, to, id, amount);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, from, to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n        require(to != address(0), \"ERC1155: transfer to the zero address\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; ++i) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n            _balances[id][to] += amount;\n        }\n\n        emit TransferBatch(operator, from, to, ids, amounts);\n\n        _afterTokenTransfer(operator, from, to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Sets a new URI for all token types, by relying on the token type ID\n     * substitution mechanism\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP].\n     *\n     * By this mechanism, any occurrence of the `\\{id\\}` substring in either the\n     * URI or any of the amounts in the JSON file at said URI will be replaced by\n     * clients with the token type ID.\n     *\n     * For example, the `https://token-cdn-domain/\\{id\\}.json` URI would be\n     * interpreted by clients as\n     * `https://token-cdn-domain/000000000000000000000000000000000000000000000000000000000004cce0.json`\n     * for token type ID 0x4cce0.\n     *\n     * See {uri}.\n     *\n     * Because these URIs cannot be meaningfully represented by the {URI} event,\n     * this function emits no events.\n     */\n    function _setURI(string memory newuri) internal virtual {\n        _uri = newuri;\n    }\n\n    /**\n     * @dev Creates `amount` tokens of token type `id`, and assigns them to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function _mint(\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _balances[id][to] += amount;\n        emit TransferSingle(operator, address(0), to, id, amount);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeTransferAcceptanceCheck(operator, address(0), to, id, amount, data);\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function _mintBatch(\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {\n        require(to != address(0), \"ERC1155: mint to the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            _balances[ids[i]][to] += amounts[i];\n        }\n\n        emit TransferBatch(operator, address(0), to, ids, amounts);\n\n        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);\n\n        _doSafeBatchTransferAcceptanceCheck(operator, address(0), to, ids, amounts, data);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens of token type `id` from `from`\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `from` must have at least `amount` tokens of token type `id`.\n     */\n    function _burn(\n        address from,\n        uint256 id,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n\n        address operator = _msgSender();\n        uint256[] memory ids = _asSingletonArray(id);\n        uint256[] memory amounts = _asSingletonArray(amount);\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        uint256 fromBalance = _balances[id][from];\n        require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n        unchecked {\n            _balances[id][from] = fromBalance - amount;\n        }\n\n        emit TransferSingle(operator, from, address(0), id, amount);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     */\n    function _burnBatch(\n        address from,\n        uint256[] memory ids,\n        uint256[] memory amounts\n    ) internal virtual {\n        require(from != address(0), \"ERC1155: burn from the zero address\");\n        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");\n\n        address operator = _msgSender();\n\n        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n\n        for (uint256 i = 0; i < ids.length; i++) {\n            uint256 id = ids[i];\n            uint256 amount = amounts[i];\n\n            uint256 fromBalance = _balances[id][from];\n            require(fromBalance >= amount, \"ERC1155: burn amount exceeds balance\");\n            unchecked {\n                _balances[id][from] = fromBalance - amount;\n            }\n        }\n\n        emit TransferBatch(operator, from, address(0), ids, amounts);\n\n        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC1155: setting approval status for self\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `ids` and `amounts` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting\n     * and burning, as well as batched variants.\n     *\n     * The same hook is called on both single and batched variants. For single\n     * transfers, the length of the `id` and `amount` arrays will be 1.\n     *\n     * Calling conditions (for each `id` and `amount` pair):\n     *\n     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * of token type `id` will be  transferred to `to`.\n     * - When `from` is zero, `amount` tokens of token type `id` will be minted\n     * for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`\n     * will be burned.\n     * - `from` and `to` are never both zero.\n     * - `ids` and `amounts` have the same, non-zero length.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) internal virtual {}\n\n    function _doSafeTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155Received(operator, from, id, amount, data) returns (bytes4 response) {\n                if (response != IERC1155Receiver.onERC1155Received.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _doSafeBatchTransferAcceptanceCheck(\n        address operator,\n        address from,\n        address to,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        bytes memory data\n    ) private {\n        if (to.isContract()) {\n            try IERC1155Receiver(to).onERC1155BatchReceived(operator, from, ids, amounts, data) returns (\n                bytes4 response\n            ) {\n                if (response != IERC1155Receiver.onERC1155BatchReceived.selector) {\n                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");\n                }\n            } catch Error(string memory reason) {\n                revert(reason);\n            } catch {\n                revert(\"ERC1155: transfer to non ERC1155Receiver implementer\");\n            }\n        }\n    }\n\n    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {\n        uint256[] memory array = new uint256[](1);\n        array[0] = element;\n\n        return array;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/extensions/IERC1155MetadataURI.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC1155/extensions/IERC1155MetadataURI.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC1155.sol\";\n\n/**\n * @dev Interface of the optional ERC1155MetadataExtension interface, as defined\n * in the https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155MetadataURI is IERC1155 {\n    /**\n     * @dev Returns the URI for token type `id`.\n     *\n     * If the `\\{id\\}` substring is present in the URI, it must be replaced by\n     * clients with the actual token type ID.\n     */\n    function uri(uint256 id) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155Receiver is IERC165 {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Storage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165Storage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ERC165.sol\";\n\n/**\n * @dev Storage based implementation of the {IERC165} interface.\n *\n * Contracts may inherit from this and call {_registerInterface} to declare\n * their support of an interface.\n */\nabstract contract ERC165Storage is ERC165 {\n    /**\n     * @dev Mapping of interface ids to whether or not it's supported.\n     */\n    mapping(bytes4 => bool) private _supportedInterfaces;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];\n    }\n\n    /**\n     * @dev Registers the contract as an implementer of the interface defined by\n     * `interfaceId`. Support of the actual ERC165 interface is automatic and\n     * registering its interface id is not required.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * Requirements:\n     *\n     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).\n     */\n    function _registerInterface(bytes4 interfaceId) internal virtual {\n        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");\n        _supportedInterfaces[interfaceId] = true;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "contracts/avalanche/AllowList.sol": {
      "content": "pragma solidity ^0.8.4;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./interfaces/IAllowList.sol\";\r\n\r\n/// @title Implementation of Avalanche IALlowList\r\n/// @author Sam (PLAYA3ULL)\r\n\r\ncontract AllowList is IAllowList {\r\n    uint256 constant STATUS_NONE = 0;\r\n    uint256 constant STATUS_ENABLED = 1;\r\n    uint256 constant STATUS_ADMIN = 2;\r\n\r\n    mapping(address => uint256) allowList;\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender), \"PB AllowList: Not Admin\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyEnabled() {\r\n        require(isEnabled(msg.sender), \"PB AllowList: Not Enabled\");\r\n        _;\r\n    }\r\n\r\n    constructor() {\r\n        allowList[msg.sender] = STATUS_ADMIN;\r\n    }\r\n\r\n    function isEnabled(address addr) public view returns (bool) {\r\n        return allowList[addr] != STATUS_NONE;\r\n    }\r\n\r\n    function isAdmin(address addr) public view returns (bool) {\r\n        return allowList[addr] == STATUS_ADMIN;\r\n    }\r\n\r\n    function setAdmin(address addr) external override onlyAdmin {\r\n        allowList[addr] = STATUS_ADMIN;\r\n    }\r\n\r\n    function setEnabled(address addr) external override onlyAdmin {\r\n        allowList[addr] = STATUS_ENABLED;\r\n    }\r\n\r\n    function setNone(address addr) external override onlyAdmin {\r\n        allowList[addr] = STATUS_NONE;\r\n    }\r\n\r\n    function readAllowList(address addr)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 role)\r\n    {\r\n        return allowList[addr];\r\n    }\r\n}"
    },
    "contracts/avalanche/interfaces/IAllowList.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IAllowList {\r\n  // Set [addr] to have the admin role over the precompile\r\n  function setAdmin(address addr) external;\r\n\r\n  // Set [addr] to be enabled on the precompile contract.\r\n  function setEnabled(address addr) external;\r\n\r\n  // Set [addr] to have no role the precompile contract.\r\n  function setNone(address addr) external;\r\n\r\n  // Read the status of [addr].\r\n  function readAllowList(address addr) external view returns (uint256 role);\r\n}"
    },
    "contracts/avalanche/interfaces/INativeMinter.sol": {
      "content": "// (c) 2022-2023, Ava Labs, Inc. All rights reserved.\r\n// See the file LICENSE for licensing terms.\r\n\r\npragma solidity ^0.8.0;\r\nimport \"./IAllowList.sol\";\r\n\r\ninterface INativeMinter is IAllowList {\r\n\r\n  /**\r\n   * @dev Reverts when trying to mint zero Tokens\r\n   */\r\n  error CannotMintZero();\r\n\r\n  /** \r\n   * @dev Reverts when trying to mint to the zero address\r\n   */\r\n  error ZeroAddress();\r\n\r\n  // Mint [amount] number of native coins and send to [addr]\r\n  function mintNativeCoin(address addr, uint256 amount) external;\r\n}"
    },
    "contracts/core/BurnController.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {IBurnController} from \"./interfaces/IBurnController.sol\";\r\n\r\n/**\r\n * @title Burn Controller Contract\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Standardised contract for burning funds.\r\n */\r\ncontract BurnController is IBurnController {\r\n    /// @dev The interface ID of the ERC20 Token Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC20 = 0x36372b07;\r\n\r\n    /// @dev The interface ID of the ERC721 NFT Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /// @notice Tracks the total number of coins burnt\r\n    uint256 totalBurnt;\r\n\r\n    /// @notice The address to send funds to that will be permanently burnt.\r\n    ///         These funds are not tracked in the total supply.\r\n    address public immutable burnAddress =\r\n        0x0000000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @notice Returns the burn address.\r\n     *\r\n     * @return The burn address.\r\n     */\r\n    function getBurnAddress() external view override returns (address) {\r\n        return burnAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Burns the specified amount of coins.\r\n     *\r\n     * @param _amount The amount of coins to burn.\r\n     */\r\n    function burn(uint256 _amount) external override {\r\n        burnFor(msg.sender, _amount, address(0));\r\n    }\r\n\r\n    function burn(uint256 _amount, address _token) external override {\r\n        burnFor(msg.sender, _amount, _token);\r\n    }\r\n\r\n    function burnFor(\r\n        address _for,\r\n        uint256 _amount,\r\n        address _token\r\n    ) public override {\r\n        _burn(_for, _amount, _token);\r\n    }\r\n\r\n    function _burn(address _for, uint256 _amount, address _token) internal {\r\n        totalBurnt += _amount;\r\n\r\n        payable(burnAddress).transfer(_amount);\r\n\r\n        emit Burn(_for, _amount, _token);\r\n    }\r\n}\r\n"
    },
    "contracts/core/interfaces/IBurnController.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\n/**\r\n * @title Burn Controller Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Burn Controller contract.\r\n */\r\ninterface IBurnController {\r\n    event Burn(address indexed _from, uint256 _amount, address indexed _token);\r\n\r\n    function getBurnAddress() external view returns (address);\r\n\r\n    function burn(uint256 _amount) external;\r\n\r\n    function burn(uint256 _amount, address _token) external;\r\n\r\n    function burnFor(address _for, uint256 _amount, address _token) external;\r\n}\r\n"
    },
    "contracts/core/interfaces/INode.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title IPLAYA3ULLNode\r\n * @author Sam (PLAYA3ULL)\r\n * @notice IPLAYA3ULLNFT contains all external functions and\r\n *         structs for the PLAYA3ULL Node.\r\n */\r\n\r\ninterface IPLAYA3ULLNode {\r\n    struct NodeOwner {\r\n        /**\r\n         * @notice Number of nodes owned\r\n         */\r\n        uint256 NumNodes;\r\n        /**\r\n         * @notice Total claimed rewards, for new nodes this is the rewards that _would_ have been claimed given node existed at contract inception\r\n         */\r\n        uint256 ClaimedRewards;\r\n    }\r\n\r\n    function mint(address toAddress, uint256 amount) external;\r\n\r\n    function pendingRewards(address _owner) external view returns (uint256);\r\n\r\n    function claimRewards() external;\r\n\r\n    function claimFor(address account) external;\r\n\r\n    function mintPrice(uint256 amount) external view returns (uint256 _price);\r\n}\r\n"
    },
    "contracts/core/interfaces/INodeEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\ninterface IPLAYA3ULLNodeEventsAndErrors {\r\n    /// @notice         A node was minted\r\n    /// @param owner    The new owner of the new node\r\n    /// @param amount   Number of nodes minted\r\n    event NodesMinted(address owner, uint256 amount);\r\n\r\n    /// @notice         A node was transferred\r\n    /// @param from     Where the node was transfered from\r\n    /// @param to       Where the node was transferred to\r\n    /// @param nodeId   The node that was transferred\r\n    event NodeTransferred(address from, address to, uint256 nodeId);\r\n\r\n    /// @notice                     The rewards pool was updated\r\n    /// @param numEpochsProcessed   The nunmber of epochs since the last pool update\r\n    /// @param amountRewarded       The amount of new rewards issues\r\n    event PoolUpdated(uint256 numEpochsProcessed, uint256 amountRewarded);\r\n\r\n    /// @notice                 Rewards claimed for wallet\r\n    /// @param owner            Owner that claimed the rewards\r\n    /// @param rewardsClaimed   Number of rewards claimed\r\n    event RewardsClaimed(address owner, uint256 rewardsClaimed);\r\n\r\n    /// @notice             A node has been disqualified from earning rewards\r\n    /// @param owner        The node owner that has been disqualified\r\n    /// @param numNodes     Number of nodes disqualified for the owner\r\n    event NodeDisqualified(address owner, uint256 numNodes);\r\n\r\n    /// @notice             The price of a node has been updated\r\n    /// @param price        The updated price of a node\r\n    event PriceChanged(uint256 price);\r\n\r\n    /// @notice                         Emitted when reward adjustment is made from disqualifying nodes\r\n    /// @param rewardsPerNodeAdjusted   Number of rewards removed per disqualified node\r\n    /// @param numNodesDisqualified     Number of nodes that were disqualified\r\n    /// @param numQualifiedNodes        Number of qualified nodes (totalSupply - numDisqualified)\r\n    event RewardsAdjustedDisqualified(\r\n        uint256 rewardsPerNodeAdjusted,\r\n        uint256 numNodesDisqualified,\r\n        uint256 numQualifiedNodes\r\n    );\r\n\r\n    /// @notice                 Emitted when an address' minter access is toggled\r\n    /// @param minterAddress    The address of the minter\r\n    /// @param canMint          Whether the toggled address can mint\r\n    event AdminMinterToggled(address minterAddress, bool canMint);\r\n\r\n    /// @notice                 Emitted when an address' disqualifier access is toggled\r\n    /// @param disqualifierAddress    The address of the disqualifier\r\n    /// @param canDisqualify          Whether the toggled address can disqualify\r\n    event AdminDisqualifierToggled(\r\n        address disqualifierAddress,\r\n        bool canDisqualify\r\n    );\r\n\r\n    /**\r\n     * @dev Reverts when all nodes are not sold\r\n     */\r\n    error AllNodesNotSold();\r\n\r\n    /**\r\n     * @dev Reverts when user is not disqualifier\r\n     */\r\n    error NotDisqualifier();\r\n\r\n    /**\r\n     * @dev Reverts when attempting to mint 0 nodes\r\n     */\r\n    error CannotMintZero();\r\n\r\n    /**\r\n     * @dev Reverts when attempting to mint more than the single transaction limit\r\n     */\r\n    error CannotMintMoreThanLimit();\r\n\r\n    /**\r\n     * @dev Reverts when attempting to ming more than the cap\r\n     */\r\n    error CannotMintMoreThanCap();\r\n\r\n    /**\r\n     * @dev Reverts if the owner has no nodes\r\n     */\r\n    error NoNodes();\r\n\r\n    /**\r\n     * @dev Reverts if the new value is less than the previous value\r\n     */\r\n    error NewLessThanPrevious();\r\n\r\n    /**\r\n     * @dev Reverts if the array lengths are not equal\r\n     */\r\n    error ArrayLengthNotEqual();\r\n\r\n    /**\r\n     * @dev Reverts if ZeroAddress\r\n     */\r\n    error ZeroAddress();\r\n\r\n    /**\r\n     * @dev Reverts if ZeroNumber\r\n     */\r\n    error AmountZero();\r\n\r\n    /**\r\n     * @dev Reverts if the contract is already initialized\r\n     */\r\n    error AlreadyInitialized();\r\n\r\n    /**\r\n     * @dev Reverts if the contract is not initialized\r\n     */\r\n    error NotInitialized();\r\n}\r\n"
    },
    "contracts/core/interfaces/ITreasuryManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title ITreasuryManager\r\n * @author Jourdan (@jourdanhaines), Sam (@samthompsonkennedy)\r\n * @notice ITreasuryManager is an interface for the TreasuryManager contract.\r\n */\r\ninterface ITreasuryManager {\r\n    /**\r\n     * @dev Represents a withdrawal action that includes burning a portion of the withdrawn amount.\r\n     * @param total Total amount withdrawn.\r\n     * @param burned Amount of the total that was burned.\r\n     * @param timestamp Timestamp when the withdrawal and burn occurred.\r\n     */\r\n    struct WithdrawalBurn {\r\n        uint256 total;\r\n        uint256 burned;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    /**\r\n     * @dev Emitted when a specified amount is burned.\r\n     * @param amount Amount of tokens burned.\r\n     */\r\n    event AmountBurned(uint256 amount);\r\n\r\n    /**\r\n     * @dev Emitted when the burn ratio is updated.\r\n     * @param burnRatio New burn ratio.\r\n     */\r\n    event BurnRatioUpdated(uint256 burnRatio);\r\n}\r\n"
    },
    "contracts/core/NativeNodePurchaser.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IPLAYA3ULLNode} from \"./interfaces/INode.sol\";\r\nimport {IPriceOracle} from \"../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games Native Node Purchaser Contract\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract facilitates the sale of PLAYA3ULL Nodes in\r\n *         3ULL utilising an external price oracle for calculating\r\n *         the sale of nodes in 3ULL.\r\n */\r\ncontract NativeNodePurchaser is Ownable {\r\n    /// @notice The PLAYA3ULL Node interface to mint to\r\n    IPLAYA3ULLNode public node;\r\n\r\n    /// @notice The Price Oracle to retrieve price data from\r\n    IPriceOracle public oracle;\r\n\r\n    /**\r\n     * @dev Reverts with an error when providing a value that is\r\n     *      insufficient for the transaction\r\n     *\r\n     * @param provided The value that was provided\r\n     * @param expected The value that was expected\r\n     */\r\n    error InsufficientValueProvided(uint256 provided, uint256 expected);\r\n\r\n    /**\r\n     * @dev Reverts with an error if the Zero Address\r\n     */\r\n    error ZeroAddress();\r\n\r\n    /**\r\n     * @dev Reverts with an error if the number is zero\r\n     */\r\n    error ZeroNumber();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to withdraw balance\r\n     *      that is greater than the balance of the contract.\r\n     *\r\n     * @param balance   The true balance of the contract.\r\n     */\r\n    error NotEnoughFunds(uint256 balance);\r\n\r\n    constructor(address _node, address _oracle) {\r\n        _assertZeroAddress(_node);\r\n        _assertZeroAddress(_oracle);\r\n\r\n        node = IPLAYA3ULLNode(_node);\r\n        oracle = IPriceOracle(_oracle);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints a `count` of nodes to `to`\r\n     *\r\n     * @param to    The address to receive the nodes\r\n     * @param count The number of nodes to mint\r\n     */\r\n    function mint(address to, uint256 count) external payable {\r\n        _assertZeroAddress(to);\r\n\r\n        // Verify the count is not zero, otherwise revert\r\n        if (count == 0) {\r\n            revert ZeroNumber();\r\n        }\r\n\r\n        // Verify the sent amount is the amount we expect, otherwise revert\r\n        uint256 expected = getPrice(count);\r\n        if (msg.value != expected) {\r\n            revert InsufficientValueProvided(msg.value, expected);\r\n        }\r\n\r\n        node.mint(to, count);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the price of a PLAYA3ULL Node in 3ULL\r\n     *         for a given `count`\r\n     *\r\n     * @param count The number of nodes to get the price for\r\n     */\r\n    function getPrice(uint256 count) public view returns (uint256) {\r\n        uint256 mintPrice = node.mintPrice(count);\r\n\r\n        // We need to convert the `mintPrice` from 6 decimals\r\n        // to 18 decimals, since that is what 3ULL uses\r\n        uint256 realPrice = (mintPrice * 1e18) / 1e6;\r\n\r\n        return oracle.getPriceIn(\"USDC\", \"3ULL\", realPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        _assertEnoughFunds(amount);\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the owner attempts to withdraw\r\n     *      more funds than the contract balance contains.\r\n     *\r\n     * @param requestedAmount   The amount that is being withdrawn from\r\n     *                          the contract.\r\n     */\r\n    function _assertEnoughFunds(uint256 requestedAmount) internal view {\r\n        if (requestedAmount > address(this).balance) {\r\n            revert NotEnoughFunds(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the provided address is the\r\n     *      Zero Address\r\n     *\r\n     * @param addr  The address to check\r\n     */\r\n    function _assertZeroAddress(address addr) internal pure {\r\n        if (addr == address(0)) {\r\n            revert ZeroAddress();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/Node.sol": {
      "content": "pragma solidity 0.8.17;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\nimport \"../avalanche/interfaces/INativeMinter.sol\";\r\n\r\nimport \"./interfaces/INode.sol\";\r\nimport \"./interfaces/INodeEventsAndErrors.sol\";\r\n\r\n///\r\n/// @title PLAYA3ULL Games Node NFT and Rewards Contract\r\n/// @author Sam (PLAYA3ULL), Jourdan (PLAYA3ULL), Jeeva (Helix)\r\n///\r\ncontract PLAYA3ULLNode is\r\n    ERC721,\r\n    Ownable,\r\n    IPLAYA3ULLNodeEventsAndErrors,\r\n    IPLAYA3ULLNode,\r\n    ReentrancyGuard\r\n{\r\n    /// @dev Avalanche Subnet native minter precompile - https://docs.avax.network/subnets/customize-a-subnet#minting-native-coins\r\n    INativeMinter immutable nativeMinter;\r\n\r\n    /// @notice Node holdings mapped to owner\r\n    mapping(address => NodeOwner) public holdingsOf;\r\n\r\n    /// @notice Mapping of addresses that are allowed to mint nodes\r\n    mapping(address => bool) public adminMinters;\r\n\r\n    /// @notice Mapping of disqualified rewards for a given address\r\n    mapping(address => uint256) public disqualifiedRewards;\r\n\r\n    /// @notice Mapping of claimed additional rewards for a given address\r\n    mapping(address => uint256) public claimedAdditionalRewards;\r\n\r\n    /// @notice Mapping of addresses that are allowed to disqualify nodes\r\n    mapping(address => bool) public disqualifiers;\r\n\r\n    /// @notice Whether the node reward system is initialized\r\n    bool public isInitialized;\r\n\r\n    /// @notice Additional rewards per node\r\n    uint256 public additionalRewardsPerNode;\r\n\r\n    /// @notice Epoch size in seconds\r\n    uint256 public immutable epochSizeSeconds;\r\n\r\n    /// @notice Rewards earnt per epoch\r\n    uint256 public rewardPerEpoch;\r\n\r\n    /// @notice Rewards accumlated per node since contract creation / node start\r\n    uint256 public lifetimeAccRewardsPerNode;\r\n\r\n    /// @notice The time up to which the rewards were last calculated from `updatePool()`\r\n    uint256 public lastRewardTimestamp;\r\n\r\n    /// @notice Total nodes currently in circulation\r\n    uint256 public totalSupply;\r\n\r\n    /// @notice Maximum number of nodes, constant set to 50,000 as per whitepaper\r\n    uint256 public immutable cap;\r\n\r\n    /// @notice Maximum number of nodes purchased at once, constant set to 25 per transaction\r\n    uint256 public constant mintMax = 25;\r\n\r\n    /// @notice How many nodes sold to increase the bracket\r\n    uint256 public constant bracketSize = 100;\r\n\r\n    /// @notice Current node price\r\n    uint256 public price;\r\n\r\n    /// @notice Price increase per `bracketSize` sold\r\n    uint256 public priceIncrease;\r\n\r\n    /// @notice Next price increase amount\r\n    uint256 public nextPriceIncrease;\r\n\r\n    /// @notice Base token URL to prefit the `tokenURI()`\r\n    string public baseTokenURI;\r\n\r\n    /// @dev Modifier for only allowing set addresses to mint\r\n    ///      nodes\r\n    modifier onlyMinter() {\r\n        require(adminMinters[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier for only allowing set addresses to\r\n    ///      disqualify nodes\r\n    modifier onlyDisqualifier() {\r\n        if (disqualifiers[msg.sender]) {\r\n            _;\r\n        } else {\r\n            revert NotDisqualifier();\r\n        }\r\n    }\r\n\r\n    /// @dev Modifier for verifying that the node reward\r\n    ///      system is initialized\r\n    modifier requireInitialized() {\r\n        if (isInitialized) {\r\n            _;\r\n        } else {\r\n            revert NotInitialized();\r\n        }\r\n    }\r\n\r\n    constructor(\r\n        uint256 _epochSizeSeconds,\r\n        uint256 _rewardPerEpoch,\r\n        INativeMinter _nativeMinter,\r\n        uint256 _cap\r\n    ) ERC721(\"PLAYA3ULL NODE\", \"3ULL NODE\") {\r\n        _assertZeroAddress(address(_nativeMinter));\r\n        _assertNotZero(_epochSizeSeconds);\r\n        _assertNotZero(_rewardPerEpoch);\r\n        _assertNotZero(_cap);\r\n\r\n        lastRewardTimestamp = block.timestamp;\r\n        nativeMinter = _nativeMinter;\r\n\r\n        epochSizeSeconds = _epochSizeSeconds;\r\n        rewardPerEpoch = _rewardPerEpoch;\r\n\r\n        cap = _cap;\r\n\r\n        priceIncrease = 100 * (10 ** 6); // 100 USD\r\n        price = 100 * (10 ** 6); // Starting price of 100 USD\r\n        nextPriceIncrease = 100;\r\n    }\r\n\r\n    ///\r\n    /// @notice Ensures all nodes have been sold prior to transfer, and performs transfer logic (rewards need to be claimed before transfer)\r\n    ///\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override(ERC721) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) return;\r\n\r\n        _assertAllNodesSold();\r\n\r\n        NodeOwner storage currentOwner = holdingsOf[from];\r\n        NodeOwner storage newOwner = holdingsOf[to];\r\n\r\n        // Rewards need to be claimed prior to transfer otherwise they are lost\r\n        claimFor(from);\r\n\r\n        currentOwner.NumNodes--;\r\n        currentOwner.ClaimedRewards -= lifetimeAccRewardsPerNode;\r\n\r\n        newOwner.NumNodes++;\r\n        newOwner.ClaimedRewards += lifetimeAccRewardsPerNode;\r\n\r\n        emit NodeTransferred(from, to, tokenId);\r\n    }\r\n\r\n    ///\r\n    /// @notice Caculates the current owners pending rewards\r\n    /// @dev The pending rewards will not show correctly, unless `updatePool()` has been called\r\n    /// @param _owner The owner to return the pending rewards for\r\n    /// @return Total pending rewards for a given node owner\r\n    ///\r\n    function pendingRewards(address _owner) public view returns (uint256) {\r\n        NodeOwner storage nodeOwner = holdingsOf[_owner];\r\n\r\n        uint256 _lifetimeScaledAccRewardsPerNode = _calculateScaledRewardsPerNode();\r\n\r\n        // Prevent underflow\r\n        if (\r\n            nodeOwner.NumNodes * _lifetimeScaledAccRewardsPerNode <\r\n            nodeOwner.ClaimedRewards\r\n        ) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 rewardsPending = (nodeOwner.NumNodes *\r\n            _lifetimeScaledAccRewardsPerNode) - nodeOwner.ClaimedRewards;\r\n\r\n        uint256 additionalRewards = (additionalRewardsPerNode *\r\n            nodeOwner.NumNodes) - claimedAdditionalRewards[_owner];\r\n\r\n        if (rewardsPending + additionalRewards < disqualifiedRewards[_owner]) {\r\n            return 0;\r\n        }\r\n\r\n        return\r\n            (rewardsPending + additionalRewards) - disqualifiedRewards[_owner];\r\n    }\r\n\r\n    ///\r\n    /// @dev Calculates the current scaled rewards per node\r\n    /// @return _lifetimeScaledAccRewardsPerNode The current scaled rewards per node\r\n    ///\r\n    function _calculateScaledRewardsPerNode() internal view returns (uint256) {\r\n        uint256 _lifetimeScaledAccRewardsPerNode = lifetimeAccRewardsPerNode;\r\n\r\n        if (\r\n            block.timestamp > (lastRewardTimestamp + epochSizeSeconds) &&\r\n            totalSupply != 0\r\n        ) {\r\n            uint256 epochsToReward = (block.timestamp - lastRewardTimestamp) /\r\n                epochSizeSeconds;\r\n            uint256 reward = epochsToReward * rewardPerEpoch;\r\n            _lifetimeScaledAccRewardsPerNode += (reward / totalSupply);\r\n        }\r\n\r\n        return _lifetimeScaledAccRewardsPerNode;\r\n    }\r\n\r\n    ///\r\n    /// @notice Updates the rewards pool\r\n    /// @dev Updates `lastRewardTimestamp` & `lifetimeAccRewardsPerNode` to ensure rewards are updated for current epoch\r\n    ///\r\n    function updatePool() public {\r\n        if (block.timestamp < (lastRewardTimestamp + epochSizeSeconds)) {\r\n            return;\r\n        }\r\n\r\n        uint256 epochsToReward = (block.timestamp - lastRewardTimestamp) /\r\n            epochSizeSeconds;\r\n        lastRewardTimestamp =\r\n            lastRewardTimestamp +\r\n            (epochsToReward * epochSizeSeconds);\r\n\r\n        if (totalSupply == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 totalRewardsForPeriod = epochsToReward * rewardPerEpoch;\r\n        lifetimeAccRewardsPerNode =\r\n            lifetimeAccRewardsPerNode +\r\n            (totalRewardsForPeriod / totalSupply);\r\n\r\n        emit PoolUpdated(epochsToReward, totalRewardsForPeriod);\r\n    }\r\n\r\n    ///\r\n    /// @notice Mints the node to an owner\r\n    /// @param ownerAddress The wallet the node/s are minted to\r\n    /// @param amount Number of nodes to mint\r\n    ///\r\n    function mintFor(address ownerAddress, uint256 amount) private {\r\n        _assertMintAmount(amount);\r\n\r\n        uint256 preTotalSupply = totalSupply;\r\n\r\n        NodeOwner storage owner = holdingsOf[ownerAddress];\r\n\r\n        updatePool();\r\n\r\n        owner.NumNodes += amount;\r\n        totalSupply += amount;\r\n\r\n        if (isInitialized) {\r\n            owner.ClaimedRewards += amount * lifetimeAccRewardsPerNode;\r\n            claimedAdditionalRewards[ownerAddress] +=\r\n                amount *\r\n                additionalRewardsPerNode;\r\n        }\r\n\r\n        if (totalSupply > nextPriceIncrease) {\r\n            nextPriceIncrease += bracketSize;\r\n            price += priceIncrease;\r\n            emit PriceChanged(price);\r\n        }\r\n\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            _safeMint(ownerAddress, preTotalSupply + i);\r\n        }\r\n\r\n        emit NodesMinted(ownerAddress, amount);\r\n    }\r\n\r\n    ///\r\n    /// @notice Allows an admin minter to mint a node for an address.\r\n    ///         This is to support cross-chain minting and migration.\r\n    /// @param toAddress The wallet the node(s) are minted to\r\n    /// @param amount The number of nodes that will be minted\r\n    ///\r\n    function mint(address toAddress, uint256 amount) external onlyMinter {\r\n        mintFor(toAddress, amount);\r\n    }\r\n\r\n    ///\r\n    /// @notice Claim rewards helper, to claim for the caller\r\n    ///\r\n    function claimRewards() external {\r\n        claimFor(msg.sender);\r\n    }\r\n\r\n    ///\r\n    /// @notice Claim rewards for a given address\r\n    /// @param account The address to claim rewards for\r\n    ///\r\n    function claimFor(address account) public requireInitialized nonReentrant {\r\n        _assertNodeOwnership(account);\r\n\r\n        NodeOwner storage owner = holdingsOf[account];\r\n\r\n        updatePool();\r\n\r\n        uint256 _lifetimeScaledAccRewardsPerNode = _calculateScaledRewardsPerNode();\r\n        uint256 totalClaimedRewardsScaled = (owner.NumNodes *\r\n            _lifetimeScaledAccRewardsPerNode);\r\n\r\n        uint256 _rewardsClaimed = pendingRewards(account);\r\n\r\n        if (_rewardsClaimed == 0) return;\r\n\r\n        // Update the claimed rewards for the owner\r\n        if (totalClaimedRewardsScaled > owner.ClaimedRewards) {\r\n            owner.ClaimedRewards = totalClaimedRewardsScaled;\r\n        }\r\n\r\n        uint256 additionalRewards = (additionalRewardsPerNode *\r\n            owner.NumNodes) - claimedAdditionalRewards[account];\r\n\r\n        claimedAdditionalRewards[account] += additionalRewards;\r\n\r\n        if (_rewardsClaimed == 0) return;\r\n\r\n        nativeMinter.mintNativeCoin(account, _rewardsClaimed);\r\n\r\n        emit RewardsClaimed(account, _rewardsClaimed);\r\n    }\r\n\r\n    ///\r\n    /// @notice Disqualifies nodes from receiving rewards for a single day (24 epochs)\r\n    ///         This will be centralized in Stage One, off-chain logic will be decentralized in Stage Two\r\n    /// @dev We increase the `additionalRewardsPerNode` for the new reward distribution\r\n    ///     Increase the `disqualifiedRewards` for each of the disqualified nodes\r\n    ///     Thus artificially decreasing the amount they can claim\r\n    ///     If `totalSupply` is `1000` and we disqualify `100` nodes, the rewards should be distributed\r\n    ///     `rewardPerNode = (rewardPerEpoch * 24) / 900` as they are disqualified from 24 epochs (a day)\r\n    /// @param accounts An array of addresses to disqualify\r\n    /// @param numNodes Corresponding number of nodes that didn't qualify for a particular\r\n    ///\r\n    function disqualifyNodes(\r\n        address[] memory accounts,\r\n        uint256[] memory numNodes\r\n    ) public requireInitialized onlyDisqualifier {\r\n        updatePool();\r\n\r\n        _assertArrayLengthEqual(accounts, numNodes);\r\n\r\n        uint256 totalUnqualifiedNodes;\r\n        for (uint256 i = 0; i < numNodes.length; ) {\r\n            unchecked {\r\n                totalUnqualifiedNodes += numNodes[i];\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // The number of nodes that are still qualified\r\n        uint256 totalQualifiedNodes = totalSupply - totalUnqualifiedNodes;\r\n\r\n        // The reward per node for the previous day\r\n        uint256 prevDaysRewardPerNode = (rewardPerEpoch * 24) / totalSupply;\r\n\r\n        // The total rewards to redistribute\r\n        uint256 rewardsToRedistributePerNode = (prevDaysRewardPerNode *\r\n            totalUnqualifiedNodes) / totalQualifiedNodes;\r\n\r\n        additionalRewardsPerNode += rewardsToRedistributePerNode;\r\n\r\n        for (uint256 i = 0; i < accounts.length; i++) {\r\n            // Ignore zero nodes\r\n            if (numNodes[i] == 0) {\r\n                continue;\r\n            }\r\n\r\n            disqualifiedRewards[accounts[i]] +=\r\n                (rewardsToRedistributePerNode * numNodes[i]) *\r\n                2;\r\n\r\n            emit NodeDisqualified(accounts[i], numNodes[i]);\r\n        }\r\n\r\n        emit RewardsAdjustedDisqualified(\r\n            rewardsToRedistributePerNode,\r\n            totalUnqualifiedNodes,\r\n            totalQualifiedNodes\r\n        );\r\n\r\n        updatePool();\r\n    }\r\n\r\n    ///\r\n    /// @notice The expected mint price for the number of nodes\r\n    /// @param amount The number of notes to get the price for\r\n    /// @return _price Price of the nodes\r\n    ///\r\n    function mintPrice(uint256 amount) public view returns (uint256 _price) {\r\n        _assertMintAmount(amount);\r\n        uint256 supplyAfterMint = totalSupply + amount;\r\n\r\n        if ((supplyAfterMint) > nextPriceIncrease) {\r\n            uint256 difference = supplyAfterMint - nextPriceIncrease;\r\n            uint256 lowerPrice = (amount - difference) * price;\r\n            uint256 upperPrice = difference * (price + priceIncrease);\r\n\r\n            _price = upperPrice + lowerPrice;\r\n        } else {\r\n            _price = amount * price;\r\n        }\r\n    }\r\n\r\n    ///\r\n    /// @notice Initializes and resets the node reward system\r\n    ///\r\n    function initialize() external onlyOwner {\r\n        if (isInitialized) {\r\n            revert AlreadyInitialized();\r\n        }\r\n\r\n        isInitialized = true;\r\n\r\n        lastRewardTimestamp = block.timestamp;\r\n        lifetimeAccRewardsPerNode = 0;\r\n    }\r\n\r\n    ///\r\n    /// @notice Base URI for computing `tokenURI`. If set, the resulting URI for each token will be the concatenation of the baseURI and the tokenId\r\n    //\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    ///\r\n    /// @notice Sets `baseTokenURI`\r\n    /// @param _baseTokenURI The new `baseTokenURU`\r\n    ///\r\n    function setBaseTokenURI(string memory _baseTokenURI) public onlyOwner {\r\n        baseTokenURI = _baseTokenURI;\r\n    }\r\n\r\n    ///\r\n    /// @notice Set the price increase per 100 nodes sold, this can only  increase from the current value as to not rip off previous purchasers\r\n    /// @param _priceIncrease The new `priceIncrease`\r\n    ///\r\n    function setPriceIncrease(uint256 _priceIncrease) external onlyOwner {\r\n        _assertNewLessThanPrevious(_priceIncrease, priceIncrease);\r\n        priceIncrease = _priceIncrease;\r\n    }\r\n\r\n    ///\r\n    /// @notice Set the base, this can only increase from the current value as to not rip off previous purchasers\r\n    /// @param _price The new `price`\r\n    ///\r\n    function setPrice(uint256 _price) external onlyOwner {\r\n        _assertNewLessThanPrevious(_price, price);\r\n        price = _price;\r\n        emit PriceChanged(price);\r\n    }\r\n\r\n    ///\r\n    /// @notice Toggles whether the given address can mint or not\r\n    /// @param minter The address of the minter to toggle\r\n    ///\r\n    function toggleAdminMinter(address minter) external onlyOwner {\r\n        adminMinters[minter] = !adminMinters[minter];\r\n\r\n        emit AdminMinterToggled(minter, adminMinters[minter]);\r\n    }\r\n\r\n    ///\r\n    /// @notice Toggles whether the given address can disqualify or not\r\n    /// @param disqualifier The address of the disqualifier to toggle\r\n    ///\r\n    function toggleDisqualifier(address disqualifier) external onlyOwner {\r\n        disqualifiers[disqualifier] = !disqualifiers[disqualifier];\r\n\r\n        emit AdminDisqualifierToggled(\r\n            disqualifier,\r\n            disqualifiers[disqualifier]\r\n        );\r\n    }\r\n\r\n    function _assertAllNodesSold() internal view {\r\n        if (totalSupply < cap) {\r\n            revert AllNodesNotSold();\r\n        }\r\n    }\r\n\r\n    function _assertMintAmount(uint256 _amount) internal view {\r\n        if (_amount == 0) {\r\n            revert CannotMintZero();\r\n        }\r\n\r\n        if (_amount > mintMax) {\r\n            revert CannotMintMoreThanLimit();\r\n        }\r\n\r\n        if (_amount + totalSupply > cap) {\r\n            revert CannotMintMoreThanCap();\r\n        }\r\n    }\r\n\r\n    function _assertNodeOwnership(address _owner) internal view {\r\n        if (holdingsOf[_owner].NumNodes == 0) {\r\n            revert NoNodes();\r\n        }\r\n    }\r\n\r\n    function _assertNewLessThanPrevious(\r\n        uint256 _new,\r\n        uint256 _previous\r\n    ) internal pure {\r\n        if (_new < _previous) {\r\n            revert NewLessThanPrevious();\r\n        }\r\n    }\r\n\r\n    function _assertArrayLengthEqual(\r\n        address[] memory _array1,\r\n        uint256[] memory _array2\r\n    ) internal pure {\r\n        if (_array1.length != _array2.length) {\r\n            revert ArrayLengthNotEqual();\r\n        }\r\n    }\r\n\r\n    function _assertZeroAddress(address _address) internal pure {\r\n        if (_address == address(0)) {\r\n            revert ZeroAddress();\r\n        }\r\n    }\r\n\r\n    function _assertNotZero(uint256 _amount) internal pure {\r\n        if (_amount == 0) {\r\n            revert AmountZero();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/ProtocolSupply.sol": {
      "content": "pragma solidity ^0.8.4;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"../avalanche/interfaces/INativeMinter.sol\";\r\n\r\n/// @title PLAYA3ULL Rewards for company\r\n/// @author Sam (PLAYA3ULL)\r\n\r\ncontract PLAYA3ULLProtocolSupply is Ownable {\r\n    INativeMinter immutable nativeMinter;\r\n\r\n    uint256 public lastCompanyRewardTimestamp;\r\n    uint256 public epochSizeSeconds;\r\n    uint256 public rewardPerEpoch;\r\n\r\n    constructor(\r\n        uint256 _epochSizeSeconds,\r\n        uint256 _rewardPerEpoch,\r\n        INativeMinter _nativeMinter\r\n    ) {\r\n        lastCompanyRewardTimestamp = block.timestamp;\r\n        nativeMinter = _nativeMinter;\r\n\r\n        epochSizeSeconds = _epochSizeSeconds;\r\n        rewardPerEpoch = _rewardPerEpoch;\r\n    }\r\n\r\n    ///\r\n    /// @notice Return pending company rewards\r\n    ///\r\n    function pendingRewards() external view returns(uint256) {\r\n        require(block.timestamp > (lastCompanyRewardTimestamp + epochSizeSeconds), \"PB ProtocolSupply: No rewards claimable yet\");\r\n        uint256 epochsToReward = (block.timestamp - lastCompanyRewardTimestamp) / epochSizeSeconds;\r\n        uint256 reward = epochsToReward * rewardPerEpoch;\r\n\r\n        return reward;\r\n    }\r\n\r\n    ///\r\n    /// @notice Claim company rewards, with flash swap of minter\r\n    ///\r\n    function claimRewards() external onlyOwner {\r\n        require(block.timestamp > (lastCompanyRewardTimestamp + epochSizeSeconds), \"PB ProtocolSupply: No rewards claimable yet\");\r\n\r\n        uint256 epochsToReward = (block.timestamp - lastCompanyRewardTimestamp) / epochSizeSeconds;\r\n        uint256 reward = epochsToReward * rewardPerEpoch;\r\n\r\n        nativeMinter.mintNativeCoin(msg.sender, reward);\r\n\r\n        lastCompanyRewardTimestamp += epochsToReward * epochSizeSeconds;\r\n    }\r\n}"
    },
    "contracts/core/SupplyController.sol": {
      "content": "pragma solidity ^0.8.4;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"../avalanche/AllowList.sol\";\r\nimport \"../avalanche/interfaces/INativeMinter.sol\";\r\n\r\n/// @title PLAYA3ULL Supply controller for all tokens minted, this includes the initial genesis allocation\r\n/// @author Sam (PLAYA3ULL)\r\n\r\ncontract PLAYA3ULLSupplyController is INativeMinter, AllowList, Ownable {\r\n    INativeMinter immutable nativeMinter;\r\n\r\n    /**\r\n     * @notice The total supply cap for PLAYA3ULL\r\n     */\r\n    uint256 public constant cap = (50 * (10**9)) * (10**18);\r\n\r\n    /**\r\n     * @notice The total amount of PLAYA3ULL minted\r\n     */\r\n    uint256 public totalMinted = 0;\r\n\r\n    /**\r\n     * @notice The address of the gas burn contract for Avalanche Subnets\r\n     */\r\n    address public gasBurn = 0x0100000000000000000000000000000000000000;\r\n\r\n    /**\r\n     * @dev Reverts when trying to mint more than the cap\r\n     */\r\n    error CannotMintMoreThanCap();\r\n\r\n    constructor(INativeMinter _nativeMinter, uint256 _existingSupply) {\r\n        _assertZeroAddress(address(_nativeMinter));\r\n\r\n        nativeMinter = _nativeMinter;\r\n        totalMinted = _existingSupply;\r\n    }\r\n    \r\n    /**\r\n     * @param addr Address to mint native coin to\r\n     * @param amount The amount of native coins to mint\r\n     */\r\n    function mintNativeCoin(address addr, uint256 amount) external override onlyEnabled {\r\n        _assertZeroAddress(addr);\r\n        _assertMintMoreThanZero(amount);\r\n        _assertMintMoreThanCap(amount);\r\n\r\n        nativeMinter.mintNativeCoin(addr, amount);\r\n        totalMinted += amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total supply of coints minted, less the amount burned from Gas\r\n     * @return The total supply of coins minted, less the amount burned\r\n     */\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalMinted - totalBurn();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total amount of coins burned from Gas\r\n     * @return The total amount of coins burned from Gas\r\n     */\r\n    function totalBurn() public view returns(uint256) {\r\n        return gasBurn.balance;\r\n    }\r\n\r\n    function _assertZeroAddress(address addr) internal pure {\r\n        if(addr == address(0)) {\r\n            revert ZeroAddress();\r\n        }\r\n    }\r\n\r\n    function _assertMintMoreThanZero(uint256 amount) internal pure {\r\n        if(amount == 0) {\r\n            revert CannotMintZero();\r\n        }\r\n    }\r\n\r\n    function _assertMintMoreThanCap(uint256 amount) internal view {\r\n        if(totalSupply() + amount > cap) {\r\n            revert CannotMintMoreThanCap();\r\n        }\r\n    }\r\n}"
    },
    "contracts/core/TreasuryManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {Ratio} from \"../misc/Ratio.sol\";\r\nimport {ITreasuryManager} from \"./interfaces/ITreasuryManager.sol\";\r\n\r\n/**\r\n * @title TreasuryManager\r\n * @author Jourdan (@jourdanhaines), Sam (@samthompsonkennedy)\r\n * @notice TreasuryManager is a contract for managing the treasury\r\n *         of the protocol.\r\n */\r\ncontract TreasuryManager is Ownable, ITreasuryManager {\r\n    using Ratio for uint256;\r\n\r\n    /// @notice The ratio of funds to burn on withdrawals\r\n    uint256 public burnRatio = 1000; // 10%\r\n\r\n    /// @notice Tracks the total number of withdrawals\r\n    uint256 public burns;\r\n\r\n    /// @notice The treasury address to receive funds\r\n    address public treasury;\r\n\r\n    /// @notice The address to send funds to be burnt\r\n    address public immutable burnAddress =\r\n        0x0000000000000000000000000000000000000000;\r\n\r\n    /// @notice Tracks the amount of funds burnt on withdrawals\r\n    mapping(uint256 => WithdrawalBurn) public withdrawalBurns;\r\n\r\n    constructor(address _treasury) {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury address.\r\n     *\r\n     * @param _treasury The new treasury address.\r\n     */\r\n    function setTreasuryAddress(address _treasury) external onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        // Calculate the burn amount and the amount left over\r\n        uint256 burnAmount = amount.getPart(burnRatio);\r\n        uint256 amountAfterBurn = amount - burnAmount;\r\n\r\n        // Transfer the funds, burning those sent to the burn address\r\n        payable(burnAddress).transfer(burnAmount);\r\n        payable(treasury).transfer(amountAfterBurn);\r\n\r\n        // Store the withdrawal burn\r\n        withdrawalBurns[burns] = WithdrawalBurn({\r\n            total: amount,\r\n            burned: burnAmount,\r\n            timestamp: block.timestamp\r\n        });\r\n\r\n        burns++;\r\n\r\n        emit AmountBurned(burnAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the burn ratio.\r\n     *\r\n     * @param _burnRatio    The new burn ratio.\r\n     */\r\n    function setBurnRatio(uint256 _burnRatio) external onlyOwner {\r\n        burnRatio = _burnRatio;\r\n\r\n        emit BurnRatioUpdated(_burnRatio);\r\n    }\r\n\r\n    /**\r\n     * @notice Called when funds are sent to the contract without data.\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/fakes/ERC20.sol": {
      "content": "\r\npragma solidity ^0.8.4;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * A Fake ERC20 contract for testing. Can create as many named toknens as we need to represent\r\n * on chain Tokens.\r\n *\r\n * Open mint to aid testing.\r\n */\r\ncontract FakeERC20 is ERC20 {\r\n    constructor (string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\r\n\r\n    function mint(address to, uint256 amount) external {\r\n      _mint(to, amount);\r\n    }\r\n}"
    },
    "contracts/fakes/ERC2981.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\ncontract FakeERC2981 is ERC721, IERC2981, ERC165Storage {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter private _tokenIdCounter;\r\n\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    address public royaltyReceiver;\r\n\r\n    constructor(string memory name_, string memory symbol_, address receiver_) ERC721(name_, symbol_) {\r\n        royaltyReceiver = receiver_;\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC2981);\r\n    }\r\n\r\n    function mint(address to) public {\r\n        uint256 tokenId = _tokenIdCounter.current();\r\n        _tokenIdCounter.increment();\r\n        _safeMint(to, tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165, ERC165Storage) returns (bool) {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    function royaltyInfo(\r\n        uint256,\r\n        uint256 _salePrice\r\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (royaltyReceiver, (_salePrice * 750) / 10000);\r\n    }\r\n}"
    },
    "contracts/fakes/ERC721.sol": {
      "content": "pragma solidity ^0.8.4;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\ncontract FakeERC721 is ERC721 {\r\n    using Counters for Counters.Counter;\r\n    Counters.Counter private _tokenIdCounter;\r\n\r\n    constructor(string memory name_, string memory symbol_) ERC721(name_, symbol_) {}\r\n\r\n    function mint(address to) public {\r\n        uint256 tokenId = _tokenIdCounter.current();\r\n        _tokenIdCounter.increment();\r\n        _safeMint(to, tokenId);\r\n    }\r\n}"
    },
    "contracts/fakes/NativeMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"../avalanche/interfaces/INativeMinter.sol\";\r\n\r\n/// @author Sam (PLAYA3ULL)\r\n/// @notice  Local testing helper to mint coins in a similar manner to Avalanche Subnets\r\n/// @dev This contract will need to have a native coin balance https://hardhat.org/hardhat-network/docs/reference#hardhat_setbalance\r\n\r\ncontract FakeNativeMinter is INativeMinter {\r\n\r\n    /// @notice Transfer native coins to address\r\n    function mintNativeCoin(address addr, uint256 amount) external {\r\n        (bool sent,) = addr.call{value: amount}(\"\");\r\n\r\n        require(sent, \"FakeNativeMinter: Failed to transfer coins\");\r\n    }\r\n\r\n    /// @dev Not needed locally\r\n    function setAdmin(address addr) external override {}\r\n\r\n    /// @dev Not needed locally\r\n    function setEnabled(address addr) external override {}\r\n\r\n    /// @dev Not needed locally\r\n    function setNone(address addr) external override {}\r\n    /// @dev Not needed locally\\\r\n    function readAllowList(address addr)\r\n        external\r\n        view\r\n        override\r\n        returns (uint256 role)\r\n    {}\r\n}"
    },
    "contracts/fakes/USD.sol": {
      "content": "\r\npragma solidity ^0.8.4;\r\n// SPDX-License-Identifier: GPL-3.0-or-later\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * A Fake ERC20 contract for testing. Can create as many named toknens as we need to represent\r\n * on chain Tokens.\r\n *\r\n * Open mint to aid testing.\r\n */\r\ncontract FakeUSD is ERC20 {\r\n    constructor (string memory name_, string memory symbol_) ERC20(name_, symbol_) {}\r\n\r\n    function mint(address to, uint256 amount) external {\r\n      _mint(to, amount);\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n\t\treturn 6;\r\n\t}\r\n}"
    },
    "contracts/lottery/interfaces/ILottery.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLLottery\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice IPLAYA3ULLLottery contains all external structs \r\n *         for the lottery.\r\n */\r\ninterface IPLAYA3ULLLottery {\r\n    /**\r\n     * @dev A lottery ticket contains three components: an\r\n     *      address of the owner of the ticket, the purchase\r\n     *      price of the ticket (this is predominantly used\r\n     *      if the lottery ticket price is changed at a\r\n     *      later date), and the timestamp that the ticket\r\n     *      was purchased at.\r\n     */\r\n    struct LotteryTicket {\r\n        address holder;\r\n        uint256 price;\r\n        uint256 purchased;\r\n    }\r\n\r\n    /**\r\n     * @dev A winnings tier represents a single tier that a\r\n     *      drawn winner resides in. Each tier contains two\r\n     *      components: the number of cumulative winners at\r\n     *      that tier (for example a second tier winning\r\n     *      count is equal to the first tier count plus the\r\n     *      count for the second tier), and an amount that\r\n     *      represents the number of winnings in that tier.\r\n     */\r\n    struct WinningsTier {\r\n        uint256 winnerCount;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     * @dev A round winner contains two components: an\r\n     *      address of the winner, and the amount of winnings\r\n     *      the winner received.\r\n     */\r\n    struct RoundWinner {\r\n        address holder;\r\n        uint256 winnings;\r\n    }\r\n\r\n    /**\r\n     * @dev A lottery round contains two components: the\r\n     *      total number of winners that were drawn for\r\n     *      that round, and a winners mapping that tracks\r\n     *      and stores the drawn winner at each index.\r\n     */\r\n    struct LotteryRound {\r\n        uint256 numWinners;\r\n        mapping(uint => RoundWinner) winners;\r\n    }\r\n}"
    },
    "contracts/lottery/interfaces/ILotteryEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {IPLAYA3ULLLottery} from \"./ILottery.sol\";\r\n\r\n/**\r\n * @title IPLAYA3ULLLotteryEventsAndErrors\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice IPLAYA3ULLLotteryEventsAndErrors contains all external\r\n *         events, and errors for the lottery.\r\n */\r\ninterface IPLAYA3ULLLotteryEventsAndErrors is IPLAYA3ULLLottery {\r\n    /**\r\n     * @dev Emit an event whenever a ticket is purchased.\r\n     *\r\n     * @param holder    The address of the ticket purchaser.\r\n     * @param id        The ticket id that was purchased.\r\n     * @param price     The price at the time of purchase.\r\n     */\r\n    event TicketPurchased(\r\n        address indexed holder,\r\n        uint256 indexed id,\r\n        uint256 price\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a ticket is sold.\r\n     *\r\n     * @param holder        The address that owned the ticket prior to the\r\n     *                      sale of the ticket.\r\n     * @param soldId        The ID of the ticket that was sold.\r\n     * @param swappedIds    An array that tracks the IDs of the tickets\r\n     *                      that were swapped in order to fulfill the\r\n     *                      sale of the the ticket.\r\n     *                      NOTE: if the ticket was valid, the\r\n     *                      `swappedIds` array will be of length two,\r\n     *                      however if the ticket was invalid, the array\r\n     *                      will be of length one.\r\n     * @param price         The sale price of the ticket.\r\n     */\r\n    event TicketSold(\r\n        address indexed holder,\r\n        uint256 indexed soldId,\r\n        uint256[] swappedIds,\r\n        uint256 price\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a new lottery begins.\r\n     *\r\n     * @param startTime The timestamp the lottery began.\r\n     * @param endTime   The timestamp that the lottery will be available\r\n     *                  to draw winners at.\r\n     */\r\n    event LotteryStarted(uint256 startTime, uint256 endTime);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the price of a ticket is updated.\r\n     *\r\n     * @param price The updated sale price for tickets, at this point\r\n     *              forward.\r\n     * @param time  The timestamp that the price was updated at.\r\n     */\r\n    event PriceUpdated(uint256 price, uint256 time);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a winner is drawn.\r\n     *\r\n     * @param round     The round index the winner was drawn in.\r\n     * @param time      The timestamp the winner was drawn at.\r\n     * @param winner    The address of the winner.\r\n     * @param winnings  The amount of winnings the winner received.\r\n     * @param tier      The tier index the winner was drawin in.\r\n     */\r\n    event WinnerDrawn(\r\n        uint256 indexed round,\r\n        uint256 time,\r\n        address indexed winner,\r\n        uint256 winnings,\r\n        uint256 indexed tier\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event when the winning tiers are updated.\r\n     *\r\n     * @param tiers The new tiers that are now in effect.\r\n     */\r\n    event TiersUpdated(WinningsTier[] tiers);\r\n\r\n    /**\r\n     * @dev Revert with an error if there is no active lottery.\r\n     */\r\n    error LotteryInactive();\r\n\r\n    /**\r\n     * @dev Revert with an error when provided value is not equal to\r\n     *      the expected value.\r\n     *\r\n     * @param expectedValue The expected value that was not provided.\r\n     */\r\n    error InvalidValueProvided(uint256 expectedValue);\r\n\r\n    /**\r\n     * @dev Revert with an error when the provided count does not\r\n     *      fulfill min < value < max.\r\n     *\r\n     * @param min   The minimum count to provide.\r\n     * @param max   The maximum count to provide.\r\n     */\r\n    error InvalidCountProvided(uint256 min, uint256 max);\r\n\r\n    /**\r\n     * @dev Revert with an error when caller owns zero tickets, but\r\n     *      is trying to sell a ticket.\r\n     */\r\n    error ZeroOwnedTickets();\r\n\r\n    /**\r\n     * @dev Revert with an error when seller does not provide indices\r\n     *      that fulfill 0 < indiceLength < max.\r\n     *\r\n     * @param min   The minimum number of indices to provide.\r\n     * @param max   The maximum number of indices to provide.\r\n     */\r\n    error IndicesOutOfRange(uint256 min, uint256 max);\r\n\r\n    /**\r\n     * @dev Revert with an error when caller attempts to access a\r\n     *      ticket that does not exist.\r\n     */\r\n    error TicketDoesNotExist();\r\n\r\n    /**\r\n     * @dev Revert with an error when caller attempts to sell a ticket\r\n     *      they do not own.\r\n     */\r\n    error TicketOwnerNotSeller();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to draw a winner, or\r\n     *      trying to start a new lottery whilst the lottery is still\r\n     *      in progress.\r\n     *\r\n     * @param endTime   The timestamp the lottery will end, and\r\n     *                  winners may be drawn or a new lottery may\r\n     *                  be started.\r\n     */\r\n    error LotteryInProgress(uint256 endTime);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to provide a start time\r\n     *      that is greater than the provided end time.\r\n     */\r\n    error IllogicalTimesProvided();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to provide an end time\r\n     *      that is not in the future.\r\n     */\r\n    error EndTimeNotInFuture();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to draw a winner whilst\r\n     *      no winning tiers have been set.\r\n     */\r\n    error NoWinningsToProvide();\r\n\r\n    /**\r\n     * @dev Revert with an error when updating winning tiers, but the\r\n     *      provided input data lengths do not match.\r\n     */\r\n    error TierInputLengthsDoNotMatch();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to start a lottery but the\r\n     *      price is zero.\r\n     */\r\n    error PriceNotSet();\r\n}\r\n"
    },
    "contracts/lottery/interfaces/ILotteryVaultEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLLotteryVaultEventsAndErrors\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice IPLAYA3ULLLotteryVaultEventsAndErrors contains all external\r\n *         events, and errors for the lottery vault.\r\n */\r\ninterface IPLAYA3ULLLotteryVaultEventsAndErrors {\r\n    /**\r\n     * @dev Emit an event when a winner has been paid.\r\n     * \r\n     * @param amount    The amount the winner received.\r\n     * @param winner    The address of the winner.\r\n     */\r\n    event WinnerPaid(uint256 indexed amount, address indexed winner);\r\n\r\n    /**\r\n     * @dev Emit an event when funds have been withdrawn.\r\n     * \r\n     * @param amount        The amount of funds withdrawn.\r\n     * @param newBalance    The balance after funds were\r\n     *                      withdrawn.\r\n     */\r\n    event FundsWithdrawn(uint256 amount, uint256 newBalance);\r\n\r\n    /**\r\n     * @dev Emit an event when funds have been deposited.\r\n     * \r\n     * @param amount        The amount of funds deposited.\r\n     * @param newBalance    The balance after funds were\r\n     *                      deposited.\r\n     */\r\n    event FundsDeposited(uint256 amount, uint256 newBalance);\r\n\r\n    /**\r\n     * @dev Revert if attempting to withdraw or distribute\r\n     *      funds that would exceed the balance of the\r\n     *      contract.\r\n     * \r\n     * @param balance   The current balance of the contract.\r\n     */\r\n    error NotEnoughFunds(uint256 balance);\r\n}"
    },
    "contracts/lottery/Lottery.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\r\n\r\nimport {IPLAYA3ULLLotteryEventsAndErrors} from \"./interfaces/ILotteryEventsAndErrors.sol\";\r\nimport {PLAYA3ULLLotteryVault} from \"./LotteryVault.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games Lottery Contract\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice This contract serves as the core and central brain for\r\n *         the PLAYA3ULL Games Lottery ecosystem.\r\n */\r\ncontract PLAYA3ULLLottery is\r\n    IPLAYA3ULLLotteryEventsAndErrors,\r\n    Initializable,\r\n    UUPSUpgradeable,\r\n    OwnableUpgradeable\r\n{\r\n    /// @notice Whether there is an active lottery.\r\n    bool public isActive;\r\n\r\n    /// @notice Represents the exact price of a ticket.\r\n    uint256 public price;\r\n\r\n    /// @notice The maximum number of tickets that can be purchased in\r\n    ///         a single transaction.\r\n    uint256 public maxPurchase;\r\n\r\n    /// @notice The maximum number of tickets that can be sold in a\r\n    ///         single transaction.\r\n    uint256 public maxSell;\r\n\r\n    /// @notice The total number of tickets that exist.\r\n    uint256 public totalTickets;\r\n\r\n    /// @notice The total number of valid tickets that exist.\r\n    ///         A valid ticket is one that was purchased prior to the\r\n    ///         start time of the current lottery round.\r\n    uint256 public totalValidTickets;\r\n\r\n    /// @notice The time at which the current lottery round will start.\r\n    uint256 public timeStart;\r\n\r\n    /// @notice The time at which the current lottery round will end.\r\n    uint256 public timeEnd;\r\n\r\n    /// @notice The number of winners that have currently been drawn for\r\n    ///         the current lottery round.\r\n    uint256 public drawnWinnersCount;\r\n\r\n    /// @notice Represents the address of the lottery vault, where\r\n    ///         winnings will be distributed from.\r\n    PLAYA3ULLLotteryVault public vault;\r\n\r\n    /// @notice The tiers of winnings that drawn winners will receive\r\n    ///         payouts from.\r\n    WinningsTier[] public winnerTiers;\r\n\r\n    /// @notice Stores and tracks the past lottery rounds, and their\r\n    ///         winners.\r\n    LotteryRound[] public rounds;\r\n\r\n    /// @dev Stores all currently purchased tickets that exist.\r\n    LotteryTicket[] private tickets;\r\n\r\n    /// @dev Tracks the number of tickets held by a given address.\r\n    mapping(address => uint256) private holders;\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize() public initializer {\r\n        __Ownable_init();\r\n        __UUPSUpgradeable_init();\r\n\r\n        isActive = false;\r\n        maxPurchase = 10;\r\n        maxSell = 10;\r\n        totalTickets = 0;\r\n        totalValidTickets = 0;\r\n        drawnWinnersCount = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of tickets held for the given\r\n     *         address.\r\n     *\r\n     * @param _holder   The address to retrieve ticket balance from.\r\n     *\r\n     * @return The number of tickets the provided address holds.\r\n     */\r\n    function balanceOf(address _holder) public view returns (uint256) {\r\n        return holders[_holder];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the lottery ticket at the given index.\r\n     *\r\n     * @param index The index at which the ticket exists.\r\n     *\r\n     * @return The retrieved lottery ticket data.\r\n     */\r\n    function getTicket(\r\n        uint256 index\r\n    ) public view returns (LotteryTicket memory) {\r\n        _assertTicketExists(index);\r\n        return tickets[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the total rounds that have happened.\r\n     *\r\n     * @return The number of surpassed rounds.\r\n     */\r\n    function getRounds() public view returns (uint256) {\r\n        return rounds.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the winner at the given round and winner\r\n     *         index.\r\n     *\r\n     * @param _round    The round to retrieve the winner from.\r\n     * @param _winner   The winner index within the given round.\r\n     *\r\n     * @return The data of the winner at the given indices.\r\n     */\r\n    function getRoundWinner(\r\n        uint256 _round,\r\n        uint256 _winner\r\n    ) public view returns (RoundWinner memory) {\r\n        return rounds[_round].winners[_winner];\r\n    }\r\n\r\n    /**\r\n     * @notice Purchases a ticket for the sender.\r\n     *\r\n     * @param count The number of tickets to purchase\r\n     */\r\n    function purchase(uint256 count) external payable {\r\n        _assertLotteryActive();\r\n        _assertValidValue(msg.value, price * count);\r\n        _assertValidCount(count);\r\n\r\n        for (uint i = 0; i < count; i++) {\r\n            _insertTicket(msg.sender, block.timestamp, price);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Purchases a ticket for a given receiver.\r\n     *\r\n     * @param receiver  The address to which the tickets will belong.\r\n     * @param count     The number of tickets to purchase.\r\n     */\r\n    function purchaseFor(address receiver, uint256 count) external payable {\r\n        _assertLotteryActive();\r\n        _assertValidValue(msg.value, price * count);\r\n        _assertValidCount(count);\r\n\r\n        for (uint i = 0; i < count; i++) {\r\n            _insertTicket(receiver, block.timestamp, price);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sells tickets in a given array of indices.\r\n     *\r\n     * @param indices   Array of indexes of tickets to sell.\r\n     */\r\n    function sell(uint256[] memory indices) external {\r\n        _assertNonZeroTickets();\r\n        _assertIndicesInRange(indices.length);\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            _deleteTicket(msg.sender, indices[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Starts a new lottery round.\r\n     *\r\n     * @param start The start timestamp for the new round.\r\n     * @param end   The end timestamp for the new round.\r\n     */\r\n    function startNew(uint256 start, uint256 end) external onlyOwner {\r\n        _assertLotteryInactive();\r\n        _assertLogicalTimes(start, end);\r\n        _assertFutureEndTime(end);\r\n        _assertPriceSet();\r\n\r\n        timeStart = start;\r\n        timeEnd = end;\r\n\r\n        isActive = true;\r\n\r\n        LotteryRound storage round = rounds.push();\r\n        round.numWinners = winnerTiers[winnerTiers.length - 1].winnerCount;\r\n\r\n        emit LotteryStarted(timeStart, timeEnd);\r\n    }\r\n\r\n    /**\r\n     * @notice Draws a random valid ticket as a winner.\r\n     *\r\n     * @param seed  Input seed to generate a random value from,\r\n     *              should be random in itself.\r\n     */\r\n    function drawWinner(uint256 seed) external onlyOwner {\r\n        _assertLotteryActive();\r\n        _assertWinningsExist();\r\n        _assertLotteryFinished();\r\n\r\n        if (\r\n            totalValidTickets == 0 ||\r\n            drawnWinnersCount == winnerTiers[winnerTiers.length - 1].winnerCount\r\n        ) {\r\n            _complete();\r\n            return;\r\n        }\r\n\r\n        uint256 winnings = winnerTiers[0].amount;\r\n        uint256 tier = 0;\r\n\r\n        for (uint i = 1; i < winnerTiers.length; i++) {\r\n            if (drawnWinnersCount >= winnerTiers[i - 1].winnerCount) {\r\n                winnings = winnerTiers[i].amount;\r\n                tier = i;\r\n            }\r\n        }\r\n\r\n        uint256 winnerIndex = uint(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    block.timestamp,\r\n                    block.difficulty,\r\n                    totalTickets,\r\n                    msg.sender,\r\n                    seed\r\n                )\r\n            )\r\n        ) % totalValidTickets;\r\n\r\n        rounds[rounds.length - 1].winners[drawnWinnersCount] = RoundWinner({\r\n            holder: tickets[winnerIndex].holder,\r\n            winnings: winnings\r\n        });\r\n\r\n        vault.payWinner(winnings, tickets[winnerIndex].holder);\r\n\r\n        drawnWinnersCount++;\r\n\r\n        emit WinnerDrawn(\r\n            rounds.length,\r\n            block.timestamp,\r\n            tickets[winnerIndex].holder,\r\n            winnings,\r\n            tier\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the vault contract to distribute winnings\r\n     *         from.\r\n     *\r\n     * @param _vault    The new vault contract.\r\n     */\r\n    function setVaultContract(PLAYA3ULLLotteryVault _vault) external onlyOwner {\r\n        vault = _vault;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the purchase price for a ticket.\r\n     *\r\n     * @param _price    The new ticket price.\r\n     */\r\n    function setPrice(uint256 _price) external onlyOwner {\r\n        _assertLotteryInactive();\r\n\r\n        price = _price;\r\n\r\n        emit PriceUpdated(_price, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the winning tiers that dictate the\r\n     *         amount of funds a winner receives.\r\n     *\r\n     * @param _winners  Array of cumulative winner counts for\r\n     *                  each tier.\r\n     * @param _winnings Array of winnings to distribute at\r\n     *                  each tier.\r\n     */\r\n    function setWinningsTiers(\r\n        uint256[] memory _winners,\r\n        uint256[] memory _winnings\r\n    ) external onlyOwner {\r\n        _assertTierInputsMatch(_winners.length, _winnings.length);\r\n\r\n        while (winnerTiers.length > 0) {\r\n            winnerTiers.pop();\r\n        }\r\n\r\n        for (uint i = 0; i < _winners.length; i++) {\r\n            WinningsTier memory tier = WinningsTier({\r\n                winnerCount: _winners[i],\r\n                amount: _winnings[i]\r\n            });\r\n            winnerTiers.push(tier);\r\n        }\r\n\r\n        emit TiersUpdated(winnerTiers);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to sell tickets for a given\r\n     *        address.\r\n     *\r\n     * @param holder    The address to sell tickets for.\r\n     * @param indices   Array of indexes of tickets to sell.\r\n     */\r\n    function sellFor(\r\n        address holder,\r\n        uint256[] memory indices\r\n    ) external onlyOwner {\r\n        if (holders[holder] == 0) {\r\n            revert ZeroOwnedTickets();\r\n        }\r\n\r\n        _assertIndicesInRange(indices.length);\r\n\r\n        for (uint i = 0; i < indices.length; i++) {\r\n            _deleteTicketFor(holder, indices[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to delete a lottery ticket from\r\n     *      the array of tickets.\r\n     *\r\n     * @param _holder   The owner address of the ticket.\r\n     * @param _index    The index in the ticket array to delete.\r\n     */\r\n    function _deleteTicketFor(address _holder, uint256 _index) internal {\r\n        _assertTicketExists(_index);\r\n        _assertCallerOwnsTicket(_index, _holder);\r\n\r\n        payable(owner()).transfer(tickets[_index].price);\r\n\r\n        uint256 indexToRemove = _index;\r\n        bool isValidTicketSale = _index < totalValidTickets;\r\n        uint256[] memory swappedTicketIds = new uint256[](\r\n            isValidTicketSale ? 2 : 1\r\n        );\r\n\r\n        if (_index < totalValidTickets) {\r\n            tickets[_index] = tickets[totalValidTickets - 1];\r\n            indexToRemove = totalValidTickets - 1;\r\n\r\n            swappedTicketIds[0] = totalValidTickets - 1;\r\n\r\n            totalValidTickets--;\r\n        }\r\n\r\n        swappedTicketIds[isValidTicketSale ? 1 : 0] = totalTickets - 1;\r\n\r\n        emit TicketSold(\r\n            _holder,\r\n            _index,\r\n            swappedTicketIds,\r\n            tickets[indexToRemove].price\r\n        );\r\n\r\n        tickets[indexToRemove] = tickets[totalTickets - 1];\r\n\r\n        tickets.pop();\r\n\r\n        holders[_holder]--;\r\n        totalTickets--;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to create and insert a lottery ticket\r\n     *      into the array of tickets.\r\n     *\r\n     * @param _to       The address to receive the tickets.\r\n     * @param _time     The timestamp that the purchase was made.\r\n     * @param _price    The purchase price of the ticket.\r\n     */\r\n    function _insertTicket(\r\n        address _to,\r\n        uint256 _time,\r\n        uint256 _price\r\n    ) internal {\r\n        LotteryTicket memory ticket = LotteryTicket({\r\n            holder: _to,\r\n            price: _price,\r\n            purchased: _time\r\n        });\r\n\r\n        tickets.push(ticket);\r\n\r\n        emit TicketPurchased(_to, totalTickets, price);\r\n\r\n        holders[_to]++;\r\n        totalTickets++;\r\n\r\n        if (block.timestamp <= timeStart) {\r\n            totalValidTickets++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to delete a lottery ticket from\r\n     *      the array of tickets.\r\n     *\r\n     * @param _holder   The owner address of the ticket.\r\n     * @param _index    The index in the ticket array to delete.\r\n     */\r\n    function _deleteTicket(address _holder, uint256 _index) internal {\r\n        _assertTicketExists(_index);\r\n        _assertCallerOwnsTicket(_index, _holder);\r\n\r\n        payable(_holder).transfer(tickets[_index].price);\r\n\r\n        uint256 indexToRemove = _index;\r\n        bool isValidTicketSale = _index < totalValidTickets;\r\n        uint256[] memory swappedTicketIds = new uint256[](\r\n            isValidTicketSale ? 2 : 1\r\n        );\r\n\r\n        if (_index < totalValidTickets) {\r\n            tickets[_index] = tickets[totalValidTickets - 1];\r\n            indexToRemove = totalValidTickets - 1;\r\n\r\n            swappedTicketIds[0] = totalValidTickets - 1;\r\n\r\n            totalValidTickets--;\r\n        }\r\n\r\n        swappedTicketIds[isValidTicketSale ? 1 : 0] = totalTickets - 1;\r\n\r\n        emit TicketSold(\r\n            _holder,\r\n            _index,\r\n            swappedTicketIds,\r\n            tickets[indexToRemove].price\r\n        );\r\n\r\n        tickets[indexToRemove] = tickets[totalTickets - 1];\r\n\r\n        tickets.pop();\r\n\r\n        holders[_holder]--;\r\n        totalTickets--;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to complete the current round.\r\n     */\r\n    function _complete() internal {\r\n        isActive = false;\r\n        drawnWinnersCount = 0;\r\n        totalValidTickets = totalTickets;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery is\r\n     *      not active.\r\n     */\r\n    function _assertLotteryActive() internal view {\r\n        if (!isActive) {\r\n            revert LotteryInactive();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to revert if the provided\r\n     *      value is not equal to the expected value.\r\n     *\r\n     * @param provided  The value that was provided.\r\n     * @param expected  The value that was expected.\r\n     */\r\n    function _assertValidValue(\r\n        uint256 provided,\r\n        uint256 expected\r\n    ) internal pure {\r\n        if (provided != expected) {\r\n            revert InvalidValueProvided(expected);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the provided\r\n     *      value is outside the expected range.\r\n     *\r\n     * @param provided  The value that was provided.\r\n     */\r\n    function _assertValidCount(uint256 provided) internal view {\r\n        if (!(0 < provided && provided <= maxPurchase)) {\r\n            revert InvalidCountProvided(0, maxPurchase);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the sender\r\n     *      holds zero tickets.\r\n     */\r\n    function _assertNonZeroTickets() internal view {\r\n        if (holders[msg.sender] == 0) {\r\n            revert ZeroOwnedTickets();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied\r\n     *      indices are outside the expected range.\r\n     *\r\n     * @param length    The length of the index array.\r\n     */\r\n    function _assertIndicesInRange(uint256 length) internal view {\r\n        if (!(0 < length && length <= maxSell)) {\r\n            revert IndicesOutOfRange(0, maxSell);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied\r\n     *      index refers to a ticket that exists.\r\n     *\r\n     * @param index The index of the ticket to verify.\r\n     */\r\n    function _assertTicketExists(uint256 index) internal view {\r\n        if (index >= totalTickets) {\r\n            revert TicketDoesNotExist();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the caller\r\n     *      owns the ticket at the supplied index.\r\n     *\r\n     * @param index     The index of the ticket to verify.\r\n     * @param caller    The expected owner of the ticket.\r\n     */\r\n    function _assertCallerOwnsTicket(\r\n        uint256 index,\r\n        address caller\r\n    ) internal view {\r\n        if (tickets[index].holder != caller) {\r\n            revert TicketOwnerNotSeller();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery\r\n     *      is active.\r\n     */\r\n    function _assertLotteryInactive() internal view {\r\n        if (isActive) {\r\n            revert LotteryInProgress(timeEnd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery\r\n     *      is still in progress.\r\n     */\r\n    function _assertLotteryFinished() internal view {\r\n        if (block.timestamp < timeEnd) {\r\n            revert LotteryInProgress(timeEnd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to revert if the supplied\r\n     *      times are not logical.\r\n     *\r\n     * @param start The timestamp of the lottery start.\r\n     * @param end   The timestamp that the lottery will end.\r\n     */\r\n    function _assertLogicalTimes(uint256 start, uint256 end) internal pure {\r\n        if (start >= end) {\r\n            revert IllogicalTimesProvided();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied\r\n     *      end time is not in the future.\r\n     *\r\n     * @param end   The end timestamp to verify against the\r\n     *              current timestamp.\r\n     */\r\n    function _assertFutureEndTime(uint256 end) internal view {\r\n        if (end <= block.timestamp) {\r\n            revert EndTimeNotInFuture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if there exists\r\n     *      no winning tiers.\r\n     */\r\n    function _assertWinningsExist() internal view {\r\n        if (winnerTiers.length == 0) {\r\n            revert NoWinningsToProvide();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to revert if the supplied\r\n     *      input lengths do not match.\r\n     *\r\n     * @param inputOneLength    The length of the first input.\r\n     * @param inputTwoLength    The length of the second input.\r\n     */\r\n    function _assertTierInputsMatch(\r\n        uint256 inputOneLength,\r\n        uint256 inputTwoLength\r\n    ) internal pure {\r\n        if (inputOneLength != inputTwoLength) {\r\n            revert TierInputLengthsDoNotMatch();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery\r\n     *     has not been priced.\r\n     */\r\n    function _assertPriceSet() internal view {\r\n        if (price == 0) {\r\n            revert PriceNotSet();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to allow upgrades to this contract.\r\n     *\r\n     * @param newImplementation The address of the new implementation.\r\n     */\r\n    function _authorizeUpgrade(\r\n        address newImplementation\r\n    ) internal override onlyOwner {}\r\n}\r\n"
    },
    "contracts/lottery/LotteryVault.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IPLAYA3ULLLotteryVaultEventsAndErrors} from \"./interfaces/ILotteryVaultEventsAndErrors.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games Lottery Vault Contract\r\n * @author Jourdan (PLAYAY3ULL), Sam (PLAYAY3ULL)\r\n * @notice This contract controls the storage and distribution\r\n *         of funds to lottery winners.\r\n *         Once the lottery contract has been set as part of\r\n *         the constructor, it may not change again without\r\n *         deploying a new vault.\r\n */\r\ncontract PLAYA3ULLLotteryVault is\r\n    Ownable,\r\n    IPLAYA3ULLLotteryVaultEventsAndErrors\r\n{\r\n    /// @notice The address of the core lottery contract.\r\n    address public lottery;\r\n\r\n    /// @dev Modifier for only allowing the lottery to call\r\n    ///      certain functions.\r\n    modifier onlyLottery() {\r\n        require(msg.sender == lottery);\r\n        _;\r\n    }\r\n\r\n    constructor(address _lottery) {\r\n        lottery = _lottery;\r\n    }\r\n\r\n    /**\r\n     * @notice Distributes the amount of winnings to the\r\n     *         supplied winner address.\r\n     *\r\n     * @param amount    The amount of winnings the winner\r\n     *                  will receive.\r\n     * @param winner    The address to receive the winnings.\r\n     */\r\n    function payWinner(uint256 amount, address winner) external onlyLottery {\r\n        _assertEnoughFunds(amount);\r\n        payable(winner).transfer(amount);\r\n\r\n        emit WinnerPaid(amount, winner);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        _assertEnoughFunds(amount);\r\n        payable(msg.sender).transfer(amount);\r\n\r\n        emit FundsWithdrawn(amount, address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Helper function to deposit funds to this\r\n     *         contract.\r\n     */\r\n    function deposit() external payable {\r\n        emit FundsDeposited(msg.value, address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if attempting to\r\n     *      withdraw or distribute funds that would exceed\r\n     *      the balance of the contract.\r\n     *\r\n     * @param requestedAmount   The amount to withdraw or\r\n     *                          distribute.\r\n     */\r\n    function _assertEnoughFunds(uint256 requestedAmount) internal view {\r\n        if (requestedAmount > address(this).balance) {\r\n            revert NotEnoughFunds(address(this).balance);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/lottery/NodeLottery.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IPLAYA3ULLLotteryEventsAndErrors} from \"./interfaces/ILotteryEventsAndErrors.sol\";\r\nimport {PLAYA3ULLLotteryVault} from \"./LotteryVault.sol\";\r\nimport {PLAYA3ULLNode} from \"../core/Node.sol\";\r\n\r\ncontract NodeLottery is IPLAYA3ULLLotteryEventsAndErrors, Ownable {\r\n    /// @notice Whether there is an active lottery.\r\n    bool public isActive;\r\n\r\n    /// @notice The time at which the current lottery round will start.\r\n    uint256 public timeStart;\r\n\r\n    /// @notice The time at which the current lottery round will end.\r\n    uint256 public timeEnd;\r\n\r\n    /// @notice The number of winners that have currently been drawn for\r\n    ///         the current lottery round.\r\n    uint256 public drawnWinnersCount;\r\n\r\n    /// @notice Represents the address of the lottery vault, where\r\n    ///         winnings will be distributed from.\r\n    PLAYA3ULLLotteryVault public vault;\r\n\r\n    /// @notice Represents the address of the PLAYA3ULL Node contract,\r\n    ///         where entries will be pulled from.\r\n    PLAYA3ULLNode public node;\r\n\r\n    /// @notice The tiers of winnings that drawn winners will receive\r\n    ///         payouts from.\r\n    WinningsTier[] public winnerTiers;\r\n\r\n    /// @notice Stores and tracks the past lottery rounds, and their\r\n    ///         winners.\r\n    LotteryRound[] public rounds;\r\n\r\n    constructor(address _node) {\r\n        isActive = false;\r\n        drawnWinnersCount = 0;\r\n\r\n        node = PLAYA3ULLNode(_node);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the total rounds that have happened.\r\n     *\r\n     * @return The number of surpassed rounds.\r\n     */\r\n    function getRounds() public view returns (uint256) {\r\n        return rounds.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the winner at the given round and winner\r\n     *         index.\r\n     *\r\n     * @param _round    The round to retrieve the winner from.\r\n     * @param _winner   The winner index within the given round.\r\n     *\r\n     * @return The data of the winner at the given indices.\r\n     */\r\n    function getRoundWinner(\r\n        uint256 _round,\r\n        uint256 _winner\r\n    ) public view returns (RoundWinner memory) {\r\n        return rounds[_round].winners[_winner];\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the total number of enterants in the\r\n     *         competition.\r\n     *\r\n     * @return The total number of enterants.\r\n     */\r\n    function getEnterantCount() public view returns (uint256) {\r\n        return node.totalSupply();\r\n    }\r\n\r\n    /**\r\n     * @notice Starts a new lottery round.\r\n     *\r\n     * @param start The start timestamp for the new round.\r\n     * @param end   The end timestamp for the new round.\r\n     */\r\n    function startNew(uint256 start, uint256 end) external onlyOwner {\r\n        _assertLotteryInactive();\r\n        _assertLogicalTimes(start, end);\r\n        _assertFutureEndTime(end);\r\n\r\n        timeStart = start;\r\n        timeEnd = end;\r\n\r\n        isActive = true;\r\n\r\n        LotteryRound storage round = rounds.push();\r\n        round.numWinners = winnerTiers[winnerTiers.length - 1].winnerCount;\r\n\r\n        emit LotteryStarted(timeStart, timeEnd);\r\n    }\r\n\r\n    /**\r\n     * @notice Draws a random valid ticket as a winner.\r\n     *\r\n     * @param seed  Input seed to generate a random value from,\r\n     *              should be random in itself.\r\n     */\r\n    function drawWinner(uint256 seed) external onlyOwner {\r\n        _assertLotteryActive();\r\n        _assertWinningsExist();\r\n        _assertLotteryFinished();\r\n\r\n        uint256 totalTickets = getEnterantCount();\r\n\r\n        if (\r\n            totalTickets == 0 ||\r\n            drawnWinnersCount == winnerTiers[winnerTiers.length - 1].winnerCount\r\n        ) {\r\n            _complete();\r\n            return;\r\n        }\r\n\r\n        uint256 winnings = winnerTiers[0].amount;\r\n        uint256 tier = 0;\r\n\r\n        for (uint i = 1; i < winnerTiers.length; i++) {\r\n            if (drawnWinnersCount >= winnerTiers[i - 1].winnerCount) {\r\n                winnings = winnerTiers[i].amount;\r\n                tier = i;\r\n            }\r\n        }\r\n\r\n        uint256 winnerIndex = uint(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    block.timestamp,\r\n                    block.difficulty,\r\n                    totalTickets,\r\n                    msg.sender,\r\n                    seed\r\n                )\r\n            )\r\n        ) % totalTickets;\r\n\r\n        address winner = node.ownerOf(winnerIndex);\r\n\r\n        rounds[rounds.length - 1].winners[drawnWinnersCount] = RoundWinner({\r\n            holder: winner,\r\n            winnings: winnings\r\n        });\r\n\r\n        vault.payWinner(winnings, winner);\r\n\r\n        drawnWinnersCount++;\r\n\r\n        emit WinnerDrawn(\r\n            rounds.length,\r\n            block.timestamp,\r\n            winner,\r\n            winnings,\r\n            tier\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the vault contract to distribute winnings\r\n     *         from.\r\n     *\r\n     * @param _vault    The new vault contract.\r\n     */\r\n    function setVaultContract(PLAYA3ULLLotteryVault _vault) external onlyOwner {\r\n        vault = _vault;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the winning tiers that dictate the\r\n     *         amount of funds a winner receives.\r\n     *\r\n     * @param _winners  Array of cumulative winner counts for\r\n     *                  each tier.\r\n     * @param _winnings Array of winnings to distribute at\r\n     *                  each tier.\r\n     */\r\n    function setWinningsTiers(\r\n        uint256[] memory _winners,\r\n        uint256[] memory _winnings\r\n    ) external onlyOwner {\r\n        _assertTierInputsMatch(_winners.length, _winnings.length);\r\n\r\n        while (winnerTiers.length > 0) {\r\n            winnerTiers.pop();\r\n        }\r\n\r\n        for (uint i = 0; i < _winners.length; i++) {\r\n            WinningsTier memory tier = WinningsTier({\r\n                winnerCount: _winners[i],\r\n                amount: _winnings[i]\r\n            });\r\n            winnerTiers.push(tier);\r\n        }\r\n\r\n        emit TiersUpdated(winnerTiers);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to complete the current round.\r\n     */\r\n    function _complete() internal {\r\n        isActive = false;\r\n        drawnWinnersCount = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery is\r\n     *      not active.\r\n     */\r\n    function _assertLotteryActive() internal view {\r\n        if (!isActive) {\r\n            revert LotteryInactive();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery\r\n     *      is active.\r\n     */\r\n    function _assertLotteryInactive() internal view {\r\n        if (isActive) {\r\n            revert LotteryInProgress(timeEnd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the lottery\r\n     *      is still in progress.\r\n     */\r\n    function _assertLotteryFinished() internal view {\r\n        if (block.timestamp < timeEnd) {\r\n            revert LotteryInProgress(timeEnd);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to revert if the supplied\r\n     *      times are not logical.\r\n     *\r\n     * @param start The timestamp of the lottery start.\r\n     * @param end   The timestamp that the lottery will end.\r\n     */\r\n    function _assertLogicalTimes(uint256 start, uint256 end) internal pure {\r\n        if (start >= end) {\r\n            revert IllogicalTimesProvided();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied\r\n     *      end time is not in the future.\r\n     *\r\n     * @param end   The end timestamp to verify against the\r\n     *              current timestamp.\r\n     */\r\n    function _assertFutureEndTime(uint256 end) internal view {\r\n        if (end <= block.timestamp) {\r\n            revert EndTimeNotInFuture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if there exists\r\n     *      no winning tiers.\r\n     */\r\n    function _assertWinningsExist() internal view {\r\n        if (winnerTiers.length == 0) {\r\n            revert NoWinningsToProvide();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal pure function to revert if the supplied\r\n     *      input lengths do not match.\r\n     *\r\n     * @param inputOneLength    The length of the first input.\r\n     * @param inputTwoLength    The length of the second input.\r\n     */\r\n    function _assertTierInputsMatch(\r\n        uint256 inputOneLength,\r\n        uint256 inputTwoLength\r\n    ) internal pure {\r\n        if (inputOneLength != inputTwoLength) {\r\n            revert TierInputLengthsDoNotMatch();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/marketplace/interfaces/IMarketplace.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLMarketplace\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice IPLAYA3ULLMarketplace contains all external structs \r\n *         for the marketplace.\r\n */\r\ninterface IPLAYA3ULLMarketplace {\r\n    /**\r\n     * @dev An item listed on the marketplace contains five \r\n     *      components: an owner address, a bound ERC721 token \r\n     *      ID, the time that the item was listed, the time\r\n     *      that the listing expires, and the consideration\r\n     *      price.\r\n     */\r\n    struct MarketplaceItemListing {\r\n        address owner;\r\n        uint256 tokenId;\r\n        uint256 timeListed;\r\n        uint256 timeExpires;\r\n        uint256 price;\r\n    }\r\n\r\n    /**\r\n     * @dev An offer on a marketplace item is similar to\r\n     *      that of an item listing, however both are mostly\r\n     *      decoupled, excluding when an offer is accepted.\r\n     *      An offer contains the same five components: an\r\n     *      offerer address, a bound ERC721 token ID, the time\r\n     *      that the offer was created, the time that the offer\r\n     *      expires, and the consideration price for the offer.\r\n     */\r\n    struct MarketplaceItemOffer {\r\n        address offerer;\r\n        uint256 tokenId;\r\n        uint256 timeOffered;\r\n        uint256 timeExpires;\r\n        uint256 amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Royalty pricing is generally a percentage of the sale\r\n     *      price. The marketplace is no different here, and must\r\n     *      be constructed from a numerator and denonimator.\r\n     *      As a note, the denominator is generally set to 10000\r\n     *      so as to express fees in basis points, but may be\r\n     *      customized nonetheless.\r\n     */\r\n    struct RoyaltyPercentage {\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n    }\r\n}"
    },
    "contracts/marketplace/interfaces/IMarketplaceEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\n/**\r\n * @title IPLAYA3ULLMarketplaceEventsAndErrors\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice IPLAYA3ULLMarketplaceEventsAndErrors contains all external\r\n *         events, and errors for the marketplace.\r\n */\r\ninterface IPLAYA3ULLMarketplaceEventsAndErrors {\r\n    /**\r\n     * @dev Emit an event whenever a listing is successfully created.\r\n     *\r\n     * @param token     The ERC721 compatible token contract.\r\n     * @param tokenId   The ID of the token to list.\r\n     * @param price     The price of the listing, to which purchasers\r\n     *                  may decide to buy now.\r\n     * @param expires   The timestamp at which this listing expires.\r\n     * @param owner     The address of the listing creator.\r\n     */\r\n    event ListingCreated(\r\n        IERC721 indexed token,\r\n        uint256 indexed tokenId,\r\n        uint256 price,\r\n        uint256 expires,\r\n        address indexed owner\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a listing is created and the\r\n     *      previous listing had expired.\r\n     *\r\n     * @param token     The ERC721 compatible token contract.\r\n     * @param tokenId   The ID of the token whose listing expired.\r\n     */\r\n    event ListingExpired(IERC721 indexed token, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a listing is fulfilled.\r\n     *\r\n     * @param token         The ERC721 compatible token contract.\r\n     * @param tokenId       The ID of the token that is being purchased.\r\n     * @param consideration The sale price of the listing,\r\n     * @param marketFee     The fee the marketplace receives.\r\n     * @param creatorFee    The fee the creator of the NFT receives. Only\r\n     *                      available on ERC2981 NFT Royalty Standard\r\n     *                      implementations.\r\n     * @param seller        The address of the listing creator.\r\n     * @param purchaser     The address of the purchaser.\r\n     */\r\n    event ListingFulfilled(\r\n        IERC721 indexed token,\r\n        uint256 indexed tokenId,\r\n        uint256 consideration,\r\n        uint256 marketFee,\r\n        uint256 creatorFee,\r\n        address seller,\r\n        address indexed purchaser\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a listing is revoked.\r\n     *\r\n     * @param token     The ERC721 compatible token contract.\r\n     * @param tokenId   The ID of the token whose listing expired.\r\n     */\r\n    event ListingRevoked(IERC721 indexed token, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emit an event whenever an offer is created.\r\n     *\r\n     * @param token         The ERC721 compatible token contract.\r\n     * @param tokenId       The ID of the token whose listing expired.\r\n     * @param offerIndex    The index that the offer resides within the\r\n     *                      `tokenOffers` array.\r\n     * @param price         The consideration price of the created offer.\r\n     * @param expires       The timestamp at which this offer expires.\r\n     * @param creator       The address of the offer creator.\r\n     */\r\n    event OfferCreated(\r\n        IERC721 indexed token,\r\n        uint256 indexed tokenId,\r\n        uint256 offerIndex,\r\n        uint256 price,\r\n        uint256 expires,\r\n        address indexed creator\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever an offer is accepted.\r\n     *\r\n     * @param token         The ERC721 compatible token contract.\r\n     * @param tokenId       The ID of the token whose listing expired.\r\n     * @param offerIndex    The index that the accepted offer resides at\r\n     *                      within the `tokenOffers` array.\r\n     * @param consideration The consideration price of the accepted offer.\r\n     * @param marketFee     The fee the marketplace receives.\r\n     * @param creatorFee    The fee the creator of the NFT receives. Only\r\n     *                      available on ERC2981 NFT Royalty Standard\r\n     *                      implementations.\r\n     * @param seller        The address of the owner of the purchased\r\n     *                      item.\r\n     * @param purchaser     The address of the offer creator, and the new\r\n     *                      owner of the purchased item.\r\n     */\r\n    event OfferAccepted(\r\n        IERC721 indexed token,\r\n        uint256 indexed tokenId,\r\n        uint256 offerIndex,\r\n        uint256 consideration,\r\n        uint256 marketFee,\r\n        uint256 creatorFee,\r\n        address seller,\r\n        address indexed purchaser\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever an offer is revoked.\r\n     *\r\n     * @param token         The ERC721 compatible token contract.\r\n     * @param tokenId       The ID of the token whose listing expired.\r\n     * @param offerIndex    The index that the revoked offer previously\r\n     *                      resided at within the `tokenOffers` array.\r\n     */\r\n    event OfferRevoked(\r\n        IERC721 indexed token,\r\n        uint256 indexed tokenId,\r\n        uint256 indexed offerIndex\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever token restrictions are updated.\r\n     *\r\n     * @param restricted    Whether token restrictions are enabled.\r\n     */\r\n    event TokenRestrictionsUpdated(bool restricted);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a tokens support is toggled.\r\n     *\r\n     * @param token     The ERC721 compatible token contract.\r\n     * @param supported Whether the token is now supported or not.\r\n     */\r\n    event SupportedTokenUpdated(IERC721 token, bool supported);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the minimum consideration is updated.\r\n     *\r\n     * @param previous      The previous minimum consideration.\r\n     * @param consideration The new minimum consideration that offers and\r\n     *                      listings must adhere to.\r\n     */\r\n    event MinimumConsiderationUpdated(uint256 previous, uint256 consideration);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the royalty percentage is updated.\r\n     *\r\n     * @param num   The percentage numerator.\r\n     * @param den   The percentage denominator.\r\n     */\r\n    event RoyaltyPercentageUpdated(uint256 num, uint256 den);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the royalty receiver address is updated.\r\n     *\r\n     * @param receiver  The address where marketplace royalties will be\r\n     *                  sent to.\r\n     */\r\n    event RoyaltyReceiverUpdated(address indexed receiver);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to list an item that\r\n     *      already exists.\r\n     */\r\n    error TokenAlreadyListed();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to access a listing\r\n     *      that does not exist.\r\n     */\r\n    error TokenNotFound();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to list or bid on an item\r\n     *      that is not a member of a supported token.\r\n     */\r\n    error UnsupportedToken();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to provide an expiry time\r\n     *      that is not in the future.\r\n     */\r\n    error ExpiryTimeNotInFuture();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to provide a consideration\r\n     *      that is less than the minimum consideration value.\r\n     */\r\n    error ConsiderationNotInRange(uint256 minimumConsideration);\r\n\r\n    /**\r\n     * @dev Revert with an error if the caller of the function is not the\r\n     *      owner of the listing or offer.\r\n     */\r\n    error CallerIsNotOwner();\r\n\r\n    /**\r\n     * @dev Revert with an error if the purchaser of an item is the owner\r\n     *      of the item to be purchased.\r\n     */\r\n    error PurchaserIsOwner();\r\n\r\n    /**\r\n     * @dev Revert with an error if the consideration that is being purchased\r\n     *      has expired.\r\n     */\r\n    error ConsiderationExpired(uint256 timeExpired);\r\n\r\n    /**\r\n     * @dev Revert with an error if the supplied value does not fulfill the\r\n     *      original listed price.\r\n     */\r\n    error IncorrectValueProvided(uint256 listingPrice);\r\n\r\n    /**\r\n     * @dev Revert with an error if the token does not have approval to be\r\n     *      transferred.\r\n     */\r\n    error UnauthorizedTransfer();\r\n\r\n    /**\r\n     * @dev Revert with an error if the supplied index is out of bounds.\r\n     */\r\n    error IndexOutOfBounds();\r\n\r\n    /**\r\n     * @dev Revert with an error if the caller is not the listing owner.\r\n     */\r\n    error CallerIsNotListingOwner();\r\n}\r\n"
    },
    "contracts/marketplace/MarketplaceCore.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\r\n\r\nimport {IPLAYA3ULLMarketplace} from \"./interfaces/IMarketplace.sol\";\r\nimport {IPLAYA3ULLMarketplaceEventsAndErrors} from \"./interfaces/IMarketplaceEventsAndErrors.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games Marketplace Core Contract\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice This contract serves as the core and central brain for\r\n *         the PLAYA3ULL Games Marketplace ecosystem.\r\n */\r\ncontract PLAYA3ULLMarketplaceCore is\r\n    Ownable,\r\n    IERC721Receiver,\r\n    IPLAYA3ULLMarketplace,\r\n    IPLAYA3ULLMarketplaceEventsAndErrors\r\n{\r\n    /// @dev Represents the interface ID for ERC2981 NFT Royalty Standard contracts\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n    /// @notice Whether to allow any token into the marketplace, or restrict to the support tokens mapping\r\n    bool public restrictTokens;\r\n\r\n    /// @notice Represents the minimum offer and listing price\r\n    uint256 public minimumConsideration;\r\n\r\n    /// @notice The address where the royalties from sales will be sent\r\n    address public royaltyReceiver;\r\n\r\n    /// @notice The percentage of royalties from sales the marketplace takes\r\n    RoyaltyPercentage public royaltyFee;\r\n\r\n    /// @notice Tracks the supported tokens that the contract allows interactions with\r\n    mapping(IERC721 => bool) public supportedTokens;\r\n\r\n    /// @notice Tracks the listings for individual token IDs for a given ERC721 contract\r\n    mapping(IERC721 => mapping(uint256 => MarketplaceItemListing))\r\n        public tokenListings;\r\n\r\n    /// @notice Tracks the offers for individual token IDs for a given ERC721 contract\r\n    mapping(IERC721 => mapping(uint256 => MarketplaceItemOffer[]))\r\n        public tokenOffers;\r\n\r\n    constructor() {\r\n        minimumConsideration = 5000e18;\r\n\r\n        restrictTokens = true;\r\n\r\n        royaltyFee = RoyaltyPercentage({numerator: 750, denominator: 10000});\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new listing for the given token. You cannot create a\r\n     *         token listing if there is already a listing for the token you\r\n     *         are trying to list. This does not apply if the existing listing\r\n     *         has expired, however.\r\n     *\r\n     * @param token     The token contract that the item offered belongs to.\r\n     * @param tokenId   The ID of the token that the listing will be bound to.\r\n     * @param price     The consideration price for the listing.\r\n     * @param expires   The timestamp that the listing will expire.\r\n     */\r\n    function createListing(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 price,\r\n        uint256 expires\r\n    ) external {\r\n        _assertTokenIsSupported(token);\r\n        _assertExpiryInFuture(expires);\r\n        _assertConsiderationInRange(price);\r\n\r\n        bool listingExists = _listingExists(token, tokenId);\r\n        if (listingExists) {\r\n            _assertCallerIsListingOwner(token, tokenId);\r\n        }\r\n\r\n        bool canList = !listingExists;\r\n        bool hasExpired = tokenListings[token][tokenId].timeExpires != 0 &&\r\n            block.timestamp >= tokenListings[token][tokenId].timeExpires;\r\n        if (!canList && !hasExpired) {\r\n            revert TokenAlreadyListed();\r\n        }\r\n\r\n        if (canList || !hasExpired) {\r\n            token.safeTransferFrom(msg.sender, address(this), tokenId);\r\n        }\r\n\r\n        if (hasExpired) {\r\n            emit ListingExpired(token, tokenId);\r\n        }\r\n\r\n        emit ListingCreated(token, tokenId, price, expires, msg.sender);\r\n\r\n        tokenListings[token][tokenId] = MarketplaceItemListing({\r\n            owner: msg.sender,\r\n            tokenId: tokenId,\r\n            timeListed: block.timestamp,\r\n            timeExpires: expires,\r\n            price: price\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @notice Fulfill a listing and receive the token, provided the\r\n     *         supplied value is equal to the listing price.\r\n     *         Performing this action permanently deletes the listing\r\n     *         data from state.\r\n     *\r\n     * @param token         The token contract that the item offered belongs to.\r\n     * @param tokenId       The ID of the token that the listing is bound to.\r\n     */\r\n    function fulfillListing(IERC721 token, uint256 tokenId) external payable {\r\n        _assertTokenIsSupported(token);\r\n\r\n        bool canPurchase = _listingExists(token, tokenId);\r\n        if (!canPurchase) {\r\n            revert TokenNotFound();\r\n        }\r\n\r\n        uint256 expiry = tokenListings[token][tokenId].timeExpires;\r\n        if (expiry <= block.timestamp) {\r\n            revert ConsiderationExpired(expiry);\r\n        }\r\n\r\n        _assertCallerIsNotListingOwner(token, tokenId);\r\n\r\n        // Verify that the correct value was sent\r\n        uint256 consideration = tokenListings[token][tokenId].price;\r\n        if (msg.value != consideration) {\r\n            revert IncorrectValueProvided(consideration);\r\n        }\r\n\r\n        (uint256 marketFee, uint256 creatorFee) = _handleRoyalties(\r\n            token,\r\n            tokenId,\r\n            consideration\r\n        );\r\n\r\n        address listingOwner = tokenListings[token][tokenId].owner;\r\n\r\n        emit ListingFulfilled(\r\n            token,\r\n            tokenId,\r\n            consideration,\r\n            marketFee,\r\n            creatorFee,\r\n            listingOwner,\r\n            msg.sender\r\n        );\r\n\r\n        delete tokenListings[token][tokenId];\r\n\r\n        // Transfer item to the purchaser\r\n        token.safeTransferFrom(address(this), msg.sender, tokenId);\r\n\r\n        // Transfer funds to the seller\r\n        payable(listingOwner).transfer(\r\n            consideration - (marketFee + creatorFee)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke a listing created by the sender for the given token,\r\n     *         and return the token to the listing owner.\r\n     *         Performing this action permanently deletes the listing\r\n     *         data from state.\r\n     *\r\n     * @param token         The token contract that the item offered belongs to.\r\n     * @param tokenId       The ID of the token that the listing is bound to.\r\n     */\r\n    function revokeListing(IERC721 token, uint256 tokenId) external {\r\n        bool canDelist = _listingExists(token, tokenId);\r\n        if (!canDelist) {\r\n            revert TokenNotFound();\r\n        }\r\n\r\n        _assertCallerIsListingOwner(token, tokenId);\r\n\r\n        emit ListingRevoked(token, tokenId);\r\n\r\n        delete tokenListings[token][tokenId];\r\n\r\n        token.safeTransferFrom(address(this), msg.sender, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new offer on a given token.\r\n     *\r\n     * @param token     The token contract that the item offered on belongs to.\r\n     * @param tokenId   The ID of the token that the offer will be bound to.\r\n     * @param expires   The timestamp that the offer will expire.\r\n     */\r\n    function createOffer(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 expires\r\n    ) external payable {\r\n        _assertTokenIsSupported(token);\r\n        _assertExpiryInFuture(expires);\r\n        _assertConsiderationInRange(msg.value);\r\n\r\n        uint256 offerIndex = tokenOffers[token][tokenId].length;\r\n\r\n        emit OfferCreated(\r\n            token,\r\n            tokenId,\r\n            offerIndex,\r\n            msg.value,\r\n            expires,\r\n            msg.sender\r\n        );\r\n\r\n        tokenOffers[token][tokenId].push(\r\n            MarketplaceItemOffer({\r\n                offerer: msg.sender,\r\n                tokenId: tokenId,\r\n                amount: msg.value,\r\n                timeOffered: block.timestamp,\r\n                timeExpires: expires\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Accept an existing, non-expired offer on a given token.\r\n     *         Performing this action permanently deletes the offer\r\n     *         data from state.\r\n     *         Importantly, performing this action will delete any\r\n     *         existing listings for the purchased item.\r\n     *\r\n     * @param token         The token contract that the item offered on belongs to.\r\n     * @param tokenId       The ID of the token that the offer is bound to.\r\n     * @param offerIndex    The index in the `tokenOffers` array to revoke.\r\n     */\r\n    function acceptOffer(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 offerIndex\r\n    ) external {\r\n        _assertCallerIsNFTOwner(token, tokenId);\r\n        _assertTokenIsSupported(token);\r\n        _assertAuthorizedTransfer(token, tokenId);\r\n        _assertIndexInBounds(offerIndex, tokenOffers[token][tokenId].length);\r\n        _assertPurchaserIsNotOwner(token, tokenId, offerIndex);\r\n\r\n        uint256 expiry = tokenOffers[token][tokenId][offerIndex].timeExpires;\r\n        if (expiry <= block.timestamp) {\r\n            revert ConsiderationExpired(expiry);\r\n        }\r\n\r\n        uint256 consideration = tokenOffers[token][tokenId][offerIndex].amount;\r\n        (uint256 marketFee, uint256 creatorFee) = _handleRoyalties(\r\n            token,\r\n            tokenId,\r\n            consideration\r\n        );\r\n\r\n        address offerer = tokenOffers[token][tokenId][offerIndex].offerer;\r\n\r\n        emit OfferAccepted(\r\n            token,\r\n            tokenId,\r\n            offerIndex,\r\n            consideration,\r\n            marketFee,\r\n            creatorFee,\r\n            msg.sender,\r\n            offerer\r\n        );\r\n\r\n        _deleteOffer(token, tokenId, offerIndex);\r\n\r\n        // Delete a listing tied to the token, if any exist\r\n        if (_listingExists(token, tokenId)) {\r\n            delete tokenListings[token][tokenId];\r\n        }\r\n\r\n        // Transfer the item to the marketplace, unless the marketplace\r\n        // already owns the item\r\n        if (token.ownerOf(tokenId) != address(this)) {\r\n            token.safeTransferFrom(msg.sender, address(this), tokenId);\r\n        }\r\n\r\n        // Transfer the item to the purchaser\r\n        token.safeTransferFrom(address(this), offerer, tokenId);\r\n\r\n        // Pay the consideration amount to the seller\r\n        payable(msg.sender).transfer(consideration - (marketFee + creatorFee));\r\n    }\r\n\r\n    /**\r\n     * @notice Revoke a created offer on a given token. This function\r\n     *         refunds the original offer amount back to the offerer.\r\n     *         Performing this action permanently deletes the offer\r\n     *         data from state.\r\n     *\r\n     * @param token         The token contract that the item offered on belongs to.\r\n     * @param tokenId       The ID of the token that the offer is bound to.\r\n     * @param offerIndex    The index in the `tokenOffers` array to revoke.\r\n     */\r\n    function revokeOffer(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 offerIndex\r\n    ) external {\r\n        _assertIndexInBounds(offerIndex, tokenOffers[token][tokenId].length);\r\n        _assertCallerIsOfferOwner(token, tokenId, offerIndex);\r\n\r\n        emit OfferRevoked(token, tokenId, offerIndex);\r\n\r\n        // Refund the caller, the original amount they offered and paid in escrow\r\n        uint256 refund = tokenOffers[token][tokenId][offerIndex].amount;\r\n        _deleteOffer(token, tokenId, offerIndex);\r\n\r\n        payable(msg.sender).transfer(refund);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to delete an offer element.\r\n     *\r\n     * @param token     The token contract that the item belongs to.\r\n     * @param tokenId   The ID of the token that contains the relevant offer.\r\n     * @param index     The index in the `tokenOffers` array to delete.\r\n     */\r\n    function _deleteOffer(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 index\r\n    ) internal {\r\n        // Delete offer from the token offers array\r\n        uint256 lastOfferIndex = tokenOffers[token][tokenId].length - 1;\r\n\r\n        tokenOffers[token][tokenId][index] = tokenOffers[token][tokenId][\r\n            lastOfferIndex\r\n        ];\r\n        tokenOffers[token][tokenId].pop();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to retrieve and return whether the provided\r\n     *      token ID has a listing created for it for the given ERC721 compliant\r\n     *      contract.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being verified.\r\n     */\r\n    function _listingExists(\r\n        IERC721 token,\r\n        uint256 tokenId\r\n    ) internal view returns (bool) {\r\n        return tokenListings[token][tokenId].owner != address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied token is not\r\n     *      supported.\r\n     *\r\n     * @param token The token for which to assert support on.\r\n     */\r\n    function _assertTokenIsSupported(IERC721 token) internal view {\r\n        if (restrictTokens && !supportedTokens[token]) {\r\n            revert UnsupportedToken();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied expiry time\r\n     *      is not in the future.\r\n     *\r\n     * @param expiry The expiry timestamp to assert on.\r\n     */\r\n    function _assertExpiryInFuture(uint256 expiry) internal view {\r\n        if (block.timestamp >= expiry) {\r\n            revert ExpiryTimeNotInFuture();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the supplied value\r\n     *      is less than the minimum consideration\r\n     *\r\n     * @param consideration The consideration to assert on.\r\n     */\r\n    function _assertConsiderationInRange(uint256 consideration) internal view {\r\n        if (consideration < minimumConsideration) {\r\n            revert ConsiderationNotInRange(minimumConsideration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the caller of the function\r\n     *      is not the owner of the listing.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being referenced.\r\n     */\r\n    function _assertCallerIsListingOwner(\r\n        IERC721 token,\r\n        uint256 tokenId\r\n    ) internal view {\r\n        if (tokenListings[token][tokenId].owner != msg.sender) {\r\n            revert CallerIsNotOwner();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the caller of the function\r\n     *      is the owner of the listing.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being referenced.\r\n     */\r\n    function _assertCallerIsNotListingOwner(\r\n        IERC721 token,\r\n        uint256 tokenId\r\n    ) internal view {\r\n        if (tokenListings[token][tokenId].owner == msg.sender) {\r\n            revert PurchaserIsOwner();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the caller of the function\r\n     *      is not the owner of the offer.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being referenced.\r\n     * @param index     The index in the `tokenOffers` array.\r\n     */\r\n    function _assertCallerIsOfferOwner(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 index\r\n    ) internal view {\r\n        if (tokenOffers[token][tokenId][index].offerer != msg.sender) {\r\n            revert CallerIsNotOwner();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the purchaser of an item\r\n     *      is not the owner of the offer.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being referenced.\r\n     * @param index     The index in the `tokenOffers` array.\r\n     */\r\n    function _assertPurchaserIsNotOwner(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 index\r\n    ) internal view {\r\n        if (tokenOffers[token][tokenId][index].offerer == msg.sender) {\r\n            revert PurchaserIsOwner();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the caller of the function\r\n     *      is not the owner of the NFT.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being referenced.\r\n     */\r\n    function _assertCallerIsNFTOwner(\r\n        IERC721 token,\r\n        uint256 tokenId\r\n    ) internal view {\r\n        address ownerOf = token.ownerOf(tokenId);\r\n        // Check if the token owner is the contract itself or the caller\r\n        // and if the listing owner is not the caller\r\n        if (\r\n            ownerOf == msg.sender ||\r\n            tokenListings[token][tokenId].owner == msg.sender\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        revert CallerIsNotOwner();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the item that is being\r\n     *      purchased does not have authorization to be transferred.\r\n     *\r\n     * @param token     The token that the ID is being verified against.\r\n     * @param tokenId   The ID of the token that is being referenced.\r\n     */\r\n    function _assertAuthorizedTransfer(\r\n        IERC721 token,\r\n        uint256 tokenId\r\n    ) internal view {\r\n        if (\r\n            token.ownerOf(tokenId) != address(this) &&\r\n            token.getApproved(tokenId) != address(this)\r\n        ) {\r\n            revert UnauthorizedTransfer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if accessed token ID\r\n     *      is out of bounds of the given array length.\r\n     *\r\n     * @param tokenId   The ID of the token is being accessed.\r\n     * @param length    The length of the array to verify.\r\n     */\r\n    function _assertIndexInBounds(\r\n        uint256 tokenId,\r\n        uint256 length\r\n    ) internal pure {\r\n        if (tokenId >= length) {\r\n            revert IndexOutOfBounds();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to handle and distribute royalties\r\n     *      to the marketplace, and the creator of the NFT\r\n     *      contract if said contract implements the ERC2981\r\n     *      NFT Royalty Standard.\r\n     *\r\n     * @param token         The ERC721 token contract.\r\n     * @param tokenId       The ID of the token is being accessed.\r\n     * @param consideration The sale price of the token.\r\n     */\r\n    function _handleRoyalties(\r\n        IERC721 token,\r\n        uint256 tokenId,\r\n        uint256 consideration\r\n    ) internal returns (uint256, uint256) {\r\n        uint256 marketFee;\r\n        uint256 creatorFee;\r\n\r\n        // Transfer royalties to marketplace royalty receiver\r\n        if (royaltyReceiver != address(0)) {\r\n            marketFee =\r\n                (consideration * royaltyFee.numerator) /\r\n                royaltyFee.denominator;\r\n            payable(royaltyReceiver).transfer(marketFee);\r\n        }\r\n\r\n        // Transfer royalties to NFT creator, if the creator has implemented\r\n        // the ERC2981 NFT Royalty Standard\r\n        if (checkRoyalties(address(token))) {\r\n            (address creator, uint256 fee) = IERC2981(address(token))\r\n                .royaltyInfo(tokenId, consideration);\r\n            creatorFee = fee;\r\n            payable(creator).transfer(creatorFee);\r\n        }\r\n\r\n        return (marketFee, creatorFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks whether the NFT has implemented the ERC2981 NFT\r\n     *      royalty standard.\r\n     *\r\n     * @param _contract The address of the NFT contract.\r\n     *\r\n     * @return Boolean value whether the contract supports the ERC2981 standard.\r\n     */\r\n    function checkRoyalties(address _contract) internal view returns (bool) {\r\n        bool success = IERC165(_contract).supportsInterface(\r\n            _INTERFACE_ID_ERC2981\r\n        );\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles support for the supplied ERC721 token, enabling access\r\n     *         to the token within the marketplace ecosystem.\r\n     *\r\n     * @param token The ERC721 token to toggle support.\r\n     */\r\n    function toggleSupportedToken(IERC721 token) external onlyOwner {\r\n        supportedTokens[token] = !supportedTokens[token];\r\n\r\n        emit SupportedTokenUpdated(token, supportedTokens[token]);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the minimum consideration price for offers and listings.\r\n     *\r\n     * @param consideration The new minimum consideration.\r\n     */\r\n    function setMinimumConsideration(uint256 consideration) external onlyOwner {\r\n        emit MinimumConsiderationUpdated(minimumConsideration, consideration);\r\n\r\n        minimumConsideration = consideration;\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether tokens are restricted, or any token may\r\n     *         interact with the marketplace ecosystem.\r\n     */\r\n    function toggleTokenRestrictions() external onlyOwner {\r\n        restrictTokens = !restrictTokens;\r\n\r\n        emit TokenRestrictionsUpdated(restrictTokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the royalty fee for that the marketplace takes on offer\r\n     *         and listing sales.\r\n     *\r\n     * @param fee The percentage data of the royalty fee.\r\n     */\r\n    function setRoyaltyFee(RoyaltyPercentage memory fee) external onlyOwner {\r\n        emit RoyaltyPercentageUpdated(fee.numerator, fee.denominator);\r\n\r\n        royaltyFee = fee;\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the royalty receiver, where royalty fees will be sent to.\r\n     *\r\n     * @param receiver  The address that will receive marketplace royalties.\r\n     */\r\n    function setRoyaltyReceiver(address receiver) external onlyOwner {\r\n        emit RoyaltyReceiverUpdated(receiver);\r\n\r\n        royaltyReceiver = receiver;\r\n    }\r\n\r\n    /**\r\n     * @notice The ERC721 smart contract calls this function on the recipient\r\n     *         after a IERC721.safeTransferFrom.\r\n     *\r\n     * @param operator  The operator address of the token.\r\n     * @param from      The sender of the ERC721 token.\r\n     * @param tokenId   The ID of the token that was received.\r\n     *\r\n     * @return This function MUST return the function selector, otherwise the\r\n     *         caller will revert the transaction.\r\n     */\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external pure override returns (bytes4) {\r\n        return IERC721Receiver.onERC721Received.selector;\r\n    }\r\n}\r\n"
    },
    "contracts/misc/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Math\r\n * @author Jourdan (@jourdanhaines)\r\n * @notice Library for mathematical calculations\r\n */\r\nlibrary Math {\r\n    /**\r\n     * @notice Clamp a number between a minimum and maximum\r\n     *\r\n     * @param amount        The number to clamp\r\n     * @param minimum       The minimum value\r\n     * @param naximum       The maximum value\r\n     *\r\n     * @return The clamped number\r\n     */\r\n    function clamp(\r\n        uint amount,\r\n        uint minimum,\r\n        uint naximum\r\n    ) internal pure returns (uint) {\r\n        if (amount < minimum) {\r\n            return minimum;\r\n        } else if (amount > naximum) {\r\n            return naximum;\r\n        } else {\r\n            return amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the maximum of two numbers\r\n     *\r\n     * @param a     The first number\r\n     * @param b     The second number\r\n     *\r\n     * @return The maximum of the two numbers\r\n     */\r\n    function max(uint a, uint b) internal pure returns (uint) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the minimum of two numbers\r\n     *\r\n     * @param a     The first number\r\n     * @param b     The second number\r\n     *\r\n     * @return The minimum of the two numbers\r\n     */\r\n    function min(uint a, uint b) internal pure returns (uint) {\r\n        return a > b ? b : a;\r\n    }\r\n}\r\n"
    },
    "contracts/misc/Randomiser.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n/**\r\n * @title Randomiser\r\n * @author Jourdan (@jourdanhaines)\r\n * @notice Randomiser allows external contracts to generate\r\n *         random numbers.\r\n */\r\ncontract Randomiser is Ownable {\r\n    // Public seed used as an entropy source for randomness\r\n    uint256 public seed;\r\n\r\n    // Nonce to ensure different results for sequential calls\r\n    uint256 public nonce;\r\n\r\n    // Event emitted when a random number is generated\r\n    event RandomNumberGenerated(uint256 indexed randomNumber);\r\n    // Event emitted when the seed is updated\r\n    event SeedUpdated(uint256 indexed seed);\r\n\r\n    /**\r\n     * @dev Sets initial seed and nonce on contract deployment.\r\n     */\r\n    constructor() {\r\n        seed = block.timestamp;\r\n        nonce = 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Generates a pseudorandom number.\r\n     *\r\n     * @notice The generated number's randomness relies on block attributes which can be influenced by miners.\r\n     *\r\n     * @return randomNumber A pseudorandom number.\r\n     */\r\n    function getRandom() public returns (uint256) {\r\n        if (nonce == type(uint256).max) {\r\n            nonce = 0;\r\n        }\r\n\r\n        nonce++;\r\n\r\n        uint256 randomNumber = uint256(\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    block.timestamp,\r\n                    msg.sender,\r\n                    nonce,\r\n                    seed,\r\n                    block.difficulty,\r\n                    block.gaslimit\r\n                )\r\n            )\r\n        );\r\n\r\n        emit RandomNumberGenerated(randomNumber);\r\n\r\n        return randomNumber;\r\n    }\r\n\r\n    /**\r\n     * @dev Generates a pseudorandom number within a specified range.\r\n     *\r\n     * @param min The lower inclusive bound of the range.\r\n     * @param max The upper exclusive bound of the range.\r\n     *\r\n     * @return A pseudorandom number within the specified range.\r\n     */\r\n    function getRandomInRange(\r\n        uint256 min,\r\n        uint256 max\r\n    ) external returns (uint256) {\r\n        require(max > min, \"Randomiser: Invalid range\");\r\n        return (getRandom() % (max - min)) + min;\r\n    }\r\n\r\n    /**\r\n     * @dev Selects a pseudorandom element from an array.\r\n     *\r\n     * @param array An array of uint256 elements.\r\n     *\r\n     * @return The randomly selected element from the array.\r\n     */\r\n    function getRandomInArray(\r\n        uint256[] memory array\r\n    ) external returns (uint256) {\r\n        return array[getRandom() % array.length];\r\n    }\r\n\r\n    /**\r\n     * @dev Selects a pseudorandom element from a weighted array.\r\n     *\r\n     * @param array An array of uint256 elements.\r\n     * @param weights An array of weights corresponding to the elements of 'array'.\r\n     *\r\n     * @return The randomly selected element from the array taking weights into account.\r\n     */\r\n    function getRandomInArrayWithWeights(\r\n        uint256[] memory array,\r\n        uint256[] memory weights\r\n    ) public returns (uint256) {\r\n        require(array.length == weights.length, \"Randomiser: Invalid array\");\r\n\r\n        uint256 totalWeight;\r\n        for (uint256 i = 0; i < weights.length; i++) {\r\n            totalWeight += weights[i];\r\n        }\r\n\r\n        uint256 randomValue = getRandom() % totalWeight;\r\n        uint256 weightSum;\r\n        for (uint256 i = 0; i < weights.length; i++) {\r\n            weightSum += weights[i];\r\n            if (randomValue < weightSum) {\r\n                return array[i];\r\n            }\r\n        }\r\n\r\n        revert(\"Randomiser: Invalid weights\");\r\n    }\r\n\r\n    /**\r\n     * @dev Generates multiple pseudorandom numbers.\r\n     *\r\n     * @param amount The number of random values to generate.\r\n     * @param distinct Whether the random numbers should all be distinct.\r\n     *\r\n     * @return An array of pseudorandom numbers.\r\n     */\r\n    function getManyRandom(\r\n        uint256 amount,\r\n        bool distinct\r\n    ) external returns (uint256[] memory) {\r\n        require(\r\n            amount <= type(uint256).max,\r\n            \"Randomiser: Requesting too many distinct values\"\r\n        );\r\n\r\n        uint256[] memory randoms = new uint256[](amount);\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            uint256 randomValue;\r\n            bool isUnique;\r\n\r\n            do {\r\n                isUnique = true;\r\n                randomValue = getRandom();\r\n\r\n                if (distinct) {\r\n                    for (uint256 j = 0; j < i; j++) {\r\n                        if (randoms[j] == randomValue) {\r\n                            isUnique = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } while (!isUnique);\r\n\r\n            randoms[i] = randomValue;\r\n        }\r\n\r\n        return randoms;\r\n    }\r\n\r\n    /**\r\n     * @dev Generates multiple pseudorandom numbers within a range.\r\n     *\r\n     * @param min The lower inclusive bound of the range.\r\n     * @param max The upper exclusive bound of the range.\r\n     * @param amount The number of random values to generate.\r\n     * @param distinct Whether the random numbers should all be distinct.\r\n     *\r\n     * @return An array of pseudorandom numbers within the specified range.\r\n     */\r\n    function getManyRandomInRange(\r\n        uint256 min,\r\n        uint256 max,\r\n        uint256 amount,\r\n        bool distinct\r\n    ) external returns (uint256[] memory) {\r\n        require(max > min, \"Randomiser: Invalid range\");\r\n        require(\r\n            amount <= type(uint256).max,\r\n            \"Randomiser: Requesting too many distinct values\"\r\n        );\r\n\r\n        uint256[] memory randoms = new uint256[](amount);\r\n        for (uint256 i = 0; i < amount; i++) {\r\n            uint256 randomValue;\r\n            bool isUnique;\r\n\r\n            do {\r\n                isUnique = true;\r\n                randomValue = (getRandom() % (max - min)) + min;\r\n\r\n                if (distinct) {\r\n                    for (uint256 j = 0; j < i; j++) {\r\n                        if (randoms[j] == randomValue) {\r\n                            isUnique = false;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            } while (!isUnique);\r\n\r\n            randoms[i] = randomValue;\r\n        }\r\n\r\n        return randoms;\r\n    }\r\n\r\n    /**\r\n     * @dev Generates multiple pseudorandom elements selected from an array.\r\n     *\r\n     * @param array An array of uint256 elements.\r\n     * @param amount The number of elements to select.\r\n     * @param distinct Whether the selected elements should all be distinct.\r\n     *\r\n     * @return An array of pseudorandomly selected elements.\r\n     */\r\n    function getManyRandomInArray(\r\n        uint256[] memory array,\r\n        uint256 amount,\r\n        bool distinct\r\n    ) external returns (uint256[] memory) {\r\n        require(\r\n            amount <= type(uint256).max,\r\n            \"Randomiser: Requesting too many distinct values\"\r\n        );\r\n\r\n        uint256[] memory randoms = new uint256[](amount);\r\n        if (distinct) {\r\n            // For distinct randoms, we shuffle the array and take the first `amount` elements\r\n            for (uint256 i = 0; i < amount; i++) {\r\n                uint256 j = getRandom() % (array.length - i);\r\n                uint256 index = i + j;\r\n                // Swap array[i] and array[index]\r\n                (array[i], array[index]) = (array[index], array[i]);\r\n                randoms[i] = array[i];\r\n            }\r\n        } else {\r\n            for (uint256 i = 0; i < amount; i++) {\r\n                randoms[i] = array[getRandom() % array.length];\r\n            }\r\n        }\r\n\r\n        return randoms;\r\n    }\r\n\r\n    /**\r\n     * @dev Generates multiple pseudorandom elements selected from an array with assigned weights.\r\n     *\r\n     * @param array An array of uint256 elements.\r\n     * @param weights An array of weights corresponding to the elements of 'array'.\r\n     * @param amount The number of elements to select.\r\n     * @param distinct Whether the selected elements should all be distinct.\r\n     *\r\n     * @return An array of pseudorandomly selected elements with consideration to their weights.\r\n     */\r\n    function getManyRandomInArrayWithWeights(\r\n        uint256[] memory array,\r\n        uint256[] memory weights,\r\n        uint256 amount,\r\n        bool distinct\r\n    ) external returns (uint256[] memory) {\r\n        require(\r\n            array.length == weights.length,\r\n            \"Randomiser: Array and weights length mismatch\"\r\n        );\r\n        require(array.length > 0, \"Randomiser: Array is empty\");\r\n        require(amount <= type(uint256).max, \"Randomiser: Invalid amount\");\r\n        require(\r\n            !distinct || amount <= array.length,\r\n            \"Randomiser: Requesting too many distinct values\"\r\n        );\r\n\r\n        uint256[] memory selected = new uint256[](amount);\r\n        uint256 totalWeight = 0;\r\n        uint256 activeLength = weights.length; // Active length to handle the case when distinct is true\r\n\r\n        // Calculate the total weight\r\n        for (uint256 i = 0; i < weights.length; i++) {\r\n            totalWeight += weights[i];\r\n        }\r\n\r\n        for (uint256 i = 0; i < amount; ++i) {\r\n            uint256 rand = getRandom() % totalWeight;\r\n            uint256 sum = 0;\r\n\r\n            for (uint256 j = 0; j < activeLength; ++j) {\r\n                sum += weights[j];\r\n                if (rand < sum) {\r\n                    selected[i] = array[j];\r\n                    if (distinct) {\r\n                        // Remove the weight of the chosen element from the total weight\r\n                        totalWeight -= weights[j];\r\n                        // Move the last element to the current position j to \"remove\" the selected element\r\n                        if (j < activeLength - 1) {\r\n                            array[j] = array[activeLength - 1];\r\n                            weights[j] = weights[activeLength - 1];\r\n                        }\r\n                        // Decrement the active length since one element is now \"removed\"\r\n                        activeLength--;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        return selected;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the seed used as an entropy source for randomness.\r\n     *\r\n     * @param _seed The new seed.\r\n     */\r\n    function setSeed(uint256 _seed) external onlyOwner {\r\n        seed = _seed;\r\n\r\n        emit SeedUpdated(_seed);\r\n    }\r\n}\r\n"
    },
    "contracts/misc/Ratio.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Ratio\r\n * @author Jourdan (@jourdanhaines)\r\n * @notice Library for ratio-based calculations with 2 decimal precision.\r\n */\r\nlibrary Ratio {\r\n    /// @notice Error to be thrown if the ratio value exceeds the maximum allowed value.\r\n    error InvalidRatio(uint256 max);\r\n\r\n    /**\r\n     * @dev Ensures the ratio value is between 0 and 10000 (for 2 decimal precision).\r\n     * Throws an `InvalidRatio` error if the condition is not met.\r\n     * @param _ratio The ratio value to validate. It should be within 0 and 10000 for 2 decimal precision.\r\n     */\r\n    modifier validRatio(uint256 _ratio) {\r\n        if (_ratio > 10000) {\r\n            revert InvalidRatio(10000);\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates a specified ratio of the given amount.\r\n     * @dev This function uses 2 decimal precision for ratio calculations. Hence, a ratio of 5.5% should be passed as 550.\r\n     * @param amount The primary value of which a part/ratio is to be calculated.\r\n     * @param ratioValue The ratio value in basis points (2 decimal precision) to be applied on the primary amount.\r\n     * @return The calculated value based on the provided ratio.\r\n     */\r\n    function getPart(\r\n        uint256 amount,\r\n        uint256 ratioValue\r\n    ) internal pure validRatio(ratioValue) returns (uint256) {\r\n        return (amount * ratioValue) / 10000;\r\n    }\r\n}\r\n"
    },
    "contracts/nft/bull/BULLNFTMinter.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./lib/MathUtils.sol\";\r\nimport \"../../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\nimport {IPLAYA3ULLNFT} from \"./interfaces/I3ULLNFT.sol\";\r\nimport {IPLAYA3ULLNFTMinterEventsAndErrors} from \"./interfaces/I3ULLNFTMinterEventsAndErrors.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games 3ULL NFT Minter Contract\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract contains the core minting functionality for\r\n *         ordinary users minting the 3ULL NFT tokens.\r\n *         Additionally, this contract handles the pricing data and\r\n *         model for said 3ULL NFTs.\r\n */\r\ncontract PLAYA3ULLNFTMinter is Ownable, IPLAYA3ULLNFTMinterEventsAndErrors {\r\n    /// @notice Whether users can mint from this contract.\r\n    bool public mintActive;\r\n\r\n    /// @notice The actual PLAYA3ULL NFT that is to be purchased.\r\n    IPLAYA3ULLNFT public immutable nft;\r\n\r\n    /// @notice The interface for the Price Oracle to retrieve\r\n    ///         pricing data from.\r\n    IPriceOracle public oracle;\r\n\r\n    /// @dev The lowest price a token can be purchased for.\r\n    uint256 private price;\r\n\r\n    /// @dev The scaling factor applied to an attributes rarity when\r\n    ///      determining the price for that attribute.\r\n    uint256 private immutable rarityScaleFactor;\r\n\r\n    constructor(address _nft, address _oracleAddress, uint256 _price) {\r\n        nft = IPLAYA3ULLNFT(_nft);\r\n        oracle = IPriceOracle(_oracleAddress);\r\n\r\n        price = _price;\r\n\r\n        mintActive = false;\r\n        rarityScaleFactor = 1_025_000; // 1.02500\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the base price for a category. For example,\r\n     *         if there are 10 categories, then the value returned\r\n     *         will be the `price` / 10.\r\n     *\r\n     * @return The base price for each category.\r\n     */\r\n    function getBasePrice() public view returns (uint256) {\r\n        uint256 traits = nft.getTraitLength();\r\n\r\n        return price / traits;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes and returns the price for a given attribute\r\n     *         of a given trait.\r\n     *\r\n     * @param _traitId  The ID of the trait that the attribute\r\n     *                  belongs to.\r\n     * @param _attrId   The ID of the attribute to compute the price.\r\n     *\r\n     * @return The computed price of the attribute.\r\n     */\r\n    function getAttributePrice(\r\n        uint256 _traitId,\r\n        uint256 _attrId\r\n    ) public view returns (uint256) {\r\n        IPLAYA3ULLNFT.Trait memory trait = nft.getTrait(_traitId);\r\n\r\n        // The attribute is \"None\", therefore no price\r\n        if (!trait.required && _attrId == 0) {\r\n            return 0;\r\n        }\r\n\r\n        IPLAYA3ULLNFT.Attribute memory attribute = nft.getAttribute(\r\n            _traitId,\r\n            _attrId\r\n        );\r\n\r\n        uint256 maxSupply = nft.getMaxSupply();\r\n        uint256 basePrice = getBasePrice();\r\n        uint256 expectedTotal = ((maxSupply * 1e18) * attribute.rarity) / 1e18;\r\n        uint256 expectedRarityFactor = (expectedTotal * rarityScaleFactor) /\r\n            1e18;\r\n        uint256 minOneSell = uint256(MathUtils.max(attribute.numSold, 1));\r\n        uint256 normalised = MathUtils.canSub(\r\n            1e18,\r\n            ((minOneSell * 1e24) / expectedRarityFactor)\r\n        )\r\n            ? 1e18 - ((minOneSell * 1e24) / expectedRarityFactor)\r\n            : 1e14; // 1e14 = 0.0001\r\n        uint256 logOfNormal = MathUtils.abs(MathUtils.log2(int256(normalised)));\r\n\r\n        return ((basePrice *\r\n            (1e18 + logOfNormal) *\r\n            (1e18 +\r\n                ((((minOneSell * 1e36) / expectedTotal) *\r\n                    (1e18 + (1e18 - normalised))) / 1e18))) / (1e36));\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the current price of 3ULL from the Price\r\n     *         Oracle.\r\n     *\r\n     * @param _price    The USD price to get in 3ULL.\r\n     *\r\n     * @return The input price in 3ULL.\r\n     */\r\n    function getBullPrice(uint256 _price) public view returns (uint256) {\r\n        return oracle.getPriceIn(\"USDC\", \"3ULL\", _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to mint a token for the given address.\r\n     *\r\n     * @param to        The receiving address of the token.\r\n     * @param traitIds  An array of indices of attributes, the\r\n     *                  length of which must be equal to the\r\n     *                  number of traits.\r\n     */\r\n    function mint(address to, uint256[] memory traitIds) external payable {\r\n        _assertMintActive();\r\n\r\n        // The total price of this NFT based on each attribute\r\n        uint256 nftPrice = 0;\r\n\r\n        // Check if the provided traits and attributes list is within the bounds of the contracts traits and attributes\r\n        for (uint8 i = 0; i < traitIds.length; ) {\r\n            IPLAYA3ULLNFT.Trait memory trait = nft.getTrait(i);\r\n            if (traitIds[i] >= trait.maxCount || traitIds[i] < 0) {\r\n                revert TraitsOutOfBounds(i, 0, trait.maxCount);\r\n            }\r\n\r\n            unchecked {\r\n                nftPrice += getAttributePrice(i, traitIds[i]);\r\n                i++;\r\n            }\r\n        }\r\n\r\n        uint256 expectedPrice = nftPrice == 0 ? 0 : getBullPrice(nftPrice);\r\n        if (msg.value != expectedPrice) {\r\n            revert InsufficientValueProvided(expectedPrice);\r\n        }\r\n\r\n        nft.mint(to, traitIds);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether minting is active or inactive.\r\n     */\r\n    function toggleActive() external onlyOwner {\r\n        mintActive = !mintActive;\r\n        emit ToggledMinting(mintActive);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the base expected price for when minting tokens.\r\n     *\r\n     * @param _price    The new price that is being set.\r\n     */\r\n    function setPrice(uint256 _price) external onlyOwner {\r\n        if (_price == 0) {\r\n            revert PriceCannotBeZero();\r\n        }\r\n\r\n        price = _price;\r\n        emit PriceUpdated(price);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the Price Oracle.\r\n     *\r\n     * @param _oracleAddress    The address of the Price Oracle.\r\n     */\r\n    function setOracle(address _oracleAddress) external onlyOwner {\r\n        if (_oracleAddress == address(0)) {\r\n            revert AddressCannotBeZero();\r\n        }\r\n\r\n        oracle = IPriceOracle(_oracleAddress);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        _assertEnoughFunds(amount);\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the owner attempts to withdraw\r\n     *      more funds than the contract balance contains.\r\n     *\r\n     * @param requestedAmount   The amount that is being withdrawn from\r\n     *                          the contract.\r\n     */\r\n    function _assertEnoughFunds(uint256 requestedAmount) internal view {\r\n        if (requestedAmount > address(this).balance) {\r\n            revert NotEnoughFunds(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the a mint attempt occurs but\r\n     *      minting is currently inactive.\r\n     */\r\n    function _assertMintActive() internal view {\r\n        if (!mintActive) {\r\n            revert MintInactive();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/bull/BULLNFTStorage.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport \"./lib/MathUtils.sol\";\r\n\r\nimport {ERC721u} from \"../ERC721u.sol\";\r\nimport {IPLAYA3ULLNFT} from \"./interfaces/I3ULLNFT.sol\";\r\nimport {IPLAYA3ULLNFTEventsAndErrors} from \"./interfaces/I3ULLNFTEventsAndErrors.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games 3ULL NFT Storage Contract\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract contains the storage and administration\r\n *         functionality for the 3ULL NFT tokens.\r\n */\r\ncontract PLAYA3ULLNFTStorage is\r\n    ERC721u,\r\n    IERC2981,\r\n    ERC165Storage,\r\n    IPLAYA3ULLNFT,\r\n    IPLAYA3ULLNFTEventsAndErrors\r\n{\r\n    /// @notice Represents the maximum number of tokens that can\r\n    ///         exist.\r\n    uint256 public maxSupply;\r\n\r\n    /// @notice The total number of tokens that currently exist.\r\n    uint256 public totalSupply;\r\n\r\n    /// @notice The address of the minting contract that is\r\n    ///         authorized to mint on this contract.\r\n    address public minterAddress;\r\n\r\n    /// @notice The address where royalties will be sent.\r\n    address public royaltyAddress;\r\n\r\n    /// @notice Tracks whether the given DNA exists or not.\r\n    mapping(string => bool) public dnaExists;\r\n\r\n    /// @dev Running counter of the number of traits that exist.\r\n    uint256 private numTraits;\r\n\r\n    /// @dev The interface ID of the ERC2981 NFT Royalty Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n    /// @dev The interface ID of the ERC721 NFT Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /// @dev Tracks the NFT that exists (or not) at a given index.\r\n    mapping(uint256 => NFT) private nfts;\r\n\r\n    /// @dev Tracks the trait information at a given index.\r\n    mapping(uint256 => Trait) private traits;\r\n\r\n    /// @dev Tracks the attributes that exist at a given index.\r\n    mapping(uint256 => Attribute[]) private attributes;\r\n\r\n    /// @dev Tracks the addresses that are approved to transfer\r\n    ///      tokens without needing all to be sold.\r\n    mapping(address => bool) private approvedTransferrers;\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint256 _maxSupply\r\n    ) ERC721u(_name, _symbol) {\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n        maxSupply = _maxSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given interface is supported by\r\n     *         this contract.\r\n     *\r\n     * @param interfaceId   The ID of the interface to check.\r\n     *\r\n     * @return Whether the given `interfaceId` is supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721, IERC165, ERC165Storage)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the NFT at the given index.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve.\r\n     *\r\n     * @return The NFT token data.\r\n     */\r\n    function getNFT(uint256 tokenId) external view returns (NFT memory) {\r\n        _assertTokenExists(tokenId);\r\n\r\n        return nfts[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total number of tokens that may exist.\r\n     *\r\n     * @return The maximum supply of tokens.\r\n     */\r\n    function getMaxSupply() external view override returns (uint256) {\r\n        return maxSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current number of tokens that exist.\r\n     *\r\n     * @return The total number of tokens in existence.\r\n     */\r\n    function getTotalSupply() external view override returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of traits that have been added.\r\n     *\r\n     * @return The number of traits.\r\n     */\r\n    function getTraitLength() external view override returns (uint256) {\r\n        return numTraits;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the trait information at the given index.\r\n     *\r\n     * @param traitId   The index of the trait to get.\r\n     *\r\n     * @return The trait data.\r\n     */\r\n    function getTrait(\r\n        uint256 traitId\r\n    ) external view override returns (Trait memory) {\r\n        _assertValidTraitRange(traitId);\r\n\r\n        return traits[traitId];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the number of attributes at a given trait index.\r\n     *\r\n     * @param traitId   The index of the trait where the attributes are\r\n     *                  stored.\r\n     *\r\n     * @return The number of attributes.\r\n     */\r\n    function getAttributeLength(\r\n        uint256 traitId\r\n    ) external view override returns (uint256) {\r\n        return attributes[traitId].length;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the attribute information at the given trait index\r\n     *         and attribute index.\r\n     *\r\n     * @param traitId   The index of the trait that this attribute belongs to.\r\n     * @param attrId    The index of the attribute that is being retrieved.\r\n     *\r\n     * @return The attribute data.\r\n     */\r\n    function getAttribute(\r\n        uint256 traitId,\r\n        uint256 attrId\r\n    ) external view override returns (Attribute memory) {\r\n        _assertValidTraitRange(traitId);\r\n        _assertValidAttributeRange(traitId, attrId);\r\n\r\n        return attributes[traitId][attrId];\r\n    }\r\n\r\n    /**\r\n     * @notice Determines whether the given trait array results in a DNA that\r\n     *         already exists.\r\n     *\r\n     * @param _traits   The trait array to compute on.\r\n     *\r\n     * @return isUnique Whether the computed DNA is unique.\r\n     * @return dna      The computed DNA.\r\n     */\r\n    function isDNAUnique(\r\n        uint256[] memory _traits\r\n    ) public view override returns (bool isUnique, string memory dna) {\r\n        // The concatenated dna string before hashing\r\n        string memory dnaBase = \"\";\r\n\r\n        for (uint8 i = 0; i < _traits.length; ) {\r\n            _assertValidTraitRange(i);\r\n            _assertValidAttributeRange(i, _traits[i]);\r\n\r\n            // Build the DNA string\r\n            bytes memory trait = bytes(attributes[i][_traits[i]].name);\r\n\r\n            dnaBase = string.concat(dnaBase, string(trait));\r\n\r\n            unchecked {\r\n                i++;\r\n            }\r\n        }\r\n\r\n        // Hash the DNA string using keccak256\r\n        dna = MathUtils._bytes32ToString(MathUtils._hash(string(dnaBase)));\r\n\r\n        isUnique = !dnaExists[dna];\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the royalty information for this ERC2981 contract.\r\n     *\r\n     * @param _salePrice    The price of the sale to get royalty information\r\n     *                      for.\r\n     *\r\n     * @return receiver         The receiving address for the royalties.\r\n     * @return royaltyAmount    The amount of royalties.\r\n     */\r\n    function royaltyInfo(\r\n        uint256,\r\n        uint256 _salePrice\r\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (royaltyAddress, (_salePrice * 750) / 10000);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints a 3ULL NFT.\r\n     *\r\n     * @param to        The receiving address of the minted token.\r\n     * @param traitIds  The trait IDs for the token to mint.\r\n     */\r\n    function mint(address to, uint256[] memory traitIds) external override {\r\n        _assertSenderIsAuthorized(msg.sender);\r\n        _assertValidTraitCount(traitIds.length);\r\n        _assertTokensNotSoldOut();\r\n\r\n        (bool _isUnique, string memory _dna) = isDNAUnique(traitIds);\r\n        if (!_isUnique) {\r\n            revert DuplicateTokenDNA();\r\n        }\r\n\r\n        for (uint8 i = 0; i < numTraits; ) {\r\n            unchecked {\r\n                // Increment the number of this trait that has been sold\r\n                attributes[i][traitIds[i]].numSold++;\r\n                i++;\r\n            }\r\n        }\r\n\r\n        nfts[totalSupply] = NFT({dna: _dna, traits: traitIds});\r\n\r\n        dnaExists[_dna] = true;\r\n\r\n        _safeMint(to, totalSupply);\r\n\r\n        emit TokenMinted(to, totalSupply);\r\n\r\n        unchecked {\r\n            totalSupply++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new trait.\r\n     *\r\n     * @param _name     The name of the trait\r\n     * @param _required Whether the trait is required.\r\n     * @param _maxCount The maximum number of attributes the trait can hold.\r\n     */\r\n    function addTrait(\r\n        string memory _name,\r\n        bool _required,\r\n        uint256 _maxCount\r\n    ) external onlyOwner {\r\n        traits[numTraits] = Trait({\r\n            name: _name,\r\n            required: _required,\r\n            maxCount: _maxCount\r\n        });\r\n\r\n        emit TraitAdded(numTraits, _name, traits[numTraits]);\r\n\r\n        unchecked {\r\n            numTraits++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Creates a new attribute for a trait.\r\n     *\r\n     * @param _traitId  The index of the trait that this attribute will\r\n     *                  belong to.\r\n     * @param _name     The name of the attribute.\r\n     * @param _rarity   The rarity value of the attribute.\r\n     */\r\n    function addAttribute(\r\n        uint256 _traitId,\r\n        string memory _name,\r\n        uint256 _rarity\r\n    ) public onlyOwner {\r\n        _assertValidTraitRange(_traitId);\r\n        _assertValidAttributeCount(_traitId);\r\n\r\n        attributes[_traitId].push(\r\n            Attribute({name: _name, rarity: _rarity, numSold: 0})\r\n        );\r\n\r\n        emit AttributeAdded(\r\n            _traitId,\r\n            attributes[_traitId].length - 1,\r\n            _name,\r\n            attributes[_traitId][attributes[_traitId].length - 1]\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Creates multiple attributes at once.\r\n     *\r\n     * @param _traitId      The index of the trait that these attributes\r\n     *                      will belong to.\r\n     * @param _attributes   The attributes data.\r\n     */\r\n    function addMultipleAttributes(\r\n        uint256 _traitId,\r\n        Attribute[] memory _attributes\r\n    ) external onlyOwner {\r\n        _assertValidTraitRange(_traitId);\r\n\r\n        if (attributes[_traitId].length > 0) {\r\n            revert ExistingAttributeLengthMustBeZero();\r\n        }\r\n\r\n        for (uint8 i = 0; i < _attributes.length; i++) {\r\n            addAttribute(_traitId, _attributes[i].name, _attributes[i].rarity);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the minter.\r\n     *         Verifies whether the provided address is a contract, and if not\r\n     *         reverts.\r\n     *\r\n     * @param minter    The address of the minting contract.\r\n     */\r\n    function setMinterAddress(address minter) external onlyOwner {\r\n        uint32 size;\r\n        assembly {\r\n            // Verify whether the provided address is a contract\r\n            size := extcodesize(minter)\r\n        }\r\n\r\n        // The size of the code at the address is zero, therefore is not a contract\r\n        if (size == 0) {\r\n            revert AddressIsNotContract();\r\n        }\r\n\r\n        minterAddress = minter;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address where royalties will be sent.\r\n     *\r\n     * @param _royaltyAddress   The address that will receive royalties.\r\n     */\r\n    function setRoyaltyAddress(address _royaltyAddress) external onlyOwner {\r\n        royaltyAddress = _royaltyAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the maximum number of tokens that can be minted.\r\n     *\r\n     * @param max   The new maximum number of tokens.\r\n     */\r\n    function setMaxSupply(uint256 max) external onlyOwner {\r\n        maxSupply = max;\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether the given `transferrer` is approved to make\r\n     *         token transfers without needing all tokens to be sold.\r\n     *\r\n     * @param transferrer   The address of the transferrer to toggle approval.\r\n     */\r\n    function toggleApprovedTransferrer(address transferrer) external onlyOwner {\r\n        approvedTransferrers[transferrer] = !approvedTransferrers[transferrer];\r\n    }\r\n\r\n    /**\r\n     * @notice Registers that this contract does support a given interface ID.\r\n     *\r\n     * @param _interfaceId  The ID of the interface to register.\r\n     */\r\n    function registerInterface(bytes4 _interfaceId) external onlyOwner {\r\n        _registerInterface(_interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to override the `_beforeTokenTransfer`\r\n     *      hook provided by the ERC721 standard.\r\n     *      Prevents transferring the NFT if they are not tradeable.\r\n     *\r\n     * @param from      The address that is attempting to transfer.\r\n     * @param to        The address that will receive the token.\r\n     * @param tokenId   The ID of the token to transfer.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal override(ERC721) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from == address(0)) return;\r\n\r\n        // Only possibly revert when there are tokens still to be sold, and\r\n        // the transferrer, either `from` or `to` are not approved.\r\n        if (tokenId < maxSupply && totalSupply < maxSupply) {\r\n            if (!approvedTransferrers[from] && !approvedTransferrers[to]) {\r\n                revert TransferOnlyWhenSold(totalSupply, maxSupply);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the tokens have all sold.\r\n     */\r\n    function _assertTokensNotSoldOut() internal view {\r\n        if (totalSupply >= maxSupply) {\r\n            revert TokensSoldOut();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the provided trait count\r\n     *      is not equal to the expected trait count.\r\n     *\r\n     * @param count The provided trait count.\r\n     */\r\n    function _assertValidTraitCount(uint256 count) internal view {\r\n        if (count != numTraits) {\r\n            revert InvalidTraitCountProvided(numTraits);\r\n        } else if (count == 0) {\r\n            revert NoTraitsAdded();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the provided trait value\r\n     *      is outside the range of traits.\r\n     *\r\n     * @param provided  The provided trait value.\r\n     */\r\n    function _assertValidTraitRange(uint256 provided) internal view {\r\n        if (provided >= numTraits && provided >= 0) {\r\n            revert InvalidTraitRange(numTraits);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the provided attribute\r\n     *      value is within range for the given trait value.\r\n     *\r\n     * @param _traitId  The ID of the trait where the attribute resides.\r\n     * @param provided  The provided attribute index.\r\n     */\r\n    function _assertValidAttributeRange(\r\n        uint256 _traitId,\r\n        uint256 provided\r\n    ) internal view {\r\n        if (provided >= traits[_traitId].maxCount) {\r\n            revert InvalidAttributeRange(traits[_traitId].maxCount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the sender of a call\r\n     *      is not authorized to access a function that requires\r\n     *      authorization.\r\n     *\r\n     * @param sender    The address to check authority on.\r\n     */\r\n    function _assertSenderIsAuthorized(address sender) internal view {\r\n        if (sender != owner() && sender != minterAddress) {\r\n            revert UnauthorizedAccessAttempt();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the provided attribute\r\n     *      count is equal to or greater than the maximum attribute count\r\n     *      for the given trait.\r\n     *\r\n     * @param _traitId  The ID of the trait to check.\r\n     */\r\n    function _assertValidAttributeCount(uint256 _traitId) internal view {\r\n        if (attributes[_traitId].length >= traits[_traitId].maxCount) {\r\n            revert AttributeCountExceeded(traits[_traitId].maxCount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/bull/interfaces/I3ULLNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLNFT\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPLAYA3ULLNFT contains all external functions and\r\n *         structs for the 3ULL NFT.\r\n */\r\ninterface IPLAYA3ULLNFT {\r\n\r\n    /**\r\n     * @dev An NFT contains two components: a string that\r\n     *      represents that NFTs DNA, preventing any other\r\n     *      token from using the same DNA, and an array of\r\n     *      traits that the NFT is constructed from.\r\n     */\r\n    struct NFT {\r\n        string dna;\r\n        uint256[] traits;\r\n    }\r\n\r\n    /**\r\n     * @dev A trait represents the different parts of the\r\n     *      token. Each trait contains three components: \r\n     *      a name, whether it is required, and the maximum\r\n     *      number of attributes that this trait may hold.\r\n     */\r\n    struct Trait {\r\n        string name;\r\n        bool required;\r\n        uint256 maxCount;\r\n    }\r\n\r\n    /**\r\n     * @dev An attribute belongs to a trait, and represents\r\n     *      a different and unique variation of the parent\r\n     *      trait. Each attribute contains three components:\r\n     *      a name, a rarity value, and the number of this\r\n     *      attribute that has sold.\r\n     */\r\n    struct Attribute {\r\n        string name;\r\n        uint256 rarity;\r\n        uint256 numSold;\r\n    }\r\n\r\n    function getMaxSupply() external view returns (uint256);\r\n\r\n    function getTotalSupply() external view returns (uint256);\r\n\r\n    function getTraitLength() external view returns (uint256);\r\n    \r\n    function getTrait(uint256 traitId) external view returns (Trait memory);\r\n\r\n    function getAttributeLength(uint256 traitId) external view returns (uint256);\r\n\r\n    function getAttribute(uint256 traitId, uint256 attrId) external view returns (Attribute memory);\r\n\r\n    function isDNAUnique(uint256[] memory traitIds) external view returns (bool isUnique, string memory dna);\r\n\r\n    function mint(address to, uint256[] memory traitIds) external;\r\n}"
    },
    "contracts/nft/bull/interfaces/I3ULLNFTEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {IPLAYA3ULLNFT} from \"./I3ULLNFT.sol\";\r\n\r\n/**\r\n * @title IPLAYA3ULLNFTEventsAndErrors\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPLAYA3ULLNFTEventsAndErrors contains all external events,\r\n *         and errors for the 3ULL NFT.\r\n */\r\ninterface IPLAYA3ULLNFTEventsAndErrors is IPLAYA3ULLNFT {\r\n    /**\r\n     * @dev Emit an event whenever a token is minted.\r\n     *\r\n     * @param to        The address that the token was minted\r\n     *                  to.\r\n     * @param tokenId   The ID of the token that was minted.\r\n     */\r\n    event TokenMinted(address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a new trait is added.\r\n     *\r\n     * @param traitIndex    The index that the new trait resides at.\r\n     * @param name          The name of the added trait.\r\n     * @param addedTrait    The trait that was added.\r\n     */\r\n    event TraitAdded(uint256 indexed traitIndex, string name, Trait addedTrait);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a new attribute is added.\r\n     *\r\n     * @param traitIndex    The index of the trait that this attribute\r\n     *                      belongs to.\r\n     * @param attrIndex     The index that the new attribute resides at.\r\n     * @param name          The name of the added attribute.\r\n     * @param addedAttr     The attribute that was added.\r\n     */\r\n    event AttributeAdded(\r\n        uint256 indexed traitIndex,\r\n        uint256 indexed attrIndex,\r\n        string name,\r\n        Attribute addedAttr\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever the royalty address is updated.\r\n     *\r\n     * @param royalty   The royalty address that has been set.\r\n     */\r\n    event RoyaltyAddressUpdated(address royalty);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint when all the\r\n     *      tokens are sold out.\r\n     */\r\n    error TokensSoldOut();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing an invalid number\r\n     *      of traits.\r\n     *\r\n     * @param expected  The expected number of traits.\r\n     */\r\n    error InvalidTraitCountProvided(uint256 expected);\r\n\r\n    /**\r\n     * @dev Revert with an error when providing no traits for a\r\n     *      mint.\r\n     */\r\n    error NoTraitsAdded();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a token that\r\n     *      has the same DNA as another that already exists.\r\n     */\r\n    error DuplicateTokenDNA();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a value that is out\r\n     *      of range for a trait.\r\n     * @param maxBound  The maximum upper bound trait available.\r\n     */\r\n    error InvalidTraitRange(uint256 maxBound);\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a value that is out\r\n     *      of range for an attribute.\r\n     * @param maxBound  The maximum upper bound attribute available.\r\n     */\r\n    error InvalidAttributeRange(uint256 maxBound);\r\n\r\n    /**\r\n     * @dev Revert with an error when a user that is not authorized\r\n     *      attempts to perform an action that only authorized users\r\n     *      may attempt.\r\n     */\r\n    error UnauthorizedAccessAttempt();\r\n\r\n    /**\r\n     * @dev Revert with an error when setting a contract address that\r\n     *      is not actually a contract.\r\n     */\r\n    error AddressIsNotContract();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to transfer a token\r\n     *      when there are still tokens to sell.\r\n     *\r\n     * @param numSold   The number of tokens that have been sold.\r\n     * @param maxSupply The number of tokens that must be sold in\r\n     *                  order to transfer a token.\r\n     */\r\n    error TransferOnlyWhenSold(uint256 numSold, uint256 maxSupply);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to add multiple attributes\r\n     *      but attributes already exist.\r\n     */\r\n    error ExistingAttributeLengthMustBeZero();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to add attributes but the\r\n     *      number of current attributes is at the maximum count.\r\n     *\r\n     * @param maxAttributes The maximum number of attributes allowed.\r\n     */\r\n    error AttributeCountExceeded(uint256 maxAttributes);\r\n}\r\n"
    },
    "contracts/nft/bull/interfaces/I3ULLNFTMinterEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLNFTMinterEventsAndErrors\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPLAYA3ULLNFTMinterEventsAndErrors contains all external events,\r\n *         and errors for the 3ULL NFT minter.\r\n */\r\ninterface IPLAYA3ULLNFTMinterEventsAndErrors {\r\n    /**\r\n     * @dev Emit an event whenever the owner updates the price.\r\n     *\r\n     * @param price `The updated price.\r\n     */\r\n    event PriceUpdated(uint256 price);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the owner toggles minting on,\r\n     *      or off.\r\n     *\r\n     * @param active    Whether minting is active or inactive.\r\n     */\r\n    event ToggledMinting(bool active);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to update the price\r\n     *      to zero.\r\n     */\r\n    error PriceCannotBeZero();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing an insufficient\r\n     *      value when minting.\r\n     *\r\n     * @param expected  The expected value for mint.\r\n     */\r\n    error InsufficientValueProvided(uint256 expected);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to withdraw balance\r\n     *      that is greater than the balance of the contract.\r\n     *\r\n     * @param balance   The true balance of the contract.\r\n     */\r\n    error NotEnoughFunds(uint256 balance);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint whilst the\r\n     *      mint is inactive.\r\n     */\r\n    error MintInactive();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a token, but\r\n     *      providing incorrect trait ID bounds.\r\n     *\r\n     * @param index The index of the trait that was out of bounds.\r\n     * @param min   The minimum trait ID value.\r\n     * @param max   The maximum trait ID value.\r\n     */\r\n    error TraitsOutOfBounds(uint256 index, uint256 min, uint256 max);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to set an address to\r\n     *      zero.\r\n     */\r\n    error AddressCannotBeZero();\r\n}\r\n"
    },
    "contracts/nft/bull/lib/MathUtils.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title PLAYA3ULL Games Math Utility Library\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This library contains utility functions for calculating\r\n *         various mathematical values that Solidity does not readily\r\n *         provide.\r\n */\r\nlibrary MathUtils {\r\n    int256 internal constant SCALE = 1e18;\r\n    \r\n    ///\r\n    /// @dev Hashes given string using keccak256\r\n    ///\r\n    function _hash(string memory _string) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n    \r\n    ///\r\n    /// @dev Converts bytes16 to bytes32\r\n    ///\r\n    function _bytes16ToBytes32(bytes16 data) internal pure returns (bytes32 result) {\r\n        result = bytes32 (data) & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 |\r\n            (bytes32 (data) & 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 64;\r\n        result = result & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000 |\r\n            (result & 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >> 32;\r\n        result = result & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000 |\r\n            (result & 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >> 16;\r\n        result = result & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000 |\r\n            (result & 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >> 8;\r\n        result = (result & 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >> 4 |\r\n            (result & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >> 8;\r\n        result = bytes32 (0x3030303030303030303030303030303030303030303030303030303030303030 +\r\n            uint256 (result) +\r\n            (uint256 (result) + 0x0606060606060606060606060606060606060606060606060606060606060606 >> 4 &\r\n            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) * 39);\r\n    }\r\n    \r\n    ///\r\n    /// @dev Converts bytes32 to a string\r\n    ///\r\n    function _bytes32ToString(bytes32 data) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(_bytes16ToBytes32(bytes16(data)), _bytes16ToBytes32(bytes16(data << 128))));\r\n    }\r\n    \r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n        if (x >= 2**128) {\r\n            x >>= 128;\r\n            msb += 128;\r\n        }\r\n        if (x >= 2**64) {\r\n            x >>= 64;\r\n            msb += 64;\r\n        }\r\n        if (x >= 2**32) {\r\n            x >>= 32;\r\n            msb += 32;\r\n        }\r\n        if (x >= 2**16) {\r\n            x >>= 16;\r\n            msb += 16;\r\n        }\r\n        if (x >= 2**8) {\r\n            x >>= 8;\r\n            msb += 8;\r\n        }\r\n        if (x >= 2**4) {\r\n            x >>= 4;\r\n            msb += 4;\r\n        }\r\n        if (x >= 2**2) {\r\n            x >>= 2;\r\n            msb += 2;\r\n        }\r\n        if (x >= 2**1) {\r\n            // No need to shift x any more.\r\n            msb += 1;\r\n        }\r\n    }\r\n    \r\n    function log2(int256 x) internal pure returns (int256 result) {\r\n        require(x > 0, \"PB MU: Input must be greater than 0!\");\r\n        unchecked {\r\n            // This works because log2(x) = -log2(1/x).\r\n            int256 sign;\r\n            if (x >= SCALE) {\r\n                sign = 1;\r\n            } else {\r\n                sign = -1;\r\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\r\n                assembly {\r\n                    x := div(1000000000000000000000000000000000000, x)\r\n                }\r\n            }\r\n\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = mostSignificantBit(uint256(x / SCALE));\r\n\r\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\r\n            result = int256(n) * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            int256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result * sign;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (int256 delta = int256(SCALE / 2); delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n            result *= sign;\r\n        }\r\n    }\r\n\r\n\r\n    function abs(int x) internal pure returns (uint256) {\r\n        return x >= 0 ? uint256(x) : uint256(-x);\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function canSub(uint256 a, uint256 b) internal pure returns (bool) {\r\n        if (b > a) return (false);\r\n        return (true);\r\n    }\r\n}"
    },
    "contracts/nft/ERC721u.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\n/**\r\n * @title ERC721u\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract is intended to be inherited and provides\r\n *         access to a central location for handling retrieving,\r\n *         updating, and verifying ERC721 token URIs which the base\r\n *         ERC721 standard does not provide.\r\n *         Additionally, this ERC721u contract supports emitting\r\n *         events when the token URI is updated, allowing listeners\r\n *         to handle this change.\r\n */\r\ncontract ERC721u is ERC721, Ownable {\r\n    /// @notice The base URI for tokens and where their metadata\r\n    ///         is stored.\r\n    string public baseTokenURI;\r\n\r\n    /**\r\n     * @dev Emit an event whenever the base token URI is updated.\r\n     *\r\n     * @param uri   The new base token uri.\r\n     */\r\n    event BaseTokenURIUpdated(string uri);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to access a token ID\r\n     *      that does not exist.\r\n     */\r\n    error TokenDoesNotExist();\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) ERC721(_name, _symbol) {}\r\n\r\n    /**\r\n     * @dev Internal view function to view and return the base token URI.\r\n     *\r\n     * @return The base token URI where the metadata is stored.\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the token URI where the metadata is stored for\r\n     *         a given token ID.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve the URI for.\r\n     *\r\n     * @return The token metadata URI.\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view virtual override returns (string memory) {\r\n        _assertTokenExists(tokenId);\r\n\r\n        return\r\n            string(abi.encodePacked(baseTokenURI, Strings.toString(tokenId)));\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the base token metadata URI.\r\n     *\r\n     * @param _newBaseTokenURI  The new base token URI.\r\n     */\r\n    function setBaseTokenURI(\r\n        string memory _newBaseTokenURI\r\n    ) external onlyOwner {\r\n        baseTokenURI = _newBaseTokenURI;\r\n\r\n        emit BaseTokenURIUpdated(baseTokenURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the given token ID does\r\n     *      not exist.\r\n     *\r\n     * @param tokenId   The ID of the token to verify if exists.\r\n     */\r\n    function _assertTokenExists(uint256 tokenId) internal view {\r\n        if (!_exists(tokenId)) {\r\n            revert TokenDoesNotExist();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/ERC721uUpgradeable.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol\";\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n\r\nimport \"@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol\";\r\n\r\n/**\r\n * @title ERC721uUpgradeable\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract is intended to be inherited and provides\r\n *         access to a central location for handling retrieving,\r\n *         updating, and verifying ERC721 token URIs which the base\r\n *         ERC721 standard does not provide.\r\n *         Additionally, this ERC721u contract supports emitting\r\n *         events when the token URI is updated, allowing listeners\r\n *         to handle this change.\r\n */\r\ncontract ERC721uUpgradeable is ERC721Upgradeable, OwnableUpgradeable {\r\n    /// @notice The base URI for tokens and where their metadata\r\n    ///         is stored.\r\n    string public baseTokenURI;\r\n\r\n    /**\r\n     * @dev Emit an event whenever the base token URI is updated.\r\n     *\r\n     * @param uri   The new base token uri.\r\n     */\r\n    event BaseTokenURIUpdated(string uri);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to access a token ID\r\n     *      that does not exist.\r\n     */\r\n    error TokenDoesNotExist();\r\n\r\n    function __ERC721u_init(\r\n        string memory _name,\r\n        string memory _symbol\r\n    ) internal onlyInitializing {\r\n        __ERC721_init(_name, _symbol);\r\n        __Ownable_init();\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to view and return the base token URI.\r\n     *\r\n     * @return The base token URI where the metadata is stored.\r\n     */\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseTokenURI;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the token URI where the metadata is stored for\r\n     *         a given token ID.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve the URI for.\r\n     *\r\n     * @return The token metadata URI.\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view virtual override returns (string memory) {\r\n        _assertTokenExists(tokenId);\r\n\r\n        return\r\n            string(\r\n                abi.encodePacked(\r\n                    baseTokenURI,\r\n                    StringsUpgradeable.toString(tokenId)\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the base token metadata URI.\r\n     *\r\n     * @param _newBaseTokenURI  The new base token URI.\r\n     */\r\n    function setBaseTokenURI(\r\n        string memory _newBaseTokenURI\r\n    ) external onlyOwner {\r\n        baseTokenURI = _newBaseTokenURI;\r\n\r\n        emit BaseTokenURIUpdated(baseTokenURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the given token ID does\r\n     *      not exist.\r\n     *\r\n     * @param tokenId   The ID of the token to verify if exists.\r\n     */\r\n    function _assertTokenExists(uint256 tokenId) internal view {\r\n        if (!_exists(tokenId)) {\r\n            revert TokenDoesNotExist();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/games/BaseGameCurrency.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC1155/ERC1155.sol\";\r\n\r\nimport {IGameCurrency} from \"./interfaces/IGameCurrency.sol\";\r\nimport {IPriceOracle} from \"../../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\n/**\r\n * @title BaseGameCurrency\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract contains all base functionality for\r\n *         games that utilise an internal currency.\r\n */\r\nabstract contract BaseGameCurrency is IGameCurrency, ERC1155 {\r\n    /*\r\n     *\r\n     * PRIVATE VARIABLES\r\n     *\r\n     */\r\n\r\n    /// @dev The name of the game currency\r\n    string private _name;\r\n\r\n    /// @dev The symbol of the game currency\r\n    string private _symbol;\r\n\r\n    /// @dev The offset for the pack tokens. This value is important\r\n    ///      as it sets the starting point for the pack tokens.\r\n    ///      Once set, no new currencies can be added.\r\n    uint256 private packOffset;\r\n\r\n    /*\r\n     *\r\n     * PUBLIC VARIABLES\r\n     *\r\n     */\r\n\r\n    /// @notice The address of the game admin.\r\n    ///         This address is the controller of adding new packs and\r\n    ///         currencies, as well as adding approved spenders.\r\n    address public gameAdmin;\r\n\r\n    /// @notice The total number of currency packs\r\n    uint256 public totalCurrencyPacks;\r\n\r\n    /// @notice The total number of currencies\r\n    uint256 public totalCurrencies;\r\n\r\n    /// @notice The Price Oracle to retrieve price data from\r\n    IPriceOracle public oracle;\r\n\r\n    /// @notice The mapping of addresses that have been approved to spend\r\n    ///         on behalf of another address.\r\n    mapping(address => bool) public approvedSpenders;\r\n\r\n    /// @notice The mapping of currency packs\r\n    mapping(uint => GameCurrencyPack) public currencyPacks;\r\n\r\n    /// @notice The mapping of currencies\r\n    mapping(uint => GameCurrency) public currencies;\r\n\r\n    /// @notice The mapping of approved markets where the game currency\r\n    ///         can be traded on.\r\n    mapping(address => bool) public approvedMarkets;\r\n\r\n    /// @dev Modifier to check if the caller is the game admin\r\n    ///     If not, revert with `Unauthorized` error\r\n    modifier onlyGameAdmin() {\r\n        if (msg.sender != gameAdmin) {\r\n            revert Unauthorized();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to check if the caller is an approved spender\r\n    ///     If not, revert with `Unauthorized` error\r\n    ///     Note: The game admin is automatically an approved spender\r\n    modifier onlyApprovedSpender() {\r\n        if (!approvedSpenders[msg.sender] && msg.sender != gameAdmin) {\r\n            revert Unauthorized();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory name,\r\n        string memory symbol,\r\n        string memory uri_,\r\n        address _gameAdmin,\r\n        address _oracle,\r\n        uint256 numCurrencies\r\n    ) ERC1155(uri_) {\r\n        _name = name;\r\n        _symbol = symbol;\r\n\r\n        gameAdmin = _gameAdmin;\r\n        oracle = IPriceOracle(_oracle);\r\n\r\n        packOffset = numCurrencies;\r\n    }\r\n\r\n    /*\r\n     *\r\n     * PUBLIC FUNCTIONS\r\n     *\r\n     */\r\n\r\n    function balanceOfPacks(\r\n        address account,\r\n        uint256 id\r\n    ) public view virtual returns (uint256) {\r\n        return balanceOf(account, currencyPacks[id].id + packOffset);\r\n    }\r\n\r\n    function balanceOfCurrency(\r\n        address account,\r\n        uint256 id\r\n    ) public view virtual returns (uint256) {\r\n        return balanceOf(account, currencies[id].id);\r\n    }\r\n\r\n    function mintPacks(uint256 packId, uint256 count) public payable virtual {\r\n        GameCurrencyPack memory pack = currencyPacks[packId];\r\n        uint256 price = getPrice(pack.price * count);\r\n\r\n        _assertValue(msg.value, price);\r\n\r\n        _mint(msg.sender, packId + packOffset, count, \"\");\r\n\r\n        emit PacksMinted(msg.sender, packId, count);\r\n    }\r\n\r\n    function mintCurrency(\r\n        uint256 currencyId,\r\n        uint256 amount\r\n    ) public payable virtual {\r\n        GameCurrency memory currency = currencies[currencyId];\r\n\r\n        if (!currency.purchaseable) {\r\n            revert NonMintableCurrency();\r\n        }\r\n\r\n        uint256 price = getPrice(currency.price * amount);\r\n\r\n        _assertValue(msg.value, price);\r\n\r\n        _mint(msg.sender, currencyId, amount, \"\");\r\n\r\n        emit CurrencyMinted(msg.sender, currencyId, amount);\r\n    }\r\n\r\n    function openPacks(uint256 _id, uint256 count) public virtual {\r\n        _assertEnoughPacks(_id, count);\r\n\r\n        GameCurrencyPack memory pack = currencyPacks[_id];\r\n\r\n        _mint(msg.sender, pack.currencyId, pack.currencyAmount * count, \"\");\r\n        _burn(msg.sender, pack.id + packOffset, count);\r\n\r\n        emit PacksOpened(\r\n            msg.sender,\r\n            pack.id,\r\n            count,\r\n            pack.currencyAmount * count\r\n        );\r\n    }\r\n\r\n    function transferPacks(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) public virtual {\r\n        _assertEnoughPacks(id, amount);\r\n\r\n        _safeTransferFrom(msg.sender, to, id + packOffset, amount, \"\");\r\n    }\r\n\r\n    function transferCurrency(\r\n        address to,\r\n        uint256 id,\r\n        uint256 amount\r\n    ) public virtual {\r\n        _assertEnoughCurrency(id, amount);\r\n\r\n        _safeTransferFrom(msg.sender, to, id, amount, \"\");\r\n    }\r\n\r\n    function name() public view virtual override returns (string memory) {\r\n        return _name;\r\n    }\r\n\r\n    function symbol() public view virtual override returns (string memory) {\r\n        return _symbol;\r\n    }\r\n\r\n    function getPrice(uint256 _price) public view returns (uint256) {\r\n        return oracle.getPriceIn(\"USDC\", \"3ULL\", _price);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * ADMIN FUNCTIONS\r\n     *\r\n     */\r\n\r\n    function mintPacksFor(\r\n        address receiver,\r\n        uint256 packId,\r\n        uint256 count\r\n    ) public virtual onlyGameAdmin {\r\n        _mint(receiver, packId + packOffset, count, \"\");\r\n\r\n        emit PacksMinted(receiver, packId, count);\r\n    }\r\n\r\n    function mintCurrencyFor(\r\n        address receiver,\r\n        uint256 currencyId,\r\n        uint256 amount\r\n    ) public virtual onlyGameAdmin {\r\n        _mint(receiver, currencyId, amount, \"\");\r\n\r\n        emit CurrencyMinted(receiver, currencyId, amount);\r\n    }\r\n\r\n    function spendFor(\r\n        address spender,\r\n        uint256 currencyId,\r\n        uint256 amount\r\n    ) public virtual override onlyApprovedSpender {\r\n        _burn(spender, currencyId, amount);\r\n    }\r\n\r\n    function setOracleAddress(address _oracle) external virtual onlyGameAdmin {\r\n        oracle = IPriceOracle(_oracle);\r\n    }\r\n\r\n    function setGameAdmin(address _gameAdmin) external virtual onlyGameAdmin {\r\n        gameAdmin = _gameAdmin;\r\n    }\r\n\r\n    function toggleApprovedSpender(\r\n        address _spender\r\n    ) external virtual onlyGameAdmin {\r\n        approvedSpenders[_spender] = !approvedSpenders[_spender];\r\n    }\r\n\r\n    function addPack(\r\n        string memory name,\r\n        uint256 price,\r\n        uint256 currencyAmount,\r\n        uint256 currencyId,\r\n        bool tradeable,\r\n        bool marketable\r\n    ) public virtual onlyGameAdmin {\r\n        uint256 packId = totalCurrencyPacks;\r\n\r\n        currencyPacks[packId] = GameCurrencyPack(\r\n            name,\r\n            totalCurrencyPacks,\r\n            price,\r\n            currencyAmount,\r\n            currencyId,\r\n            tradeable,\r\n            marketable\r\n        );\r\n\r\n        totalCurrencyPacks++;\r\n\r\n        emit PackAdded(packId, currencyPacks[packId]);\r\n    }\r\n\r\n    function addCurrency(\r\n        string memory name,\r\n        uint256 price,\r\n        bool tradeable,\r\n        bool purchaseable\r\n    ) public virtual onlyGameAdmin {\r\n        uint256 currencyId = totalCurrencies;\r\n\r\n        currencies[currencyId] = GameCurrency(\r\n            name,\r\n            currencyId,\r\n            price,\r\n            tradeable,\r\n            purchaseable\r\n        );\r\n\r\n        totalCurrencies++;\r\n\r\n        emit CurrencyAdded(currencyId, currencies[currencyId]);\r\n    }\r\n\r\n    function updatePack(\r\n        uint256 packId,\r\n        string memory name,\r\n        uint256 price,\r\n        uint256 currencyAmount,\r\n        uint256 currencyId,\r\n        bool tradeable,\r\n        bool marketable\r\n    ) public virtual onlyGameAdmin {\r\n        currencyPacks[packId] = GameCurrencyPack(\r\n            name,\r\n            packId,\r\n            price,\r\n            currencyAmount,\r\n            currencyId,\r\n            tradeable,\r\n            marketable\r\n        );\r\n\r\n        emit PackUpdated(packId, currencyPacks[packId]);\r\n    }\r\n\r\n    function updateCurrency(\r\n        uint256 currencyId,\r\n        string memory name,\r\n        uint256 price,\r\n        bool tradeable,\r\n        bool purchaseable\r\n    ) public virtual onlyGameAdmin {\r\n        currencies[currencyId] = GameCurrency(\r\n            name,\r\n            currencyId,\r\n            price,\r\n            tradeable,\r\n            purchaseable\r\n        );\r\n\r\n        emit CurrencyUpdated(currencyId, currencies[currencyId]);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyGameAdmin {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * INTERNAL FUNCTIONS\r\n     *\r\n     */\r\n\r\n    function _assertValue(uint256 provided, uint256 expected) internal pure {\r\n        if (provided != expected) {\r\n            revert InsufficientValue(provided, expected);\r\n        }\r\n    }\r\n\r\n    function _assertEnoughPacks(uint256 packId, uint256 count) internal view {\r\n        if (balanceOfPacks(msg.sender, packId) < count) {\r\n            revert NotEnoughPacks(packId, count);\r\n        }\r\n    }\r\n\r\n    function _assertEnoughCurrency(\r\n        uint256 currencyId,\r\n        uint256 amount\r\n    ) internal view {\r\n        if (balanceOfCurrency(msg.sender, currencyId) < amount) {\r\n            revert NotEnoughCurrency(currencyId, amount);\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint256[] memory ids,\r\n        uint256[] memory amounts,\r\n        bytes memory data\r\n    ) internal virtual override {\r\n        super._beforeTokenTransfer(operator, from, to, ids, amounts, data);\r\n\r\n        // Allow minting tokens, burning tokens, and game admin control\r\n        if (from == address(0) || msg.sender == gameAdmin || to == address(0)) {\r\n            return;\r\n        }\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            uint256 id = ids[i];\r\n\r\n            if (id >= packOffset) {\r\n                uint256 packId = id - packOffset;\r\n\r\n                if (\r\n                    currencyPacks[packId].tradeable ||\r\n                    (currencyPacks[packId].marketable && approvedMarkets[to])\r\n                ) {\r\n                    continue;\r\n                }\r\n\r\n                revert NonTradeablePack(packId);\r\n            }\r\n\r\n            if (currencies[id].tradeable) {\r\n                continue;\r\n            }\r\n\r\n            revert NonTradeableCurrency(id);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/games/game-pack/GamePack.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport \"../../../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\nimport {ERC721u} from \"../../ERC721u.sol\";\r\nimport {IGamePack} from \"./interfaces/IGamePack.sol\";\r\nimport {IGamePackOpener} from \"./interfaces/IGamePackOpener.sol\";\r\nimport {IGamePackTokenMinter} from \"./interfaces/IGamePackTokenMinter.sol\";\r\nimport {Randomiser} from \"../../../misc/Randomiser.sol\";\r\nimport {Math} from \"../../../misc/Math.sol\";\r\n\r\ncontract GamePack is IGamePack, ERC721u, ERC165Storage, IERC2981 {\r\n    using Math for uint256;\r\n\r\n    /// @notice The total number of tokens that currently exist.\r\n    uint public totalSupply;\r\n\r\n    /// @notice The total number of packs that currently exist.\r\n    uint public totalPacks;\r\n\r\n    /// @notice Whether or not minting is active.\r\n    bool public mintActive;\r\n\r\n    /// @notice The address where royalties will be sent.\r\n    address public royaltyAddress;\r\n\r\n    /// @notice The address of the treasury manager.\r\n    address public treasuryManager;\r\n\r\n    /// @notice The address of the pack opener.\r\n    address public packOpener;\r\n\r\n    /// @notice The address of the randomiser contract.\r\n    Randomiser public randomiser;\r\n\r\n    /// @notice The interface for the Price Oracle to retrieve\r\n    ///         pricing data from.\r\n    IPriceOracle public oracle;\r\n\r\n    /// @notice Mapping of addresses that are allowed to mint\r\n    mapping(address => bool) public adminMinters;\r\n\r\n    /// @notice Mapping of pack IDs to packs\r\n    mapping(uint256 => Pack) public packs;\r\n\r\n    /// @notice Mapping of token IDs to packs\r\n    mapping(uint256 => PackToken) public packTokens;\r\n\r\n    /// @dev The interface ID of the ERC2981 NFT Royalty Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n    /// @dev The interface ID of the ERC721 NFT Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /// @dev Modifier for allowing set addresses to mint for other addresses.\r\n    modifier onlyMinter() {\r\n        require(\r\n            adminMinters[msg.sender] == true,\r\n            \"GamePack: Unauthorized minter\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _oracleAddress,\r\n        address _treasuryManager,\r\n        address _randomiser\r\n    ) ERC721u(_name, _symbol) {\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n        oracle = IPriceOracle(_oracleAddress);\r\n\r\n        treasuryManager = _treasuryManager;\r\n\r\n        randomiser = Randomiser(_randomiser);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * PUBLIC FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Returns whether the given interface is supported by\r\n     *         this contract.\r\n     *\r\n     * @param interfaceId   The ID of the interface to check.\r\n     *\r\n     * @return Whether the given `interfaceId` is supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721, IERC165, ERC165Storage)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the royalty information for this ERC2981 contract.\r\n     *\r\n     * @param _salePrice    The price of the sale to get royalty information\r\n     *                      for.\r\n     *\r\n     * @return receiver         The receiving address for the royalties.\r\n     * @return royaltyAmount    The amount of royalties.\r\n     */\r\n    function royaltyInfo(\r\n        uint256,\r\n        uint256 _salePrice\r\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (royaltyAddress, (_salePrice * 750) / 10000);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the URI for a given token ID.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve the URI for.\r\n     *\r\n     * @return The URI for `tokenId`.\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory base = _baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return super.tokenURI(tokenId);\r\n        }\r\n\r\n        uint256 skinId = packTokens[tokenId].packId;\r\n\r\n        return string(abi.encodePacked(base, Strings.toString(skinId)));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current number of tokens that exist.\r\n     *\r\n     * @return The total number of tokens in existence.\r\n     */\r\n    function getTotalSupply() external view override returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the caller a pack.\r\n     *\r\n     * @param _packId   The ID of the pack to mint.\r\n     * @param count     The number of packs to mint.\r\n     */\r\n    function mintPack(uint256 _packId, uint256 count) external payable {\r\n        uint256 price = packs[_packId].price;\r\n        uint256 totalPrice = price * count;\r\n\r\n        uint256 purchasePrice = oracle.getPriceIn(\"USDC\", \"3ULL\", totalPrice);\r\n\r\n        // Round purchase price to the nearest 10\r\n        purchasePrice = (purchasePrice / 10) * 10;\r\n\r\n        require(\r\n            msg.value >= purchasePrice,\r\n            \"GamePack: insufficient funds to mint\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _mintPack(msg.sender, _packId);\r\n        }\r\n\r\n        payable(treasuryManager).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Opens a pack.\r\n     *\r\n     * @param _tokenId      The ID of the pack to open.\r\n     * @param _keyTokenId   The ID of the key to use to open the pack.\r\n     */\r\n    function openPack(uint256 _tokenId, uint256 _keyTokenId) external {\r\n        require(\r\n            packOpener == address(0) || msg.sender == packOpener,\r\n            \"GamePack: unauthorized to open packs\"\r\n        );\r\n        require(_tokenId < totalSupply, \"GamePack: pack does not exist\");\r\n        require(!packTokens[_tokenId].opened, \"GamePack: pack already opened\");\r\n        require(ownerOf(_tokenId) == msg.sender, \"GamePack: not owner\");\r\n\r\n        Pack memory pack = packs[packTokens[_tokenId].packId];\r\n\r\n        // Get the number of rewards to mint\r\n        uint256 amount = randomiser.getRandomInRange(\r\n            pack.minResult,\r\n            pack.maxResult\r\n        );\r\n\r\n        // Get the random reward IDs\r\n        uint256[] memory randoms = randomiser.getManyRandomInArrayWithWeights(\r\n            pack.rewardIds,\r\n            pack.rewardWeights,\r\n            pack.distinctResults ? amount.min(pack.rewardIds.length) : amount,\r\n            pack.distinctResults\r\n        );\r\n\r\n        pack.handler.mintBatch(msg.sender, randoms);\r\n\r\n        // Pack was opened, so consume the key\r\n        pack.opener.consumeOpener(_keyTokenId);\r\n\r\n        // Mark the pack as opened\r\n        packTokens[_tokenId].opened = true;\r\n\r\n        _burn(_tokenId);\r\n\r\n        emit PackOpened(_tokenId, msg.sender, randoms);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * ADMIN FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury manager address.\r\n     */\r\n    function setTreasuryManager(address manager) external onlyOwner {\r\n        treasuryManager = manager;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints a pack for the given address.\r\n     *\r\n     * @param _to       The address to mint the pack to.\r\n     * @param _packId   The ID of the pack to mint.\r\n     * @param count     The number of packs to mint.\r\n     */\r\n    function mintPackFor(\r\n        address _to,\r\n        uint256 _packId,\r\n        uint256 count\r\n    ) external onlyMinter {\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _mintPack(_to, _packId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new pack to the contract.\r\n     *\r\n     * @param _name             The name of the pack.\r\n     * @param _keyId            The ID of the key to open the pack.\r\n     * @param _price            The price of the pack.\r\n     * @param _minResult        The minimum number of rewards to mint.\r\n     * @param _maxResult        The maximum number of rewards to mint.\r\n     * @param _rewardIds        The IDs of the rewards that can be minted.\r\n     * @param _rewardWeights    The weights of the rewards that can be minted.\r\n     * @param _distinctRewards  Whether or not the rewards should be distinct.\r\n     * @param _mintHandler      The address of the mint handler.\r\n     * @param _packOpener       The address of the pack opener.\r\n     */\r\n    function addPack(\r\n        string memory _name,\r\n        uint256 _keyId,\r\n        uint256 _price,\r\n        uint256 _minResult,\r\n        uint256 _maxResult,\r\n        uint256[] memory _rewardIds,\r\n        uint256[] memory _rewardWeights,\r\n        bool _distinctRewards,\r\n        address _mintHandler,\r\n        address _packOpener\r\n    ) external onlyOwner {\r\n        uint256 _packId = totalPacks;\r\n\r\n        packs[_packId] = Pack({\r\n            name: _name,\r\n            packId: _packId,\r\n            keyId: _keyId,\r\n            price: _price,\r\n            minResult: _minResult,\r\n            maxResult: _maxResult,\r\n            rewardIds: _rewardIds,\r\n            rewardWeights: _rewardWeights,\r\n            distinctResults: _distinctRewards,\r\n            handler: IGamePackTokenMinter(_mintHandler),\r\n            opener: IGamePackOpener(_packOpener)\r\n        });\r\n\r\n        totalPacks++;\r\n\r\n        emit PackAdded(_packId, _name, _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates an existing pack.\r\n     *\r\n     * @param _packId           The ID of the pack to update.\r\n     * @param _name             The name of the pack.\r\n     * @param _keyId            The ID of the key to open the pack.\r\n     * @param _price            The price of the pack.\r\n     * @param _minResult        The minimum number of rewards to mint.\r\n     * @param _maxResult        The maximum number of rewards to mint.\r\n     * @param _rewardIds        The IDs of the rewards that can be minted.\r\n     * @param _rewardWeights    The weights of the rewards that can be minted.\r\n     * @param _distinctRewards  Whether or not the rewards should be distinct.\r\n     * @param _mintHandler      The address of the mint handler.\r\n     * @param _packOpener       The address of the pack opener.\r\n     */\r\n    function updatePack(\r\n        uint256 _packId,\r\n        string memory _name,\r\n        uint256 _keyId,\r\n        uint256 _price,\r\n        uint256 _minResult,\r\n        uint256 _maxResult,\r\n        uint256[] memory _rewardIds,\r\n        uint256[] memory _rewardWeights,\r\n        bool _distinctRewards,\r\n        address _mintHandler,\r\n        address _packOpener\r\n    ) external onlyOwner {\r\n        packs[_packId] = Pack({\r\n            name: _name,\r\n            packId: _packId,\r\n            keyId: _keyId,\r\n            price: _price,\r\n            minResult: _minResult,\r\n            maxResult: _maxResult,\r\n            rewardIds: _rewardIds,\r\n            rewardWeights: _rewardWeights,\r\n            distinctResults: _distinctRewards,\r\n            handler: IGamePackTokenMinter(_mintHandler),\r\n            opener: IGamePackOpener(_packOpener)\r\n        });\r\n\r\n        emit PackUpdated(_packId, _name, _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles the minting of new NFTs\r\n     */\r\n    function toggleMinting() external onlyOwner {\r\n        mintActive = !mintActive;\r\n\r\n        emit MintingToggled(mintActive);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to toggle the ability for an address to mint.\r\n     *\r\n     * @param _minter   The address to toggle minting for.\r\n     */\r\n    function toggleMinter(address _minter) external onlyOwner {\r\n        adminMinters[_minter] = !adminMinters[_minter];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers that this contract does support a given interface ID.\r\n     *\r\n     * @param _interfaceId  The ID of the interface to register.\r\n     */\r\n    function registerInterface(bytes4 _interfaceId) external onlyOwner {\r\n        _registerInterface(_interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address where royalties will be sent.\r\n     *\r\n     * @param _royaltyAddress   The address that will receive royalties.\r\n     */\r\n    function setRoyaltyAddress(address _royaltyAddress) external onlyOwner {\r\n        royaltyAddress = _royaltyAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the pack opener.\r\n     *\r\n     * @param _packOpener   The address of the pack opener.\r\n     */\r\n    function setPackOpener(address _packOpener) external onlyOwner {\r\n        packOpener = _packOpener;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address of the randomiser contract.\r\n     *\r\n     * @param _randomiser The address of the randomiser contract.\r\n     */\r\n    function setRandomiser(address _randomiser) external onlyOwner {\r\n        randomiser = Randomiser(_randomiser);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * INTERNAL FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @dev Internal function to mint a pack to an address.\r\n     *\r\n     * @param _to       The address to mint the pack to.\r\n     * @param _packId   The ID of the pack to mint.\r\n     */\r\n    function _mintPack(address _to, uint256 _packId) internal {\r\n        require(mintActive == true, \"GamePack: Minting is not active\");\r\n        require(_packId < totalPacks, \"GamePack: Invalid pack ID\");\r\n\r\n        packTokens[totalSupply] = PackToken({opened: false, packId: _packId});\r\n\r\n        _mint(_to, totalSupply);\r\n\r\n        totalSupply++;\r\n\r\n        emit PackMinted(totalSupply - 1, _to, _packId);\r\n    }\r\n}\r\n"
    },
    "contracts/nft/games/game-pack/GamePackOpener.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport \"../../../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\nimport {ERC721u} from \"../../ERC721u.sol\";\r\nimport {IGamePackOpener} from \"./interfaces/IGamePackOpener.sol\";\r\n\r\ncontract GamePackOpener is IGamePackOpener, ERC721u, ERC165Storage, IERC2981 {\r\n    /// @notice The total number of tokens that currently exist.\r\n    uint public totalSupply;\r\n\r\n    /// @notice The total number of pack openers that currently exist.\r\n    uint public totalPackOpeners;\r\n\r\n    /// @notice Whether or not minting is active.\r\n    bool public mintActive;\r\n\r\n    /// @notice The address where royalties will be sent.\r\n    address public royaltyAddress;\r\n\r\n    /// @notice The address of the treasury manager.\r\n    address public treasuryManager;\r\n\r\n    /// @notice The address of the contract approved to open packs.\r\n    address public consumer;\r\n\r\n    /// @notice The interface for the Price Oracle to retrieve\r\n    ///         pricing data from.\r\n    IPriceOracle public oracle;\r\n\r\n    /// @notice Mapping of addresses that are allowed to mint\r\n    mapping(address => bool) public adminMinters;\r\n\r\n    /// @notice Mapping of pack opener IDs to pack openers.\r\n    mapping(uint256 => PackOpener) public packOpeners;\r\n\r\n    /// @notice Mapping of token IDs to pack openers.\r\n    mapping(uint256 => PackOpenerToken) public packOpenerTokens;\r\n\r\n    /// @dev The interface ID of the ERC2981 NFT Royalty Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n    /// @dev The interface ID of the ERC721 NFT Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /// @dev Modifier for allowing set addresses to mint for other addresses.\r\n    modifier onlyMinter() {\r\n        require(\r\n            adminMinters[msg.sender] == true,\r\n            \"GamePackOpener: Unauthorized minter\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier for allowing the consumer to open packs.\r\n    modifier onlyConsumer() {\r\n        require(\r\n            consumer == msg.sender,\r\n            \"GamePackOpener: Unauthorized consumer\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _oracleAddress,\r\n        address _treasuryManager\r\n    ) ERC721u(_name, _symbol) {\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n        oracle = IPriceOracle(_oracleAddress);\r\n\r\n        treasuryManager = _treasuryManager;\r\n    }\r\n\r\n    /*\r\n     *\r\n     * PUBLIC FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Returns whether the given interface is supported by\r\n     *         this contract.\r\n     *\r\n     * @param interfaceId   The ID of the interface to check.\r\n     *\r\n     * @return Whether the given `interfaceId` is supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721, IERC165, ERC165Storage)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the royalty information for this ERC2981 contract.\r\n     *\r\n     * @param _salePrice    The price of the sale to get royalty information\r\n     *                      for.\r\n     *\r\n     * @return receiver         The receiving address for the royalties.\r\n     * @return royaltyAmount    The amount of royalties.\r\n     */\r\n    function royaltyInfo(\r\n        uint256,\r\n        uint256 _salePrice\r\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (royaltyAddress, (_salePrice * 750) / 10000);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the URI for a given token ID.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve the URI for.\r\n     *\r\n     * @return The URI for `tokenId`.\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory base = _baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return super.tokenURI(tokenId);\r\n        }\r\n\r\n        uint256 skinId = packOpenerTokens[tokenId].packOpenerId;\r\n\r\n        return string(abi.encodePacked(base, Strings.toString(skinId)));\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current number of tokens that exist.\r\n     *\r\n     * @return The total number of tokens in existence.\r\n     */\r\n    function getTotalSupply() external view override returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the caller a pack opener.\r\n     *\r\n     * @param _packOpenerId The ID of the pack opener to mint.\r\n     * @param count         The number of pack openers to mint.\r\n     */\r\n    function mintOpener(uint256 _packOpenerId, uint256 count) external payable {\r\n        uint256 price = packOpeners[_packOpenerId].price;\r\n        uint256 totalPrice = price * count;\r\n\r\n        uint256 purchasePrice = oracle.getPriceIn(\"USDC\", \"3ULL\", totalPrice);\r\n\r\n        require(\r\n            msg.value == purchasePrice,\r\n            \"GamePackOpener: Incorrect payment amount\"\r\n        );\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _mintOpener(msg.sender, _packOpenerId);\r\n        }\r\n\r\n        payable(treasuryManager).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Consumes a pack opener.\r\n     *\r\n     * @param _tokenId The ID of the pack opener to consume.\r\n     */\r\n    function consumeOpener(uint256 _tokenId) external override onlyConsumer {\r\n        require(_tokenId < totalSupply, \"GamePackOpener: Invalid opener ID\");\r\n        require(\r\n            packOpenerTokens[_tokenId].opened == false,\r\n            \"GamePackOpener: Opener already opened\"\r\n        );\r\n\r\n        packOpenerTokens[_tokenId].opened = true;\r\n\r\n        _burn(_tokenId);\r\n\r\n        emit PackOpenerConsumed(_tokenId, msg.sender);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * ADMIN FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury manager address.\r\n     */\r\n    function setTreasuryManager(address manager) external onlyOwner {\r\n        treasuryManager = manager;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to mint a pack opener for an address.\r\n     *\r\n     * @param _to           The address to mint the pack opener for.\r\n     * @param _packOpenerId The ID of the pack opener to mint.\r\n     * @param count         The number of pack openers to mint.\r\n     */\r\n    function mintOpenerFor(\r\n        address _to,\r\n        uint256 _packOpenerId,\r\n        uint256 count\r\n    ) external onlyMinter {\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _mintOpener(_to, _packOpenerId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new pack opener.\r\n     *\r\n     * @param _name     The name of the pack opener.\r\n     * @param _price    The price of the pack opener.\r\n     */\r\n    function addPackOpener(\r\n        string memory _name,\r\n        uint256 _price\r\n    ) external onlyOwner {\r\n        uint256 packOpenerId = totalPackOpeners;\r\n\r\n        packOpeners[packOpenerId] = PackOpener({\r\n            name: _name,\r\n            packOpenerId: packOpenerId,\r\n            price: _price\r\n        });\r\n\r\n        totalPackOpeners++;\r\n\r\n        emit PackOpenerAdded(packOpenerId, _name, _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates an existing pack opener.\r\n     *\r\n     * @param _packOpenerId The ID of the pack opener to update.\r\n     * @param _name         The name of the pack opener.\r\n     * @param _price        The price of the pack opener.\r\n     */\r\n    function updatePackOpener(\r\n        uint256 _packOpenerId,\r\n        string memory _name,\r\n        uint256 _price\r\n    ) external onlyOwner {\r\n        PackOpener storage packOpener = packOpeners[_packOpenerId];\r\n\r\n        packOpener.name = _name;\r\n        packOpener.price = _price;\r\n\r\n        emit PackOpenerUpdated(_packOpenerId, _name, _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the consumer address.\r\n     */\r\n    function setConsumerAddress(address _consumer) external onlyOwner {\r\n        consumer = _consumer;\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles the minting of new NFTs\r\n     */\r\n    function toggleMinting() external onlyOwner {\r\n        mintActive = !mintActive;\r\n\r\n        emit MintingToggled(mintActive);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to toggle the ability for an address to mint.\r\n     *\r\n     * @param _minter   The address to toggle minting for.\r\n     */\r\n    function toggleMinter(address _minter) external onlyOwner {\r\n        adminMinters[_minter] = !adminMinters[_minter];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers that this contract does support a given interface ID.\r\n     *\r\n     * @param _interfaceId  The ID of the interface to register.\r\n     */\r\n    function registerInterface(bytes4 _interfaceId) external onlyOwner {\r\n        _registerInterface(_interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address where royalties will be sent.\r\n     *\r\n     * @param _royaltyAddress   The address that will receive royalties.\r\n     */\r\n    function setRoyaltyAddress(address _royaltyAddress) external onlyOwner {\r\n        royaltyAddress = _royaltyAddress;\r\n    }\r\n\r\n    /*\r\n     *\r\n     * INTERNAL FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @dev Internal function to mint a pack opener to an address.\r\n     *\r\n     * @param _to               The address to mint the pack opener to.\r\n     * @param _packOpenerId     The ID of the pack opener to mint.\r\n     */\r\n    function _mintOpener(address _to, uint256 _packOpenerId) internal {\r\n        require(mintActive == true, \"GamePackOpener: Minting is not active\");\r\n        require(\r\n            _packOpenerId < totalPackOpeners,\r\n            \"GamePackOpener: Invalid pack opener ID\"\r\n        );\r\n\r\n        packOpenerTokens[totalSupply] = PackOpenerToken({\r\n            opened: false,\r\n            packOpenerId: _packOpenerId\r\n        });\r\n\r\n        _mint(_to, totalSupply);\r\n\r\n        totalSupply++;\r\n\r\n        emit PackOpenerMinted(totalSupply - 1, _to, _packOpenerId);\r\n    }\r\n}\r\n"
    },
    "contracts/nft/games/game-pack/interfaces/IGamePack.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\nimport {IGamePackOpener} from \"./IGamePackOpener.sol\";\r\nimport {IGamePackTokenMinter} from \"./IGamePackTokenMinter.sol\";\r\n\r\ninterface IGamePack {\r\n    struct Pack {\r\n        string name;\r\n        uint256 packId;\r\n        uint256 keyId;\r\n        uint256 price;\r\n        uint256 minResult;\r\n        uint256 maxResult;\r\n        uint256[] rewardIds;\r\n        uint256[] rewardWeights;\r\n        bool distinctResults;\r\n        IGamePackTokenMinter handler;\r\n        IGamePackOpener opener;\r\n    }\r\n\r\n    struct PackToken {\r\n        bool opened;\r\n        uint256 packId;\r\n    }\r\n\r\n    event PackAdded(uint256 indexed packId, string name, uint256 price);\r\n\r\n    event PackUpdated(uint256 indexed packId, string name, uint256 price);\r\n\r\n    event PackOpened(\r\n        uint256 indexed packId,\r\n        address indexed user,\r\n        uint256[] rewardIds\r\n    );\r\n\r\n    event PackMinted(\r\n        uint256 indexed packId,\r\n        address indexed user,\r\n        uint256 tokenId\r\n    );\r\n\r\n    event MintingToggled(bool enabled);\r\n\r\n    function getTotalSupply() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/nft/games/game-pack/interfaces/IGamePackOpener.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\ninterface IGamePackOpener {\r\n    struct PackOpener {\r\n        string name;\r\n        uint256 packOpenerId;\r\n        uint256 price;\r\n    }\r\n\r\n    struct PackOpenerToken {\r\n        bool opened;\r\n        uint256 packOpenerId;\r\n    }\r\n\r\n    event PackOpenerAdded(\r\n        uint256 indexed packOpenerId,\r\n        string name,\r\n        uint256 price\r\n    );\r\n\r\n    event PackOpenerUpdated(\r\n        uint256 indexed packOpenerId,\r\n        string name,\r\n        uint256 price\r\n    );\r\n\r\n    event PackOpenerConsumed(\r\n        uint256 indexed packOpenerId,\r\n        address indexed user\r\n    );\r\n\r\n    event PackOpenerMinted(\r\n        uint256 indexed packOpenerId,\r\n        address indexed user,\r\n        uint256 tokenId\r\n    );\r\n\r\n    event MintingToggled(bool enabled);\r\n\r\n    function consumeOpener(uint256 _keyId) external;\r\n\r\n    function getTotalSupply() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/nft/games/game-pack/interfaces/IGamePackTokenMinter.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\ninterface IGamePackTokenMinter {\r\n    function mint(address _to, uint256 _tokenId) external;\r\n\r\n    function mintBatch(address _to, uint256[] memory _tokenIds) external;\r\n}\r\n"
    },
    "contracts/nft/games/interfaces/IGameCurrency.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\ninterface IGameCurrency {\r\n    struct GameCurrencyPack {\r\n        string name;\r\n        uint256 id;\r\n        uint256 price;\r\n        uint256 currencyAmount;\r\n        uint256 currencyId;\r\n        bool tradeable;\r\n        bool marketable;\r\n    }\r\n\r\n    struct GameCurrency {\r\n        string name;\r\n        uint256 id;\r\n        uint256 price;\r\n        bool tradeable;\r\n        bool purchaseable;\r\n    }\r\n\r\n    event PacksMinted(\r\n        address indexed owner,\r\n        uint256 indexed packId,\r\n        uint256 count\r\n    );\r\n\r\n    event CurrencyMinted(\r\n        address indexed owner,\r\n        uint256 indexed currencyId,\r\n        uint256 amount\r\n    );\r\n\r\n    event PacksOpened(\r\n        address indexed owner,\r\n        uint256 indexed packId,\r\n        uint256 count,\r\n        uint256 currencyAmount\r\n    );\r\n\r\n    event PackAdded(uint256 indexed packId, GameCurrencyPack pack);\r\n    event PackUpdated(uint256 indexed packId, GameCurrencyPack pack);\r\n\r\n    event CurrencyAdded(uint256 indexed packId, GameCurrency pack);\r\n    event CurrencyUpdated(uint256 indexed packId, GameCurrency pack);\r\n\r\n    error CallerNotOwner();\r\n    error NonMintableCurrency();\r\n    error NotEnoughPacks(uint256 packId, uint256 count);\r\n    error NotEnoughCurrency(uint256 currencyId, uint256 amount);\r\n    error InsufficientValue(uint256 provided, uint256 expected);\r\n    error Unauthorized();\r\n    error NonTradeablePack(uint256 packId);\r\n    error NonTradeableCurrency(uint256 currencyId);\r\n\r\n    function spendFor(\r\n        address spender,\r\n        uint256 currencyId,\r\n        uint256 amount\r\n    ) external;\r\n\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n}\r\n"
    },
    "contracts/nft/games/mars-colony/ColonyMarsGameCurrency.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {BaseGameCurrency} from \"../BaseGameCurrency.sol\";\r\n\r\ncontract ColonyMarsGameCurrency is BaseGameCurrency {\r\n    constructor(\r\n        string memory uri_,\r\n        address _gameAdmin,\r\n        address _oracle\r\n    )\r\n        BaseGameCurrency(\r\n            \"Starvin' Martian Game Currency\",\r\n            \"SMGC\",\r\n            uri_,\r\n            _gameAdmin,\r\n            _oracle,\r\n            2\r\n        )\r\n    {}\r\n}\r\n"
    },
    "contracts/nft/games/mars-colony/ColonyMarsNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\n\r\nimport \"../../../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\nimport {ERC721u} from \"../../ERC721u.sol\";\r\nimport {IColonyMarsNFT} from \"./interfaces/IColonyMarsNFT.sol\";\r\n\r\n/**\r\n * @title ColonyMarsNFT\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract contains all storage and pricing\r\n *         data for the Colony Mars NFT tokens.\r\n */\r\ncontract ColonyMarsNFT is IColonyMarsNFT, ERC721u, ERC165Storage, IERC2981 {\r\n    /// @notice The total number of tokens that currently exist.\r\n    uint public totalSupply;\r\n\r\n    /// @notice Whether or not minting is active.\r\n    bool public mintActive;\r\n\r\n    /// @notice The address where royalties will be sent.\r\n    address public royaltyAddress;\r\n\r\n    /// @notice The address of the treasury manager.\r\n    address public treasuryManager;\r\n\r\n    /// @notice The interface for the Price Oracle to retrieve\r\n    ///         pricing data from.\r\n    IPriceOracle public oracle;\r\n\r\n    /// @notice Mapping of addresses that are allowed to mint nodes\r\n    mapping(address => bool) public adminMinters;\r\n\r\n    /// @dev The interface ID of the ERC2981 NFT Royalty Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n    /// @dev The interface ID of the ERC721 NFT Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /// @dev The number of categories that can exist.\r\n    uint256 private constant NUM_CATEGORIES = 4;\r\n\r\n    /// @dev Tracks the NFT that exists (or not) at a given index.\r\n    mapping(uint => Building) private nfts;\r\n\r\n    /// @dev Stores the given mint data for a category and it's child buildings and tiers.\r\n    mapping(uint => mapping(uint => BuildingDetails[])) private categories;\r\n\r\n    /// @dev The total number of buildings that belong in a category.\r\n    uint256[] public maxCategoryBuildings = new uint256[](NUM_CATEGORIES);\r\n\r\n    /// @dev Modifier for allowing set addresses to mint for other addresses.\r\n    modifier onlyMinter() {\r\n        if (adminMinters[msg.sender] != true) {\r\n            revert UnauthorizedMinter();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        address _oracleAddress,\r\n        address _treasuryManager\r\n    ) ERC721u(_name, _symbol) {\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n        oracle = IPriceOracle(_oracleAddress);\r\n\r\n        treasuryManager = _treasuryManager;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given interface is supported by\r\n     *         this contract.\r\n     *\r\n     * @param interfaceId   The ID of the interface to check.\r\n     *\r\n     * @return Whether the given `interfaceId` is supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721, IERC165, ERC165Storage)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the NFT at the given index.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve.\r\n     *\r\n     * @return The NFT token data.\r\n     */\r\n    function getNFT(uint256 tokenId) external view returns (Building memory) {\r\n        _assertTokenExists(tokenId);\r\n\r\n        return nfts[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current number of tokens that exist.\r\n     *\r\n     * @return The total number of tokens in existence.\r\n     */\r\n    function getTotalSupply() external view returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the current price of 3ULL from the Price\r\n     *         Oracle.\r\n     *\r\n     * @param _price    The USD price to get in 3ULL.\r\n     *\r\n     * @return The input price in 3ULL.\r\n     */\r\n    function getBullPrice(uint256 _price) public view returns (uint256) {\r\n        return oracle.getPriceIn(\"USDC\", \"3ULL\", _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the royalty information for this ERC2981 contract.\r\n     *\r\n     * @param _salePrice    The price of the sale to get royalty information\r\n     *                      for.\r\n     *\r\n     * @return receiver         The receiving address for the royalties.\r\n     * @return royaltyAmount    The amount of royalties.\r\n     */\r\n    function royaltyInfo(\r\n        uint256,\r\n        uint256 _salePrice\r\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (royaltyAddress, (_salePrice * 750) / 10000);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the building details for a given building and tier.\r\n     *         A buildings details includes data such as the type of building,\r\n     *         the purchase price, the current minted amount of that building,\r\n     *         and the total number of that building that can be minted.\r\n     *\r\n     * @param categoryId The ID of the category the building belongs to.\r\n     * @param buildingId The initial ID of the building in the details\r\n     *                   mapping.\r\n     * @param tierId     The building tier ID.\r\n     *\r\n     * @return The building details for the given building and tier IDs.\r\n     */\r\n    function getBuildingDetails(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId\r\n    ) external view returns (BuildingDetails memory) {\r\n        _assertCategoryInRange(categoryId);\r\n\r\n        return categories[categoryId][buildingId][tierId];\r\n    }\r\n\r\n    /**\r\n     * @notice Mints a building with the given tier to the sender. This\r\n     *         function is payable and therefore requires payment in 3ULL in\r\n     *         order to mint.\r\n     *\r\n     * @param categoryId The category the building belongs to.\r\n     * @param buildingId The building that is to be minted.\r\n     * @param tierId     The tier of the building to mint.\r\n     */\r\n    function mint(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId\r\n    ) external payable {\r\n        _assertValidValueProvided(categoryId, buildingId, tierId);\r\n\r\n        _mintBuilding(msg.sender, categoryId, buildingId, tierId);\r\n\r\n        payable(treasuryManager).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an address toggled as an admin minter to mint a building\r\n     *         for an address.\r\n     *\r\n     * @param to            The address that will receive the minted building.\r\n     * @param categoryId    The category the building belongs to.\r\n     * @param buildingId    The building index to mint.\r\n     * @param tierId        The building tier that will be minted.\r\n     */\r\n    function mintFor(\r\n        address to,\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId\r\n    ) external onlyMinter {\r\n        _mintBuilding(to, categoryId, buildingId, tierId);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to toggle whether minting is active or not.\r\n     */\r\n    function toggleMintActive() external onlyOwner {\r\n        mintActive = !mintActive;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury manager address.\r\n     */\r\n    function setTreasuryManager(address manager) external onlyOwner {\r\n        treasuryManager = manager;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the maximum buildings for a given\r\n     *         category.\r\n     *\r\n     * @param categoryId    The category ID to set the max buildings.\r\n     * @param max           The maximum buildings that can exist on the\r\n     *                      category.\r\n     */\r\n    function setMaxBuildings(\r\n        uint256 categoryId,\r\n        uint256 max\r\n    ) external onlyOwner {\r\n        _assertCategoryInRange(categoryId);\r\n\r\n        maxCategoryBuildings[categoryId] = max;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the details of a building.\r\n     *\r\n     * @param categoryId        The category index that the building belons\r\n     *                          to.\r\n     * @param buildingId        The index that will be used to lookup and\r\n     *                          mutate this building at.\r\n     * @param _name             The name of the building.\r\n     * @param _maxCountPerTier  The maximum of this building that can be\r\n     *                          minted at each tier.\r\n     * @param _tierPrices       The building prices at each tier, must be\r\n     *                          the same length as the _maxCountPerTier\r\n     *                          parameter.\r\n     */\r\n    function setBuildingDetails(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        string memory _name,\r\n        uint256[] memory _maxCountPerTier,\r\n        uint256[] memory _tierPrices\r\n    ) external onlyOwner {\r\n        _assertCategoryInRange(categoryId);\r\n\r\n        if (_maxCountPerTier.length != _tierPrices.length) {\r\n            revert ArraysDoNotMatch();\r\n        }\r\n\r\n        uint256[] memory _minted = new uint256[](_tierPrices.length);\r\n        for (uint i = 0; i < _minted.length; i++) {\r\n            if (categories[categoryId][buildingId].length <= i) {\r\n                _minted[i] = 0;\r\n                continue;\r\n            }\r\n\r\n            if (categories[categoryId][buildingId][i].max > 0) {\r\n                // If the maximum value has been set, then we can assume\r\n                // that we are updating the building details, so retrieve\r\n                // the current minted amount.\r\n                _minted[i] = categories[categoryId][buildingId][i].minted;\r\n\r\n                delete categories[categoryId][buildingId][i];\r\n            }\r\n        }\r\n\r\n        for (uint i = 0; i < _minted.length; i++) {\r\n            if (categories[categoryId][buildingId].length <= i) {\r\n                categories[categoryId][buildingId].push(\r\n                    BuildingDetails({\r\n                        name: _name,\r\n                        price: _tierPrices[i],\r\n                        minted: _minted[i],\r\n                        max: _maxCountPerTier[i]\r\n                    })\r\n                );\r\n            } else {\r\n                categories[categoryId][buildingId][i] = BuildingDetails({\r\n                    name: _name,\r\n                    price: _tierPrices[i],\r\n                    minted: _minted[i],\r\n                    max: _maxCountPerTier[i]\r\n                });\r\n            }\r\n\r\n            emit BuildingTierUpdated(\r\n                categoryId,\r\n                buildingId,\r\n                i,\r\n                _name,\r\n                _maxCountPerTier[i],\r\n                _tierPrices[i]\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to update the price of a building tier.\r\n     *\r\n     * @param buildingId    The ID of the building to update.\r\n     * @param tierId        The building tier ID to update.\r\n     * @param newPrice      The new price of the building tier.\r\n     */\r\n    function updateTierPrice(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId,\r\n        uint256 newPrice\r\n    ) external onlyOwner {\r\n        if (categories[categoryId][buildingId].length >= tierId) {\r\n            categories[categoryId][buildingId][tierId].price = newPrice;\r\n\r\n            emit BuildingTierUpdated(\r\n                categoryId,\r\n                buildingId,\r\n                tierId,\r\n                categories[categoryId][buildingId][tierId].name,\r\n                categories[categoryId][buildingId][tierId].max,\r\n                newPrice\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address where royalties will be sent.\r\n     *\r\n     * @param _royaltyAddress   The address that will receive royalties.\r\n     */\r\n    function setRoyaltyAddress(address _royaltyAddress) external onlyOwner {\r\n        royaltyAddress = _royaltyAddress;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers that this contract does support a given interface ID.\r\n     *\r\n     * @param _interfaceId  The ID of the interface to register.\r\n     */\r\n    function registerInterface(bytes4 _interfaceId) external onlyOwner {\r\n        _registerInterface(_interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether the given address can mint without requiring\r\n     *         payment or not.\r\n     *\r\n     * @param minter The address of the minter to toggle.\r\n     */\r\n    function toggleAdminMinter(address minter) external onlyOwner {\r\n        adminMinters[minter] = !adminMinters[minter];\r\n\r\n        emit AdminMinterToggled(minter, adminMinters[minter]);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to mint a building at a certain tier, to a\r\n     *      given address.\r\n     *\r\n     * @param to             The receiving address of the newly minted\r\n     *                       token/building.\r\n     * @param _categoryId    The ID of the category the building belongs to\r\n     * @param _buildingId    The ID of the building, or type of building to\r\n     *                       mint.\r\n     * @param _tierId        The tier of the building to mint.\r\n     */\r\n    function _mintBuilding(\r\n        address to,\r\n        uint256 _categoryId,\r\n        uint256 _buildingId,\r\n        uint256 _tierId\r\n    ) internal {\r\n        if (!mintActive) {\r\n            revert MintInactive();\r\n        }\r\n\r\n        _assertCategoryInRange(_categoryId);\r\n\r\n        if (_buildingId >= maxCategoryBuildings[_categoryId]) {\r\n            revert UnknownBuilding(_categoryId, _buildingId);\r\n        }\r\n\r\n        _assertTierNotMintedOut(_categoryId, _buildingId, _tierId);\r\n\r\n        categories[_categoryId][_buildingId][_tierId].minted++;\r\n\r\n        nfts[totalSupply] = Building({\r\n            categoryId: _categoryId,\r\n            buildingId: _buildingId,\r\n            tierId: _tierId\r\n        });\r\n\r\n        _safeMint(to, totalSupply);\r\n\r\n        emit TokenMinted(to, totalSupply);\r\n\r\n        totalSupply++;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the given building\r\n     *      and tier has reached the maximum number of mints.\r\n     *\r\n     * @param categoryId    The ID of the category.\r\n     * @param buildingId    The ID of the building.\r\n     * @param tierId        The ID of the building tier to verify\r\n     *                      that it has or has not minted out.\r\n     */\r\n    function _assertTierNotMintedOut(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId\r\n    ) internal view {\r\n        if (\r\n            categories[categoryId][buildingId][tierId].minted ==\r\n            categories[categoryId][buildingId][tierId].max\r\n        ) {\r\n            revert BuildingTierMintedOut(\r\n                categoryId,\r\n                buildingId,\r\n                tierId,\r\n                categories[categoryId][buildingId][tierId].max\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the given value in a\r\n     *      payable transaction is invalid.\r\n     *\r\n     * @param categoryId    The ID of the category.\r\n     * @param buildingId    The ID of the building.\r\n     * @param tierId        The ID of the building tier to verify the\r\n     *                      price.\r\n     */\r\n    function _assertValidValueProvided(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId\r\n    ) internal view {\r\n        uint256 basePrice = categories[categoryId][buildingId][tierId].price;\r\n        uint256 convertedPrice = getBullPrice(basePrice);\r\n\r\n        if (msg.value != convertedPrice) {\r\n            revert InsufficientValueProvided(msg.value, convertedPrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if the given category ID\r\n     *      is not within the bounds of the categories.\r\n     *\r\n     * @param given The given category ID.\r\n     */\r\n    function _assertCategoryInRange(uint256 given) internal pure {\r\n        if (given >= NUM_CATEGORIES) {\r\n            revert InvalidCategoryIndex();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/games/mars-colony/interfaces/IColonyMarsNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IColonyMarsNFT\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IColonyMarsNFT contains all external functions, structs,\r\n *         events, and errors for the Colony Mars NFT.\r\n */\r\ninterface IColonyMarsNFT {\r\n    /**\r\n     * @dev A building contains three components: a numeric\r\n     *      index for the building, a numeric index for the\r\n     *      tier of the building, and the type of building.\r\n     */\r\n    struct Building {\r\n        uint256 categoryId;\r\n        uint256 buildingId;\r\n        uint256 tierId;\r\n    }\r\n\r\n    /**\r\n     * @dev The details for a building outline the required\r\n     *      data to be stored on-chain such as the price of\r\n     *      the building, the number of them minted and the\r\n     *      max of the tier that can be minted.\r\n     */\r\n    struct BuildingDetails {\r\n        string name;\r\n        uint256 price;\r\n        uint256 minted;\r\n        uint256 max;\r\n    }\r\n\r\n    /**\r\n     * @dev Emit an event whenever a buildings tier is updated.\r\n     *\r\n     * @param categoryId    The index of the category.\r\n     * @param buildingId    The index of the building.\r\n     * @param tierId        The index of the building tier.\r\n     * @param name          The name of the building.\r\n     * @param maxCount      The number of tokens that can be minted at this tier.\r\n     * @param price         The price of the token at this tier.\r\n     */\r\n    event BuildingTierUpdated(\r\n        uint256 indexed categoryId,\r\n        uint256 indexed buildingId,\r\n        uint256 indexed tierId,\r\n        string name,\r\n        uint256 maxCount,\r\n        uint256 price\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a token is minted.\r\n     *\r\n     * @param to        The address that the token was minted\r\n     *                  to.\r\n     * @param tokenId   The ID of the token that was minted.\r\n     */\r\n    event TokenMinted(address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the royalty address is updated.\r\n     *\r\n     * @param royalty   The royalty address that has been set.\r\n     */\r\n    event RoyaltyAddressUpdated(address royalty);\r\n\r\n    /**\r\n     * @notice                 Emitted when an address' minter access is toggled\r\n     * @param minterAddress    The address of the minter\r\n     * @param canMint          Whether the toggled address can mint\r\n     */\r\n    event AdminMinterToggled(address minterAddress, bool canMint);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a building tier\r\n     *      that has minted out.\r\n     *\r\n     * @param categoryId The ID of the category.\r\n     * @param buildingId The ID of the building.\r\n     * @param tierId     The ID of the tier that the building belongs.\r\n     * @param max        The maximum number of this tier that can be\r\n     *                   minted.\r\n     */\r\n    error BuildingTierMintedOut(\r\n        uint256 categoryId,\r\n        uint256 buildingId,\r\n        uint256 tierId,\r\n        uint256 max\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint but the mint is\r\n     *      inactive.\r\n     */\r\n    error MintInactive();\r\n\r\n    /**\r\n     * @dev Revert with an error when a given value that was provided\r\n     *      was not equal to an expected value.\r\n     */\r\n    error InsufficientValueProvided(uint256 provided, uint256 expected);\r\n\r\n    /**\r\n     * @dev Revert with an error when supplying two arrays that were\r\n     *      meant to match, but didn't.\r\n     */\r\n    error ArraysDoNotMatch();\r\n\r\n    /**\r\n     * @dev Revert with an error when an address attempts to mint for\r\n     *      without having access to that function.\r\n     */\r\n    error UnauthorizedMinter();\r\n\r\n    /**\r\n     * @dev Revert with an error when supplying a category index\r\n     *      outside of the expected category IDs.\r\n     */\r\n    error InvalidCategoryIndex();\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to purchase a building\r\n     *      that does not exist.\r\n     */\r\n    error UnknownBuilding(uint256 categoryId, uint256 buildingId);\r\n}\r\n"
    },
    "contracts/nft/games/nexus/interfaces/INexusNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title INexusNFT\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice INexusNFT contains all external functions, structs,\r\n *         events, and errors for the Nexus NFT.\r\n */\r\ninterface INexusNFT {\r\n    /**\r\n     * @dev The structure of a skin consists of the following:\r\n     *       - skinId: The unique identifier for the skin, this\r\n     *                 is also used as the token ID\r\n     *       - skinType: The type of skin, either a character or\r\n     *                   weapon skin\r\n     *       - price: The price of the skin in USD\r\n     *       - maxQuantity: The maximum number of skins that can\r\n     *                      be minted. If this is 0, then there\r\n     *                      is no limit\r\n     *       - minted: The number of skins that have been minted\r\n     *       - name: The name of the skin\r\n     *       - internalName: The internal name of the skin\r\n     *       - special: Whether or not the skin can be minted\r\n     *                  after the mint ends\r\n     */\r\n    struct Skin {\r\n        uint256 skinId;\r\n        uint256 skinType;\r\n        uint256 price;\r\n        uint256 maxQuantity;\r\n        uint256 minted;\r\n        string name;\r\n        string internalName;\r\n        bool special;\r\n    }\r\n\r\n    /**\r\n     * @dev The structure of a skin bundle offer consists of the\r\n     *      following:\r\n     *       - bundleId: The unique identifier for the bundle\r\n     *       - discount: The discount percentage for the bundle\r\n     *       - skinIds: The IDs of the skins that are in the bundle\r\n     *       - active: Whether or not the bundle is active\r\n     */\r\n    struct SkinBundleOffer {\r\n        uint256 bundleId;\r\n        uint256 discount;\r\n        uint256[] skinIds;\r\n        bool active;\r\n    }\r\n\r\n    /**\r\n     * @dev Emit an event whenever a skin is added.\r\n     *\r\n     * @param skinId       The ID of the skin. This is also the token ID\r\n     * @param skinType     The type of skin, either a character or weapon skin\r\n     * @param price        The price of the skin in USD\r\n     * @param maxQuantity  The maximum number of skins that can be minted\r\n     * @param name         The name of the skin\r\n     * @param internalName The internal name of the skin\r\n     * @param special      Whether or not the skin can be minted after the mint ends\r\n     */\r\n    event SkinAdded(\r\n        uint256 indexed skinId,\r\n        uint256 indexed skinType,\r\n        uint256 price,\r\n        uint256 maxQuantity,\r\n        string name,\r\n        string internalName,\r\n        bool special\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a skin is updated.\r\n     *\r\n     * @param skinId       The ID of the skin. This is also the token ID\r\n     * @param skinType     The type of skin, either a character or weapon skin\r\n     * @param price        The price of the skin in USD\r\n     * @param maxQuantity  The maximum number of skins that can be minted\r\n     * @param name         The name of the skin\r\n     * @param internalName The internal name of the skin\r\n     * @param special      Whether or not the skin can be minted after the mint ends\r\n     */\r\n    event SkinUpdated(\r\n        uint256 indexed skinId,\r\n        uint256 indexed skinType,\r\n        uint256 price,\r\n        uint256 maxQuantity,\r\n        string name,\r\n        string internalName,\r\n        bool special\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a skin bundle offer is added.\r\n     *\r\n     * @param bundleId The ID of the bundle\r\n     * @param discount The discount percentage for the bundle\r\n     * @param skinIds  The IDs of the skins that are in the bundle\r\n     */\r\n    event BundleAdded(\r\n        uint256 indexed bundleId,\r\n        uint256 discount,\r\n        uint256[] skinIds\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a skin bundle offer is updated.\r\n     *\r\n     * @param bundleId The ID of the bundle\r\n     * @param discount The discount percentage for the bundle\r\n     * @param skinIds  The IDs of the skins that are in the bundle\r\n     */\r\n    event BundleUpdated(\r\n        uint256 indexed bundleId,\r\n        uint256 discount,\r\n        uint256[] skinIds\r\n    );\r\n\r\n    /**\r\n     * @dev Emit an event whenever a skin is minted.\r\n     *\r\n     * @param to      The address that the skin was minted to\r\n     * @param tokenId The ID of the skin that was minted\r\n     */\r\n    event SkinMinted(address indexed to, uint256 indexed tokenId);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a skin bundle is minted.\r\n     *\r\n     * @param to       The address that the bundle was minted to\r\n     * @param bundleId The ID of the bundle that was minted\r\n     */\r\n    event BundleMinted(address indexed to, uint256 indexed bundleId);\r\n\r\n    /**\r\n     * @dev Emit an event when an admin toggles minting.\r\n     *\r\n     * @param enabled Whether or not minting is enabled\r\n     */\r\n    event MintingToggled(bool enabled);\r\n\r\n    /**\r\n     * @dev Emit an event when an admin updates the end time.\r\n     *\r\n     * @param endTime The new time when the mint ends\r\n     */\r\n    event EndTimeUpdated(uint256 endTime);\r\n\r\n    /**\r\n     * @dev Emit an event when the owner/admin is updated.\r\n     *\r\n     * @param owner The new owner/admin address\r\n     */\r\n    event OwnerUpdated(address indexed owner);\r\n\r\n    function getTotalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to call a function\r\n     *      that is only allowed by an admin.\r\n     */\r\n    error Unauthorized();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a skin where\r\n     *      the minter does not have the required amount of funds.\r\n     *\r\n     * @param provided The amount of funds provided\r\n     * @param expected The amount of funds expected\r\n     */\r\n    error InsufficientValue(uint256 provided, uint256 expected);\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a skin ID that\r\n     *      does not exist.\r\n     */\r\n    error InvalidSkinID();\r\n\r\n    /**\r\n     * @dev Revert with an error when providing a bundle ID that\r\n     *      does not exist.\r\n     */\r\n    error InvalidBundleID();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a skin that\r\n     *      is sold out.\r\n     */\r\n    error SkinSoldOut();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint, but minting\r\n     *      is disabled.\r\n     */\r\n    error MintingDisabled();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a bundle that\r\n     *      is not active.\r\n     */\r\n    error BundleInactive();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a capped skin\r\n     *      when capped skins are enabled.\r\n     */\r\n    error SkinNoLongerMintable();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to transfer admin\r\n     *      but the current owner has skins.\r\n     *\r\n     * @param skinId The ID of the skin that the owner has\r\n     */\r\n    error OwnerHasSkins(uint256 skinId);\r\n}\r\n"
    },
    "contracts/nft/games/nexus/NexusAdminMinter.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {NexusNFT} from \"./NexusNFT.sol\";\r\nimport {INexusNFT} from \"./interfaces/INexusNFT.sol\";\r\nimport {IGamePackTokenMinter} from \"../game-pack/interfaces/IGamePackTokenMinter.sol\";\r\nimport {IPriceOracle} from \"../../../oracle/price/PriceOracle.sol\";\r\n\r\n/**\r\n * @title NexusAdminMinter\r\n * @author Jourdan (@jourdanhaines)\r\n * @notice NexusAdminMinter allows for minting Nexus skins and bundles\r\n *         for free, by having this contract front the funds.\r\n */\r\ncontract NexusAdminMinter is Ownable, IGamePackTokenMinter {\r\n    /// @notice NexusNFT contract\r\n    NexusNFT public nexusNFT;\r\n\r\n    /// @notice Price oracle contract\r\n    IPriceOracle public oracle;\r\n\r\n    /// @notice The address that is allowed to mint skins and bundles\r\n    address public minter;\r\n\r\n    uint256 public lowFundsThreshold = 1_000_000 ether;\r\n\r\n    /**\r\n     * @notice Event emitted when the funds of the contract are low\r\n     *\r\n     * @param amount  The amount of funds that are left in the contract\r\n     */\r\n    event LowFunds(uint256 amount);\r\n\r\n    modifier onlyAdmin() {\r\n        require(\r\n            msg.sender == minter || msg.sender == owner(),\r\n            \"NexusAdminMinter: caller is not the minter or owner\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(NexusNFT _nexusNFT, address _minter) {\r\n        nexusNFT = _nexusNFT;\r\n\r\n        minter = _minter;\r\n\r\n        oracle = nexusNFT.oracle();\r\n    }\r\n\r\n    /**\r\n     * @notice Mint a skin for free by fronting the funds\r\n     *\r\n     * @param to        The address to mint the skin to\r\n     * @param tokenId   The ID of the skin to mint\r\n     */\r\n    function mint(address to, uint256 tokenId) external override onlyAdmin {\r\n        mintToken(to, tokenId, 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint a batch of skins for free by fronting the funds\r\n     *\r\n     * @param to        The address to mint the skins to\r\n     * @param tokenIds  The IDs of the skins to mint\r\n     */\r\n    function mintBatch(\r\n        address to,\r\n        uint256[] memory tokenIds\r\n    ) external override onlyAdmin {\r\n        for (uint256 i = 0; i < tokenIds.length; i++) {\r\n            mintToken(to, tokenIds[i], 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint skins for free by fronting the funds\r\n     *\r\n     * @param to      The address to mint the skin to\r\n     * @param skinId  The ID of the skin to mint\r\n     * @param count   The number of skins to mint\r\n     */\r\n    function mintToken(\r\n        address to,\r\n        uint256 skinId,\r\n        uint256 count\r\n    ) public onlyAdmin {\r\n        // Get the price of the skin\r\n        // NOTE: Solidity does not allow structs to be returned from external\r\n        //       contract calls, therefore we must use assembly to decode the\r\n        //       struct from the returned bytes\r\n        bytes memory data = abi.encodeWithSignature(\"skins(uint256)\", skinId);\r\n        (, bytes memory result) = address(nexusNFT).staticcall(data);\r\n        (, , uint256 _price) = abi.decode(result, (uint256, uint256, uint256));\r\n\r\n        uint256 price = oracle.getPriceIn(\"USDC\", \"3ULL\", _price * count);\r\n\r\n        nexusNFT.mintFor{value: price}(to, skinId, count);\r\n\r\n        // Check if the funds are low\r\n        if (address(this).balance < lowFundsThreshold) {\r\n            emit LowFunds(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint a bundle for free by fronting the funds\r\n     *\r\n     * @param to        The address to mint the bundle to\r\n     * @param bundleId  The ID of the bundle to mint\r\n     * @param count     The number of bundles to mint\r\n     */\r\n    function mintBundle(\r\n        address to,\r\n        uint256 bundleId,\r\n        uint256 count\r\n    ) external onlyAdmin {\r\n        uint256 bundlePrice = nexusNFT.getBundlePrice(bundleId, count);\r\n\r\n        nexusNFT.mintBundleFor{value: bundlePrice}(to, bundleId, count);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the minter address\r\n     *\r\n     * @param _minter  The address to set as the minter\r\n     */\r\n    function setMinter(address _minter) external onlyOwner {\r\n        minter = _minter;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the low funds threshold\r\n     *\r\n     * @param _lowFundsThreshold  The threshold to set\r\n     */\r\n    function setLowFundsThreshold(\r\n        uint256 _lowFundsThreshold\r\n    ) external onlyOwner {\r\n        lowFundsThreshold = _lowFundsThreshold;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/nft/games/nexus/NexusNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/utils/introspection/ERC165Storage.sol\";\r\nimport \"@openzeppelin/contracts/interfaces/IERC2981.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport {INexusNFT} from \"./interfaces/INexusNFT.sol\";\r\nimport {ERC721u} from \"../../ERC721u.sol\";\r\nimport {IPriceOracle} from \"../../../oracle/price/interfaces/IPriceOracle.sol\";\r\nimport {Ratio} from \"../../../misc/Ratio.sol\";\r\n\r\n/**\r\n * @title NexusNFT\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract contains all base functionality for\r\n *         the Nexus NFT system.\r\n *         This contract is an ERC1155 token, and is used to\r\n *         mint new NFTs.\r\n *         When adding new skins, the type of skin is denoted\r\n *         as either a 0 or 1, where 0 is a character skin, and\r\n *         1 is a weapon skin.\r\n */\r\ncontract NexusNFT is INexusNFT, ERC721u, IERC2981, ERC165Storage {\r\n    using Ratio for uint256;\r\n\r\n    /*\r\n     *\r\n     * PRIVATE VARIABLES\r\n     *\r\n     */\r\n\r\n    /// @dev The interface ID of the ERC2981 NFT Royalty Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\r\n\r\n    /// @dev The interface ID of the ERC721 NFT Standard.\r\n    bytes4 private constant _INTERFACE_ID_ERC721 = 0x80ac58cd;\r\n\r\n    /*\r\n     *\r\n     * PUBLIC VARIABLES\r\n     *\r\n     */\r\n\r\n    /// @notice The total number of skins that have been added\r\n    uint256 public totalSkins;\r\n\r\n    /// @notice The total number of NFTs that have been minted\r\n    uint256 public totalSupply;\r\n\r\n    /// @notice The total number of bundles that have been added\r\n    uint256 public totalBundles;\r\n\r\n    /// @notice The time when minting will end\r\n    uint256 public endTime;\r\n\r\n    /// @notice Whether or not the minting is enabled\r\n    bool public isMintingEnabled = false;\r\n\r\n    /// @notice The address where royalties will be sent.\r\n    address public royaltyAddress;\r\n\r\n    /// @notice The address of the treasury manager.\r\n    address public treasuryManager;\r\n\r\n    /// @notice The Price Oracle to retrieve price data from\r\n    IPriceOracle public oracle;\r\n\r\n    /// @notice Tracks the skins that are available for purchase\r\n    mapping(uint256 => Skin) public skins;\r\n\r\n    /// @notice Tracks the skins that have been minted\r\n    mapping(uint256 => Skin) public tokenSkins;\r\n\r\n    /// @notice Tracks the bundles that have been added\r\n    mapping(uint256 => SkinBundleOffer) public bundles;\r\n\r\n    /*\r\n     *\r\n     * MODIFIERS\r\n     *\r\n     */\r\n\r\n    /// @dev Modifier to check if the caller is the owner\r\n    ///      If not, revert with `Unauthorized` error\r\n    modifier onlyAdmin() {\r\n        if (msg.sender != owner()) {\r\n            revert Unauthorized();\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        address _oracle,\r\n        address _treasuryManager,\r\n        uint256 _endTime,\r\n        string memory name_,\r\n        string memory symbol_\r\n    ) ERC721u(name_, symbol_) {\r\n        _registerInterface(_INTERFACE_ID_ERC721);\r\n        _registerInterface(_INTERFACE_ID_ERC2981);\r\n\r\n        treasuryManager = _treasuryManager;\r\n        oracle = IPriceOracle(_oracle);\r\n\r\n        endTime = _endTime;\r\n    }\r\n\r\n    /*\r\n     *\r\n     * PUBLIC FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Returns whether the given interface is supported by\r\n     *         this contract.\r\n     *\r\n     * @param interfaceId   The ID of the interface to check.\r\n     *\r\n     * @return Whether the given `interfaceId` is supported.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 interfaceId\r\n    )\r\n        public\r\n        view\r\n        virtual\r\n        override(ERC721, IERC165, ERC165Storage)\r\n        returns (bool)\r\n    {\r\n        return super.supportsInterface(interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the URI for a given token ID.\r\n     *\r\n     * @param tokenId   The ID of the token to retrieve the URI for.\r\n     *\r\n     * @return The URI for `tokenId`.\r\n     */\r\n    function tokenURI(\r\n        uint256 tokenId\r\n    ) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory base = _baseURI();\r\n\r\n        if (bytes(base).length == 0) {\r\n            return super.tokenURI(tokenId);\r\n        }\r\n\r\n        uint256 skinId = tokenSkins[tokenId].skinId;\r\n\r\n        return string(abi.encodePacked(base, Strings.toString(skinId)));\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the royalty information for this ERC2981 contract.\r\n     *\r\n     * @param _salePrice    The price of the sale to get royalty information\r\n     *                      for.\r\n     *\r\n     * @return receiver         The receiving address for the royalties.\r\n     * @return royaltyAmount    The amount of royalties.\r\n     */\r\n    function royaltyInfo(\r\n        uint256,\r\n        uint256 _salePrice\r\n    ) external view override returns (address receiver, uint256 royaltyAmount) {\r\n        return (royaltyAddress, (_salePrice * 750) / 10000);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the current number of tokens that exist.\r\n     *\r\n     * @return The total number of tokens in existence.\r\n     */\r\n    function getTotalSupply() external view override returns (uint256) {\r\n        return totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the skins in a bundle\r\n     *\r\n     * @param bundleId The ID of the bundle\r\n     *\r\n     * @return The IDs of the skins in the bundle\r\n     */\r\n    function getBundleSkins(\r\n        uint256 bundleId\r\n    ) external view returns (uint256[] memory) {\r\n        return bundles[bundleId].skinIds;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the price of a bundle\r\n     *\r\n     * @param bundleId The ID of the bundle\r\n     * @param count    The number of bundles to mint\r\n     */\r\n    function getBundlePrice(\r\n        uint256 bundleId,\r\n        uint256 count\r\n    ) public view returns (uint256) {\r\n        uint256 totalPrice = 0;\r\n        for (uint256 i = 0; i < bundles[bundleId].skinIds.length; i++) {\r\n            totalPrice += skins[bundles[bundleId].skinIds[i]].price;\r\n        }\r\n\r\n        uint256 price = oracle.getPriceIn(\"USDC\", \"3ULL\", totalPrice * count);\r\n        uint256 discountedPrice = price -\r\n            (price.getPart(bundles[bundleId].discount));\r\n\r\n        // Round down to the nearest 10\r\n        discountedPrice = (discountedPrice / 10) * 10;\r\n\r\n        return discountedPrice;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice Mints a new NFT to the sender\r\n     *\r\n     * @param skinId The ID of skin to mint\r\n     * @param count  The number of NFTs to mint\r\n     */\r\n    function mint(uint256 skinId, uint256 count) external payable {\r\n        mintFor(msg.sender, skinId, count);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @notice Mints a new NFT to the `to` address\r\n     *\r\n     * @param to     The address to mint the NFT to\r\n     * @param skinId The ID of skin to mint\r\n     * @param count  The number of NFTs to mint\r\n     */\r\n    function mintFor(address to, uint256 skinId, uint256 count) public payable {\r\n        Skin memory skin = skins[skinId];\r\n\r\n        uint256 price = oracle.getPriceIn(\"USDC\", \"3ULL\", skin.price * count);\r\n\r\n        if (msg.value != price) {\r\n            revert InsufficientValue(msg.value, price);\r\n        }\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            _mintToken(to, skinId);\r\n        }\r\n\r\n        payable(treasuryManager).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the NFTs within a bundle to the sender\r\n     *\r\n     * @param bundleId The ID of the bundle to mint\r\n     * @param count    The number of bundles to mint\r\n     */\r\n    function mintBundle(uint256 bundleId, uint256 count) external payable {\r\n        mintBundleFor(msg.sender, bundleId, count);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the NFTs within a bundle to the `to` address\r\n     *\r\n     * @param to       The address to mint the NFTs to\r\n     * @param bundleId The ID of the bundle to mint\r\n     * @param count    The number of bundles to mint\r\n     */\r\n    function mintBundleFor(\r\n        address to,\r\n        uint256 bundleId,\r\n        uint256 count\r\n    ) public payable {\r\n        _assertBundleExists(bundleId);\r\n        _assertBundleActive(bundleId);\r\n\r\n        SkinBundleOffer memory bundle = bundles[bundleId];\r\n\r\n        uint256 price = getBundlePrice(bundleId, count);\r\n\r\n        if (msg.value != price) {\r\n            revert InsufficientValue(msg.value, price);\r\n        }\r\n\r\n        for (uint256 i = 0; i < count; i++) {\r\n            for (uint256 j = 0; j < bundle.skinIds.length; j++) {\r\n                _mintToken(to, bundle.skinIds[j]);\r\n            }\r\n\r\n            emit BundleMinted(to, bundleId);\r\n        }\r\n\r\n        payable(treasuryManager).transfer(msg.value);\r\n    }\r\n\r\n    /*\r\n     *\r\n     * ADMIN FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury manager address.\r\n     */\r\n    function setTreasuryManager(address manager) external onlyOwner {\r\n        treasuryManager = manager;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an admin to mint a new NFT to the `to` address\r\n     *\r\n     * @param to     The address to mint the NFT to\r\n     * @param skinId The ID of skin to mint\r\n     */\r\n    function adminMintFor(address to, uint256 skinId) external onlyAdmin {\r\n        _mintToken(to, skinId);\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new type of skin that can be minted\r\n     *\r\n     * @param _type         The type of skin to add, where 0 is a character\r\n     *                      skin, and 1 is a weapon skin\r\n     * @param _price        The price of the skin in USDC\r\n     * @param _maxQuantity  The maximum number of this skin that can be\r\n     *                      minted. If 0, there is no limit\r\n     * @param _name         The name of the skin\r\n     * @param _internalName The internal name of the skin\r\n     */\r\n    function addSkin(\r\n        uint256 _type,\r\n        uint256 _price,\r\n        uint256 _maxQuantity,\r\n        string memory _name,\r\n        string memory _internalName,\r\n        bool _special\r\n    ) external onlyAdmin {\r\n        // The ID of the skin is the total number of skins before mint\r\n        uint256 _skinId = totalSkins;\r\n\r\n        totalSkins += 1;\r\n\r\n        skins[_skinId] = Skin({\r\n            skinId: _skinId,\r\n            skinType: _type,\r\n            price: _price,\r\n            maxQuantity: _maxQuantity,\r\n            minted: 0,\r\n            name: _name,\r\n            internalName: _internalName,\r\n            special: _special\r\n        });\r\n\r\n        emit SkinAdded(\r\n            _skinId,\r\n            _type,\r\n            _price,\r\n            _maxQuantity,\r\n            _name,\r\n            _internalName,\r\n            _special\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates an existing skin\r\n     *\r\n     * @param _skinId       The ID of the skin to update\r\n     * @param _price        The price of the skin in USDC\r\n     * @param _maxQuantity  The maximum number of this skin that can be\r\n     *                      minted. If 0, there is no limit\r\n     * @param _name         The name of the skin\r\n     * @param _internalName The internal name of the skin\r\n     */\r\n    function updateSkin(\r\n        uint256 _skinId,\r\n        uint256 _price,\r\n        uint256 _maxQuantity,\r\n        string memory _name,\r\n        string memory _internalName,\r\n        bool _special\r\n    ) external onlyAdmin {\r\n        _assertSkinExists(_skinId);\r\n\r\n        skins[_skinId] = Skin({\r\n            skinId: _skinId,\r\n            skinType: skins[_skinId].skinType,\r\n            price: _price,\r\n            maxQuantity: _maxQuantity,\r\n            minted: skins[_skinId].minted,\r\n            name: _name,\r\n            internalName: _internalName,\r\n            special: _special\r\n        });\r\n\r\n        emit SkinUpdated(\r\n            _skinId,\r\n            skins[_skinId].skinType,\r\n            _price,\r\n            _maxQuantity,\r\n            _name,\r\n            _internalName,\r\n            _special\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new bundle that can be purchased\r\n     *\r\n     * @param _discount The discount percentage for the bundle\r\n     * @param _skinIds  The IDs of the skins that are in the bundle\r\n     */\r\n    function addBundle(\r\n        uint256 _discount,\r\n        uint256[] memory _skinIds\r\n    ) external onlyAdmin {\r\n        for (uint256 i = 0; i < _skinIds.length; i++) {\r\n            _assertSkinExists(_skinIds[i]);\r\n        }\r\n\r\n        uint256 _bundleId = totalBundles;\r\n\r\n        totalBundles += 1;\r\n\r\n        bundles[_bundleId] = SkinBundleOffer({\r\n            bundleId: _bundleId,\r\n            discount: _discount,\r\n            skinIds: _skinIds,\r\n            active: true\r\n        });\r\n\r\n        emit BundleAdded(_bundleId, _discount, _skinIds);\r\n    }\r\n\r\n    function updateBundle(\r\n        uint256 _bundleId,\r\n        uint256 _discount,\r\n        uint256[] memory _skinIds,\r\n        bool _active\r\n    ) external onlyAdmin {\r\n        bundles[_bundleId] = SkinBundleOffer({\r\n            bundleId: _bundleId,\r\n            discount: _discount,\r\n            skinIds: _skinIds,\r\n            active: _active\r\n        });\r\n\r\n        emit BundleUpdated(_bundleId, _discount, _skinIds);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles the minting of new NFTs\r\n     */\r\n    function toggleMinting() external onlyAdmin {\r\n        isMintingEnabled = !isMintingEnabled;\r\n\r\n        emit MintingToggled(isMintingEnabled);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the time when the mint ends\r\n     */\r\n    function setEndTime(uint256 _endTime) external onlyAdmin {\r\n        endTime = _endTime;\r\n\r\n        emit EndTimeUpdated(_endTime);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyAdmin {\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers that this contract does support a given interface ID.\r\n     *\r\n     * @param _interfaceId  The ID of the interface to register.\r\n     */\r\n    function registerInterface(bytes4 _interfaceId) external onlyOwner {\r\n        _registerInterface(_interfaceId);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the address where royalties will be sent.\r\n     *\r\n     * @param _royaltyAddress   The address that will receive royalties.\r\n     */\r\n    function setRoyaltyAddress(address _royaltyAddress) external onlyOwner {\r\n        royaltyAddress = _royaltyAddress;\r\n    }\r\n\r\n    /*\r\n     *\r\n     * INTERNAL FUNCTIONS\r\n     *\r\n     */\r\n\r\n    /**\r\n     * @dev Internal function to mint a token to the `to` address\r\n     *\r\n     * @param to     The address to mint the NFT to\r\n     * @param skinId The ID of skin to mint\r\n     */\r\n    function _mintToken(address to, uint256 skinId) internal {\r\n        _assertMintingEnabled();\r\n        _assertSkinMintable(skinId);\r\n        _assertSkinNotSoldOut(skinId);\r\n\r\n        uint256 tokenId = totalSupply;\r\n\r\n        _mint(to, tokenId);\r\n\r\n        tokenSkins[totalSupply] = skins[skinId];\r\n        totalSupply += 1;\r\n        skins[skinId].minted += 1;\r\n\r\n        emit SkinMinted(to, tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to assert that the minting is enabled\r\n     */\r\n    function _assertMintingEnabled() internal view {\r\n        if (!isMintingEnabled) {\r\n            revert MintingDisabled();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to assert that the skin is mintable\r\n     *\r\n     * @param skinId The ID of skin to mint\r\n     */\r\n    function _assertSkinMintable(uint256 skinId) internal view {\r\n        // If the skin is not special, it can only be minted before the end time\r\n        if (!skins[skinId].special && block.timestamp >= endTime) {\r\n            revert SkinNoLongerMintable();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to assert that the skin is not sold out\r\n     *\r\n     * @param skinId The ID of skin to mint\r\n     */\r\n    function _assertSkinNotSoldOut(uint256 skinId) internal view {\r\n        if (\r\n            skins[skinId].maxQuantity > 0 &&\r\n            skins[skinId].minted >= skins[skinId].maxQuantity\r\n        ) {\r\n            revert SkinSoldOut();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to assert that the skin exists\r\n     *\r\n     * @param skinId The ID of skin to mint\r\n     */\r\n    function _assertSkinExists(uint256 skinId) internal view {\r\n        if (skinId >= totalSkins) {\r\n            revert InvalidSkinID();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to assert that the bundle exists\r\n     *\r\n     * @param bundleId The ID of the bundle\r\n     */\r\n    function _assertBundleExists(uint256 bundleId) internal view {\r\n        if (bundleId >= totalBundles) {\r\n            revert InvalidBundleID();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to assert that the bundle is active\r\n     *\r\n     * @param bundleId The ID of the bundle\r\n     */\r\n    function _assertBundleActive(uint256 bundleId) internal view {\r\n        if (!bundles[bundleId].active) {\r\n            revert BundleInactive();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/vi3/interfaces/IVI3EventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLVI3EventsAndErrors\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPLAYA3ULLVI3EventsAndErrors contains all external\r\n *         events and errors for the Very Important 3ULLs.\r\n */\r\ninterface IPLAYA3ULLVI3EventsAndErrors {\r\n    /**\r\n     * @dev Emit an event whenever a new VI3 NFT is minted.\r\n     *\r\n     * @param to        The address of the receiver of the new NFT.\r\n     * @param tokenId   The ID of the new NFT.\r\n     */\r\n    event VI3Minted(address to, uint256 tokenId);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the price of a VI3 is updated.\r\n     *\r\n     * @param price The new price of a VI3 NFT.\r\n     */\r\n    event PriceUpdated(uint256 price);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the VI3 NFTs become tradeable.\r\n     *\r\n     * @param tradeable Whether the NFTs are tradeable or not.\r\n     */\r\n    event TradeableUpdated(bool tradeable);\r\n\r\n    /**\r\n     * @dev Revert with an error when attempting to purchase a\r\n     *      token without supplying the correct deposit amount.\r\n     *\r\n     * @param price The expected price of the token.\r\n     */\r\n    error DepositNotEqual(uint256 price);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to transfer a token\r\n     *      that is not tradeable.\r\n     */\r\n    error NonTransferrableToken();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to transfer a token\r\n     *      to a wallet that already owns a token.\r\n     */\r\n    error ReceiverAlreadyOwnsToken();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to withdraw balance\r\n     *      that is greater than the balance of the contract.\r\n     */\r\n    error NotEnoughFunds(uint256 balance);\r\n}\r\n"
    },
    "contracts/nft/vi3/VI3.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\n\r\nimport {ERC721u} from \"../ERC721u.sol\";\r\nimport {IPLAYA3ULLVI3EventsAndErrors} from \"./interfaces/IVI3EventsAndErrors.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games VI3 Contract\r\n * @author Jourdan (PLAYAY3ULL), Sam (PLAYA3ULL)\r\n * @notice This contract is the central VI3 NFT contract\r\n *         for PLAYA3ULL Games' Very Important 3ULLs.\r\n */\r\ncontract PLAYA3ULLVI3 is ERC721u, IPLAYA3ULLVI3EventsAndErrors {\r\n    /// @notice The price of each VI3\r\n    uint256 public price;\r\n\r\n    /// @notice The total minted number of tokens\r\n    uint256 public totalSupply;\r\n\r\n    /// @notice Whether VI3s are tradeable or not\r\n    bool public tradeable;\r\n\r\n    constructor() ERC721u(\"VERY IMPORTANT 3ULL\", \"VI3\") {\r\n        price = 10000 * 1e18;\r\n        tradeable = false;\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the provided wallet a VI3 NFT,\r\n     *\r\n     * @param to    The receiver of the minted NFT.\r\n     */\r\n    function mint(address to) external payable {\r\n        _assertEqualDeposit(msg.value);\r\n        _safeMint(to, totalSupply);\r\n\r\n        emit VI3Minted(to, totalSupply);\r\n\r\n        unchecked {\r\n            totalSupply++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the price to purchase a NFT.\r\n     *\r\n     * @param _price    The new purchase price.\r\n     */\r\n    function setPrice(uint256 _price) external onlyOwner {\r\n        price = _price;\r\n\r\n        emit PriceUpdated(_price);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether NFTs are tradeable.\r\n     */\r\n    function toggleTradeable() external onlyOwner {\r\n        tradeable = !tradeable;\r\n\r\n        emit TradeableUpdated(tradeable);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        _assertEnoughFunds(amount);\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to override the `_beforeTokenTransfer`\r\n     *      hook provided by the ERC721 standard.\r\n     *      Prevents transferring the NFT if they are not tradeable.\r\n     *\r\n     * @param from      The address that is attempting to transfer.\r\n     * @param to        The address that will receive the token.\r\n     * @param tokenId   The ID of the token to transfer.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal override(ERC721) {\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n\r\n        if (from != address(0)) {\r\n            _assertTokenTradeable();\r\n        }\r\n\r\n        _assertReceiverHasNoTokens(to);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the deposit amount is not equal\r\n     *      to the purchase price of an NFT.\r\n     *\r\n     * @param amount    The amount that is being deposited.\r\n     */\r\n    function _assertEqualDeposit(uint256 amount) internal view {\r\n        if (amount != price) {\r\n            revert DepositNotEqual(price);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the owner attempts to withdraw\r\n     *      more funds than the contract balance contains.\r\n     *\r\n     * @param requestedAmount   The amount that is being withdrawn from\r\n     *                          the contract.\r\n     */\r\n    function _assertEnoughFunds(uint256 requestedAmount) internal view {\r\n        if (requestedAmount > address(this).balance) {\r\n            revert NotEnoughFunds(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert if a token is being\r\n     *      transferred but tokens are not currently set to allow transfers.\r\n     */\r\n    function _assertTokenTradeable() internal view {\r\n        if (!tradeable) {\r\n            revert NonTransferrableToken();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal view function to revert when transferring to a wallet\r\n     *      that already owns a token.\r\n     *\r\n     * @param receiver  The wallet to verify the number of tokens held.\r\n     */\r\n    function _assertReceiverHasNoTokens(address receiver) internal view {\r\n        if (balanceOf(receiver) >= 1) {\r\n            revert ReceiverAlreadyOwnsToken();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/oracle/price/interfaces/IPriceOracle.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPriceOracle\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPriceOracle contains all external functions, structs\r\n *         and events and errors for the Price Oracle.\r\n */\r\ninterface IPriceOracle {\r\n    /**\r\n     * @dev Emit an event whenever a token is set or updated.\r\n     *\r\n     * @param symbol The token symbol.\r\n     */\r\n    event TokenUpdated(string indexed symbol);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a token pair's price is set\r\n     *      or updated.\r\n     *\r\n     * @param symbolA The symbol of the `from` token.\r\n     * @param symbolB The symbol of the `to`, or `in` token.\r\n     * @param price   The new price of the tokenA in tokenB.\r\n     */\r\n    event PairPriceUpdated(\r\n        string indexed symbolA,\r\n        string indexed symbolB,\r\n        uint256 price\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to set a token pair\r\n     *      price that is zero or less.\r\n     */\r\n    error InvalidPrice();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to call a function\r\n     *     that is only allowed by an admin.\r\n     */\r\n    error CallerIsNotAdmin();\r\n\r\n    function getPriceIn(\r\n        string memory tokenFrom,\r\n        string memory tokenIn,\r\n        uint256 price\r\n    ) external view returns (uint256);\r\n\r\n    function getPairPrice(\r\n        string memory symbolA,\r\n        string memory symbolB\r\n    ) external view returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/oracle/price/PriceOracle.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games Price Oracle Contract\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice This contract is the source of truth for price\r\n *         data on the PLAYA3ULL Games blockchain\r\n */\r\ncontract PriceOracle is Ownable, IPriceOracle {\r\n    /// @notice The prices of a given pair, indexed via a key\r\n    mapping(bytes32 => uint256) public pricePairs;\r\n\r\n    /// @notice The administrators that can set prices\r\n    mapping(address => bool) public priceAdmins;\r\n\r\n    /// @dev Modifier for only allowing set addresses to set\r\n    ///      prices\r\n    modifier onlyAdmin() {\r\n        if (!priceAdmins[msg.sender]) {\r\n            revert CallerIsNotAdmin();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the price of a token from it's pair\r\n     *\r\n     * @param tokenFrom  The token to get the price from\r\n     * @param tokenIn    The token to get the price in\r\n     * @param price      The price to get in\r\n     *\r\n     * @return The given price in the token price\r\n     */\r\n    function getPriceIn(\r\n        string memory tokenFrom,\r\n        string memory tokenIn,\r\n        uint256 price\r\n    ) external view returns (uint256) {\r\n        _assertValidPrice(price);\r\n\r\n        (, uint256 priceInToFrom) = getPairPrice(tokenFrom, tokenIn);\r\n\r\n        return (price * 1e18) / priceInToFrom;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the pair price for a given token pair\r\n     *\r\n     * @param symbolA The first token of a pair\r\n     * @param symbolB The second token of a pair\r\n     *\r\n     * @return The price of tokenA in tokenB\r\n     * @return The price of tokenB in tokenA\r\n     */\r\n    function getPairPrice(\r\n        string memory symbolA,\r\n        string memory symbolB\r\n    ) public view returns (uint256, uint256) {\r\n        // Get the keys for the pairs to lookup pricing for\r\n        bytes32 pair1 = getPairKey(symbolA, symbolB);\r\n        bytes32 pair2 = getPairKey(symbolB, symbolA);\r\n\r\n        return (pricePairs[pair1], pricePairs[pair2]);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the pair price for a given token pair\r\n     *\r\n     * @param symbolA The `from` token symbol\r\n     * @param symbolB The `to`, or `in` token symbol\r\n     * @param price The new price for the pair\r\n     */\r\n    function setPairPrice(\r\n        string memory symbolA,\r\n        string memory symbolB,\r\n        uint256 price\r\n    ) external onlyAdmin {\r\n        _assertValidPrice(price);\r\n\r\n        // Construct the token pair key\r\n        bytes32 pairKey = getPairKey(symbolA, symbolB);\r\n        pricePairs[pairKey] = price;\r\n\r\n        emit PairPriceUpdated(symbolA, symbolB, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an owner to toggle whether an address has admin\r\n     *         rights or not\r\n     *\r\n     * @param admin The address to toggle\r\n     */\r\n    function togglePriceAdmin(address admin) external onlyOwner {\r\n        priceAdmins[admin] = !priceAdmins[admin];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to construct a pair key for a given token\r\n     *      pair\r\n     *\r\n     * @param symbolA The first symbol in the pair\r\n     * @param symbolB The second symbol in the pair\r\n     *\r\n     * @return The keypair hash as a bytes32\r\n     */\r\n    function getPairKey(\r\n        string memory symbolA,\r\n        string memory symbolB\r\n    ) internal pure returns (bytes32) {\r\n        bytes32 hash = keccak256(abi.encodePacked(symbolA, symbolB));\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if a given price is zero or less\r\n     *\r\n     * @param price The price to verify\r\n     */\r\n    function _assertValidPrice(uint256 price) internal pure {\r\n        if (price <= 0) {\r\n            revert InvalidPrice();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/BaseGameRewardHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IRewardManager} from \"./interfaces/IRewardManager.sol\";\r\nimport {IGameRewardHandler} from \"./interfaces/IGameRewardHandler.sol\";\r\nimport {ITokenAirdropHandler} from \"./interfaces/ITokenAirdropHandler.sol\";\r\n\r\n/**\r\n * @title BaseGameRewardHandler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Handles reward payments for games by funneling\r\n *         requests to the reward manager.\r\n * @dev    This contract is inherited by other contracts\r\n *         which can implement their own security measures.\r\n */\r\nabstract contract BaseGameRewardHandler is Ownable, IGameRewardHandler {\r\n    /// @notice The total reward payments that have been added\r\n    uint256 public totalRewards;\r\n\r\n    /// @notice The reward manager contract\r\n    IRewardManager public rewardManager;\r\n\r\n    /// @notice The token airdrop handler contract\r\n    ITokenAirdropHandler public tokenAirdropHandler;\r\n\r\n    /// @notice Addresses who are authorised to reward\r\n    mapping(address => bool) public authorisedRewarders;\r\n\r\n    modifier onlyAuthorisedRewarder() {\r\n        require(\r\n            authorisedRewarders[msg.sender],\r\n            \"BaseGameRewardHandler: Not authorised to reward\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlyRewardManager() {\r\n        require(\r\n            msg.sender == address(rewardManager),\r\n            \"BaseGameRewardHandler: Not authorised to reward\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _rewardManager) {\r\n        rewardManager = IRewardManager(_rewardManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Submits a coin reward request to the reward manager\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     */\r\n    function rewardCoin(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external virtual override onlyAuthorisedRewarder {\r\n        _reward(_to, _amount, \"\");\r\n    }\r\n\r\n    /**\r\n     * @notice Submits an NFT reward request to the reward manager\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function rewardToken(\r\n        address _to,\r\n        bytes memory _data\r\n    ) external virtual override onlyAuthorisedRewarder {\r\n        _reward(_to, 1, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Handles the reward from the reward manager\r\n     *\r\n     * @dev This function is to be implemented by the child contract\r\n     *\r\n     * @param _to The address to mint the NFT to\r\n     * @param _data The data to send with the mint\r\n     */\r\n    function handleReward(\r\n        address _to,\r\n        bytes memory _data\r\n    ) external virtual override onlyRewardManager {\r\n        if (tokenAirdropHandler == ITokenAirdropHandler(address(0))) return;\r\n\r\n        tokenAirdropHandler.airdrop(_to, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether an address is authorised to reward or not\r\n     *\r\n     * @param _rewarder The address to toggle\r\n     */\r\n    function toggleAuthorisedRewarder(address _rewarder) external onlyOwner {\r\n        authorisedRewarders[_rewarder] = !authorisedRewarders[_rewarder];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the reward manager\r\n     *\r\n     * @param _rewardManager The reward manager to set\r\n     */\r\n    function setRewardManager(address _rewardManager) external onlyOwner {\r\n        rewardManager = IRewardManager(_rewardManager);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the token airdrop handler\r\n     *\r\n     * @param _tokenAirdropHandler The token airdrop handler to set\r\n     */\r\n    function setTokenAirdropHandler(\r\n        address _tokenAirdropHandler\r\n    ) external onlyOwner {\r\n        tokenAirdropHandler = ITokenAirdropHandler(_tokenAirdropHandler);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to handle the reward\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function _reward(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    ) internal {\r\n        // If there is no attached data, we assume it is a rewardCoin request\r\n        if (_data.length == 0) {\r\n            _beforeRewardCoin(_to, _amount);\r\n        } else {\r\n            _beforeRewardToken(_to, _data);\r\n        }\r\n\r\n        rewardManager.reward(_to, _amount, _data);\r\n\r\n        if (_data.length == 0) {\r\n            _afterRewardCoin(_to, _amount);\r\n        } else {\r\n            _afterRewardToken(_to, _data);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied before a reward is sent.\r\n     *\r\n     * @param _to The address that will be rewarded\r\n     * @param _amount The amount that will be rewarded\r\n     */\r\n    function _beforeRewardCoin(address _to, uint256 _amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied after a reward is sent.\r\n     *\r\n     * @param _to The address that was rewarded\r\n     * @param _amount The amount that was rewarded\r\n     */\r\n    function _afterRewardCoin(address _to, uint256 _amount) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called before a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied before a reward is sent.\r\n     *\r\n     * @param _to The address that will be rewarded\r\n     * @param _data The data that will be sent with the reward\r\n     */\r\n    function _beforeRewardToken(\r\n        address _to,\r\n        bytes memory _data\r\n    ) internal virtual {}\r\n\r\n    /**\r\n     * @dev Hook that is called after a reward is sent\r\n     *\r\n     * This allows child contracts to implement checks and measures that\r\n     * are applied after a reward is sent.\r\n     *\r\n     * @param _to The address that was rewarded\r\n     * @param _data The data that was sent with the reward\r\n     */\r\n    function _afterRewardToken(\r\n        address _to,\r\n        bytes memory _data\r\n    ) internal virtual {}\r\n}\r\n"
    },
    "contracts/rewards/BaseTokenAirdropHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {ITokenAirdropHandler} from \"./interfaces/ITokenAirdropHandler.sol\";\r\n\r\n/**\r\n * @title Base Token Airdrop Handler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Handles token airdrops for a token.\r\n */\r\nabstract contract BaseTokenAirdropHandler is Ownable, ITokenAirdropHandler {\r\n    /**\r\n     * @notice Airdrops a token to the recipient\r\n     *\r\n     * @param _to The address to airdrop to\r\n     * @param _data The data to send with the airdrop\r\n     */\r\n    function airdrop(address _to, bytes memory _data) external override {\r\n        _beforeAirdrop(_to, _data);\r\n\r\n        _airdrop(_to, _data);\r\n\r\n        _afterAirdrop(_to, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to airdrop a token to the recipient\r\n     *\r\n     * @param _to The address to airdrop to\r\n     * @param _data The data to send with the airdrop\r\n     */\r\n    function _airdrop(address _to, bytes memory _data) internal virtual;\r\n\r\n    /**\r\n     * @dev Hook that is called before airdropping a token to the recipient\r\n     *\r\n     * @param _to The address to airdrop to\r\n     * @param _data The data to send with the airdrop\r\n     */\r\n    function _beforeAirdrop(address _to, bytes memory _data) internal virtual;\r\n\r\n    /**\r\n     * @dev Hook that is called after airdropping a token to the recipient\r\n     *\r\n     * @param _to The address to airdrop to\r\n     * @param _data The data to send with the airdrop\r\n     */\r\n    function _afterAirdrop(address _to, bytes memory _data) internal virtual;\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IGameRewardHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Game Reward Handler Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Game Reward Handler contracts.\r\n */\r\ninterface IGameRewardHandler {\r\n    /**\r\n     * @notice Reward a user with coins\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     */\r\n    function rewardCoin(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Reward a user with tokens\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _data The data to pass to the reward manager\r\n     */\r\n    function rewardToken(address _to, bytes memory _data) external;\r\n\r\n    /**\r\n     * @notice Handles the reward after being authorised\r\n     *         by the reward manager.\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _data The data received from the reward manager\r\n     */\r\n    function handleReward(address _to, bytes memory _data) external;\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IRewardManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Reward Manager Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Reward Manager contract.\r\n */\r\ninterface IRewardManager {\r\n    /**\r\n     * @notice A stored reward that was sent to an address\r\n     *\r\n     * @param to The address that was rewarded\r\n     * @param from The address that sent the reward\r\n     * @param amount The amount that was rewarded\r\n     * @param data The data that was sent with the reward\r\n     * @param timestamp The timestamp of the reward\r\n     */\r\n    struct Reward {\r\n        address to;\r\n        address from;\r\n        uint256 amount;\r\n        bytes data;\r\n        uint256 timestamp;\r\n    }\r\n\r\n    /**\r\n     * @notice Emitted when a reward is sent\r\n     *\r\n     * @param _to The address that was rewarded\r\n     * @param _from The address that sent the reward\r\n     * @param _amount The amount that was rewarded\r\n     * @param _data The data that was sent with the reward\r\n     * @param _timestamp The timestamp of the reward\r\n     */\r\n    event RewardSent(\r\n        address indexed _to,\r\n        address indexed _from,\r\n        uint256 _amount,\r\n        bytes _data,\r\n        uint256 _timestamp\r\n    );\r\n\r\n    /**\r\n     * @notice Sends a reward to the recipient\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function reward(address _to, uint256 _amount, bytes memory _data) external;\r\n}\r\n"
    },
    "contracts/rewards/interfaces/ITokenAirdropHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Token Airdrop Handler Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Token Airdrop Handler contract.\r\n */\r\ninterface ITokenAirdropHandler {\r\n    /**\r\n     * @notice Airdrops a token to the recipient\r\n     *\r\n     * @param _to The address to airdrop to\r\n     * @param _data The data to send with the airdrop\r\n     */\r\n    function airdrop(address _to, bytes memory _data) external;\r\n}\r\n"
    },
    "contracts/rewards/NexusAirdropRewardHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"./BaseGameRewardHandler.sol\";\r\n\r\n/**\r\n * @title NexusAirdropRewardHandler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Handles the reward payments for Nexus, specifically\r\n *         the 3ULL airdrop component.\r\n */\r\ncontract NexusAirdropRewardHandler is BaseGameRewardHandler {\r\n    /// @notice The time period in which rewards are tracked\r\n    uint256 public constant EPOCH_PERIOD = 1 days;\r\n\r\n    /// @notice The maximum amount of rewards that can be paid out per epoch\r\n    uint256 public constant MAX_REWARD_PER_EPOCH = 1_000_000 ether;\r\n\r\n    /// @notice The timestamp of the last epoch\r\n    uint256 public lastEpochTimestamp = 0;\r\n\r\n    /// @notice The amount of funds released in the current epoch\r\n    uint256 public fundsReleasedInCurrentEpoch = 0;\r\n\r\n    /// @notice Tracks the last epoch an address was rewarded in\r\n    mapping(address => uint256) public lastAddressRewardEpoch;\r\n\r\n    constructor(address _rewardManager) BaseGameRewardHandler(_rewardManager) {}\r\n\r\n    /**\r\n     * @dev Overrides the hook that is called before the reward is sent\r\n     *      in order to implement custom security measures.\r\n     *\r\n     * @param _to The address to be rewarded\r\n     * @param _amount The amount to be rewarded\r\n     */\r\n    function _beforeRewardCoin(\r\n        address _to,\r\n        uint256 _amount\r\n    ) internal virtual override onlyAuthorisedRewarder {\r\n        // Calculate the current epoch\r\n        uint256 currentEpoch = block.timestamp -\r\n            (block.timestamp % EPOCH_PERIOD);\r\n\r\n        // If the current epoch is greater than the last epoch timestamp,\r\n        // then we need to reset the funds released in the current epoch\r\n        if (currentEpoch > lastEpochTimestamp) {\r\n            lastEpochTimestamp = currentEpoch;\r\n            fundsReleasedInCurrentEpoch = 0;\r\n        }\r\n\r\n        // The funds released in the current epoch must be less than the max\r\n        // reward per epoch\r\n        require(\r\n            fundsReleasedInCurrentEpoch < MAX_REWARD_PER_EPOCH,\r\n            \"NexusAirdropRewardHandler: Max reward per epoch reached\"\r\n        );\r\n\r\n        // We only allow an address to be rewarded once per epoch\r\n        require(\r\n            lastAddressRewardEpoch[_to] < currentEpoch,\r\n            \"NexusAirdropRewardHandler: Address already rewarded in this epoch\"\r\n        );\r\n\r\n        fundsReleasedInCurrentEpoch += _amount;\r\n        lastAddressRewardEpoch[_to] = currentEpoch;\r\n\r\n        super._beforeRewardCoin(_to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/RewardManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IRewardManager} from \"./interfaces/IRewardManager.sol\";\r\nimport {IGameRewardHandler} from \"./interfaces/IGameRewardHandler.sol\";\r\nimport {IVaultCoordinator} from \"../treasury/vault/interfaces/IVaultCoordinator.sol\";\r\n\r\n/**\r\n * @title RewardManager\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Receives authorised payment requests and sends\r\n *         the payments to the recipient.\r\n */\r\ncontract RewardManager is Ownable, IRewardManager {\r\n    /// @notice The total reward payments that have been added\r\n    uint256 public totalRewards;\r\n\r\n    /// @notice The vault coordinator contract\r\n    IVaultCoordinator public vaultCoordinator;\r\n\r\n    /// @notice Tracks the rewards that have been sent\r\n    mapping(uint256 => Reward) public rewards;\r\n\r\n    /// @notice Authorised handlers that can request rewards\r\n    mapping(IGameRewardHandler => bool) public rewardHandlers;\r\n\r\n    modifier onlyRewardHandler() {\r\n        require(\r\n            rewardHandlers[IGameRewardHandler(msg.sender)],\r\n            \"RewardManager: Not authorised to reward\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _vaultCoordinator) {\r\n        vaultCoordinator = IVaultCoordinator(_vaultCoordinator);\r\n    }\r\n\r\n    /**\r\n     * @notice Sends a reward to the recipient\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function reward(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    ) external override onlyRewardHandler {\r\n        _reward(_to, _amount, _data);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether a reward handler is authorised\r\n     *\r\n     * @param _handler The reward handler to toggle\r\n     */\r\n    function toggleRewardHandler(address _handler) external onlyOwner {\r\n        rewardHandlers[IGameRewardHandler(_handler)] = !rewardHandlers[\r\n            IGameRewardHandler(_handler)\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the vault coordinator\r\n     *\r\n     * @param _vaultCoordinator The vault coordinator to set\r\n     */\r\n    function setVaultCoordinator(address _vaultCoordinator) external onlyOwner {\r\n        vaultCoordinator = IVaultCoordinator(_vaultCoordinator);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to send a reward to the recipient\r\n     *\r\n     * @param _to The address to reward\r\n     * @param _amount The amount to reward\r\n     * @param _data The data to send with the reward\r\n     */\r\n    function _reward(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes memory _data\r\n    ) internal {\r\n        // Ensure that the vault coordinator is set\r\n        require(\r\n            vaultCoordinator != IVaultCoordinator(address(0)),\r\n            \"RewardManager: Vault coordinator not set\"\r\n        );\r\n\r\n        // Prevent rewards being sent to the zero address\r\n        require(_to != address(0), \"RewardManager: Cannot reward zero address\");\r\n\r\n        // Amount must be greater than zero\r\n        require(_amount > 0, \"RewardManager: Cannot reward zero amount\");\r\n\r\n        // Track the reward\r\n        rewards[totalRewards] = Reward({\r\n            to: _to,\r\n            from: msg.sender,\r\n            amount: _amount,\r\n            data: _data,\r\n            timestamp: block.timestamp\r\n        });\r\n\r\n        // If the data provided is empty, we assume that the request\r\n        // is to reward coins\r\n        if (_data.length == 0) {\r\n            bytes memory transferData = abi.encode(msg.sender);\r\n\r\n            // The request has been authorised by the reward manager,\r\n            // so we can request the funds to be transferred by the\r\n            // vault coordinator\r\n            vaultCoordinator.transfer(_to, _amount, transferData);\r\n        } else {\r\n            // The request has been authorised by the reward manager,\r\n            // so we can return the request to the handler\r\n            IGameRewardHandler(msg.sender).handleReward(_to, _data);\r\n        }\r\n\r\n        emit RewardSent(_to, msg.sender, _amount, _data, block.timestamp);\r\n    }\r\n}\r\n"
    },
    "contracts/treasury/BaseTreasury.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {ITreasury} from \"./interfaces/ITreasury.sol\";\r\n\r\n/**\r\n * @title Base Treasury Contract\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Base contract for receiving funds.\r\n */\r\ncontract BaseTreasury is ITreasury {\r\n    /**\r\n     * @notice Allows funds to be depositted via a contract call.\r\n     */\r\n    function deposit() external payable virtual override {\r\n        _onReceive(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Called when funds are sent to the contract without data.\r\n     *\r\n     * @dev This fallback function can only accept 2300 gas, which is not enough\r\n     *      which is not enough to complete the transaction. Therefore, we\r\n     *      revert to prevent funds from being locked in the contract.\r\n     */\r\n    receive() external payable override {\r\n        revert(\"BaseTreasury: Funds must be sent via the deposit function\");\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function called when funds are received.\r\n     *\r\n     *      This function is to be implemented by child contracts.\r\n     *\r\n     * @param _from The address that sent the funds.\r\n     */\r\n    function _onReceive(address _from) internal virtual {}\r\n}\r\n"
    },
    "contracts/treasury/BurnableTreasuryReceiver.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {Ratio} from \"../misc/Ratio.sol\";\r\nimport {BaseTreasury} from \"./BaseTreasury.sol\";\r\nimport {IBurnableTreasury} from \"./interfaces/IBurnableTreasury.sol\";\r\nimport {ITreasuryFundController} from \"./interfaces/ITreasuryFundController.sol\";\r\n\r\n/**\r\n * @title Burnable Treasury Receiver Contract\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Contract for receiving funds and burning a percentage of them,\r\n *         before sending the remaining funds on to the treasury.\r\n */\r\ncontract BurnableTreasuryReceiver is Ownable, BaseTreasury, IBurnableTreasury {\r\n    using Ratio for uint256;\r\n\r\n    /// @notice Tracks the total number of coins burnt\r\n    uint256 public totalBurnt;\r\n\r\n    /// @notice The default burn ratio\r\n    uint256 public defaultBurnRatio = 1000; // 10%\r\n\r\n    /// @notice The treasury contract that receives funds\r\n    ITreasuryFundController public treasury;\r\n\r\n    /// @notice The address to send funds to that will be permanently burnt.\r\n    ///         These funds are not tracked in the total supply.\r\n    address public immutable burnAddress =\r\n        0x0000000000000000000000000000000000000000;\r\n\r\n    /// @notice Tracks the burn ratio for each payer\r\n    mapping(address => uint256) public payerBurnRatio;\r\n\r\n    constructor(ITreasuryFundController _treasury) {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the treasury address.\r\n     *\r\n     * @return The treasury address.\r\n     */\r\n    function getTreasury()\r\n        external\r\n        view\r\n        override\r\n        returns (ITreasuryFundController)\r\n    {\r\n        return treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury address.\r\n     *\r\n     * @param _treasury The new treasury address.\r\n     */\r\n    function setTreasuryAddress(\r\n        ITreasuryFundController _treasury\r\n    ) external onlyOwner {\r\n        require(\r\n            address(_treasury) != address(0),\r\n            \"BurnableTreasuryReceiver: Cannot set treasury to zero address\"\r\n        );\r\n\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the burn ratio for a payer.\r\n     *\r\n     * @param _payer The payer to set the burn ratio for.\r\n     * @param _burnRatio The burn ratio to set.\r\n     */\r\n    function setPayerBurnRatio(\r\n        address _payer,\r\n        uint256 _burnRatio\r\n    ) external onlyOwner {\r\n        payerBurnRatio[_payer] = _burnRatio;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the default burn ratio.\r\n     *\r\n     * @param _defaultBurnRatio The default burn ratio to set.\r\n     */\r\n    function setDefaultBurnRatio(uint256 _defaultBurnRatio) external onlyOwner {\r\n        defaultBurnRatio = _defaultBurnRatio;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function called when funds are received.\r\n     *\r\n     * @param _from The address that sent the funds.\r\n     */\r\n    function _onReceive(address _from) internal override {\r\n        uint256 burnRatio = payerBurnRatio[_from];\r\n\r\n        if (burnRatio == 0) {\r\n            burnRatio = defaultBurnRatio;\r\n        }\r\n\r\n        uint256 burnAmount = msg.value.getPart(burnRatio);\r\n        uint256 amountAfterBurn = msg.value - burnAmount;\r\n\r\n        // Transfer the funds, burning those sent to the burn address\r\n        payable(burnAddress).transfer(burnAmount);\r\n        treasury.deposit{value: amountAfterBurn}();\r\n\r\n        // Update the total burnt\r\n        totalBurnt += burnAmount;\r\n\r\n        // Emit the Burn event\r\n        emit Burn(_from, burnAmount);\r\n    }\r\n}\r\n"
    },
    "contracts/treasury/interfaces/IBurnableTreasury.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {ITreasury} from \"./ITreasury.sol\";\r\nimport {ITreasuryFundController} from \"./ITreasuryFundController.sol\";\r\n\r\n/**\r\n * @title Burnable Treasury Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Burnable Treasury contract.\r\n */\r\ninterface IBurnableTreasury is ITreasury {\r\n    /**\r\n     * @notice Emitted when tokens are burned.\r\n     *\r\n     * @param payer The address of the payer.\r\n     * @param amount The amount of tokens burned.\r\n     */\r\n    event Burn(address indexed payer, uint256 amount);\r\n\r\n    /**\r\n     * @notice Returns the treasury fund controller.\r\n     *\r\n     * @return The treasury fund controller.\r\n     */\r\n    function getTreasury() external view returns (ITreasuryFundController);\r\n}\r\n"
    },
    "contracts/treasury/interfaces/ILegacyNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Legacy NFT Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Legacy NFT contract.\r\n */\r\ninterface ILegacyNFT {\r\n    /**\r\n     * @notice Withdraws funds from the contract.\r\n     *\r\n     * @param amount The amount to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external;\r\n\r\n    /**\r\n     * @notice Transfers ownership of a child contract.\r\n     *\r\n     * @param newOwner The address of the new owner.\r\n     */\r\n    function transferOwnership(address newOwner) external;\r\n}\r\n"
    },
    "contracts/treasury/interfaces/ILegacyNFTFundsHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {ILegacyNFT} from \"./ILegacyNFT.sol\";\r\nimport {ITreasury} from \"./ITreasury.sol\";\r\n\r\n/**\r\n * @title Legacy NFT Funds Handler Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Legacy NFT Funds Handler contract.\r\n */\r\ninterface ILegacyNFTFundsHandler {\r\n    /**\r\n     * @notice Returns the treasury address.\r\n     *\r\n     * @return The treasury address.\r\n     */\r\n    function getTreasury() external view returns (ITreasury);\r\n\r\n    /**\r\n     * @notice Withdraws the funds from the child contract to the treasury.\r\n     *\r\n     * @param _child The child contract.\r\n     */\r\n    function withdraw(ILegacyNFT _child) external;\r\n\r\n    /**\r\n     * @notice Transfers ownership of a child contract.\r\n     *\r\n     * @param _child The child contract.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    function transferChildOwnership(\r\n        ILegacyNFT _child,\r\n        address _newOwner\r\n    ) external;\r\n}\r\n"
    },
    "contracts/treasury/interfaces/ITreasury.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Treasury Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Treasury contract.\r\n */\r\ninterface ITreasury {\r\n    /**\r\n     * @notice Allows funds to be depositted via a contract call.\r\n     */\r\n    function deposit() external payable;\r\n\r\n    /**\r\n     * @notice Called when funds are sent to the contract without data.\r\n     */\r\n    receive() external payable;\r\n}\r\n"
    },
    "contracts/treasury/interfaces/ITreasuryFundController.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {ITreasury} from \"./ITreasury.sol\";\r\n\r\n/**\r\n * @title Treasury Fund Controller Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Treasury Fund Controller contract.\r\n */\r\ninterface ITreasuryFundController is ITreasury {\r\n    /**\r\n     * @notice Emitted when the treasury funds reach a low threshold.\r\n     */\r\n    event LowFundWarning(uint256 amount);\r\n\r\n    function isExcludedFromAutoVaultFund(\r\n        address _payer\r\n    ) external view returns (bool);\r\n\r\n    /**\r\n     * @notice Transfers funds to an address\r\n     *\r\n     * @param _to The address to transfer to.\r\n     * @param _amount The amount to transfer.\r\n     */\r\n    function transfer(address _to, uint256 _amount) external;\r\n\r\n    /**\r\n     * @notice Allows contracts to safely deposit funds without triggering\r\n     *         the auto fund mechanism.\r\n     */\r\n    function safeDeposit() external payable;\r\n}\r\n"
    },
    "contracts/treasury/LegacyNFTFundsHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {ILegacyNFTFundsHandler} from \"./interfaces/ILegacyNFTFundsHandler.sol\";\r\nimport {ILegacyNFT} from \"./interfaces/ILegacyNFT.sol\";\r\nimport {ITreasury} from \"./interfaces/ITreasury.sol\";\r\n\r\n/**\r\n * @title Legacy NFT Funds Handler Contract\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Contract for handling funds from the Legacy NFT contracts.\r\n */\r\ncontract LegacyNFTFundsHandler is Ownable, ILegacyNFTFundsHandler {\r\n    /// @notice The treasury contract that receives funds\r\n    ITreasury public treasury;\r\n\r\n    constructor(ITreasury _treasury) {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the treasury address\r\n     *\r\n     * @return The treasury address\r\n     */\r\n    function getTreasury() external view override returns (ITreasury) {\r\n        return treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury address\r\n     *\r\n     * @param _treasury The new treasury address\r\n     */\r\n    function setTreasury(ITreasury _treasury) external onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to transfer the ownership of a child\r\n     *         contract\r\n     *\r\n     * @param _child The child contract\r\n     * @param _newOwner The new owner\r\n     */\r\n    function transferChildOwnership(\r\n        ILegacyNFT _child,\r\n        address _newOwner\r\n    ) external override onlyOwner {\r\n        _child.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw funds from a child contract\r\n     *         to the treasury\r\n     *\r\n     * @param _child The child contract\r\n     */\r\n    function withdraw(ILegacyNFT _child) external override onlyOwner {\r\n        _child.withdraw(address(_child).balance);\r\n\r\n        treasury.deposit{value: address(this).balance}();\r\n    }\r\n\r\n    /**\r\n     * @notice Fallback function to receive funds if no data was sent\r\n     */\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/treasury/TreasuryFundController.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {BaseTreasury} from \"./BaseTreasury.sol\";\r\nimport {ITreasuryFundController} from \"./interfaces/ITreasuryFundController.sol\";\r\nimport {IVaultFundManager} from \"./vault/interfaces/IVaultFundManager.sol\";\r\nimport {IVaultCoordinator} from \"./vault/interfaces/IVaultCoordinator.sol\";\r\n\r\n/**\r\n * @title TreasuryFundController\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice The Treasury Fund Controller contract.\r\n */\r\ncontract TreasuryFundController is\r\n    Ownable,\r\n    BaseTreasury,\r\n    ITreasuryFundController\r\n{\r\n    /// @notice The vault fund manager\r\n    IVaultFundManager public vaultFundManager;\r\n\r\n    /// @notice The treasury address to receive funds\r\n    address public treasury;\r\n\r\n    /// @notice The threshold at which the low fund warning is triggered\r\n    uint256 public lowFundWarningThreshold = 1_000_000 ether;\r\n\r\n    /// @notice Tracks whether an address is authorised to transfer funds\r\n    mapping(address => bool) public authorisedTransferrers;\r\n\r\n    /// @notice Tracks whether a payer is excluded from the auto vault fund\r\n    ///         mechanism\r\n    mapping(address => bool) public payersExcludedFromAutoVaultFund;\r\n\r\n    modifier onlyAuthorisedTransferrer() {\r\n        require(\r\n            msg.sender == owner() || authorisedTransferrers[msg.sender],\r\n            \"TreasuryFundController: Not authorised to transfer funds\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(address _treasury) {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Permissionless function to attempt to fund low vaults.\r\n     */\r\n    function fundLowVaults() external {\r\n        _tryFundVault();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether an address is excluded from the auto vault fund\r\n     *         mechanism.\r\n     *\r\n     * @param _payer The payer address.\r\n     *\r\n     * @return Whether the payer is excluded from the auto vault fund mechanism.\r\n     */\r\n    function isExcludedFromAutoVaultFund(\r\n        address _payer\r\n    ) external view override returns (bool) {\r\n        return payersExcludedFromAutoVaultFund[_payer];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows authorised callers to transfer funds.\r\n     *\r\n     * @param _to The address to transfer to.\r\n     * @param _amount The amount to transfer.\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external override onlyAuthorisedTransferrer {\r\n        payable(_to).transfer(_amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows authorised callers to safely deposit funds without\r\n     *         triggering the auto fund mechanism.\r\n     */\r\n    function safeDeposit() external payable override {}\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury address.\r\n     *\r\n     * @param _treasury The new treasury address.\r\n     */\r\n    function setTreasuryAddress(address _treasury) external onlyOwner {\r\n        treasury = _treasury;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the vault fund manager.\r\n     *\r\n     * @param _vaultFundManager The new vault fund manager.\r\n     */\r\n    function setVaultFundManager(\r\n        IVaultFundManager _vaultFundManager\r\n    ) external onlyOwner {\r\n        vaultFundManager = _vaultFundManager;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the low fund warning threshold.\r\n     *\r\n     * @param _lowFundWarningThreshold The new low fund warning threshold.\r\n     */\r\n    function setLowFundWarningThreshold(\r\n        uint256 _lowFundWarningThreshold\r\n    ) external onlyOwner {\r\n        lowFundWarningThreshold = _lowFundWarningThreshold;\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether funds received from a payer should trigger the\r\n     *         auto vault fund mechanism.\r\n     *\r\n     *         This is useful for payers that already have high gas costs\r\n     *         associated with the transaction, and therefore may end up running\r\n     *         out of gas if the auto vault fund mechanism is triggered.\r\n     *\r\n     * @param _payer The payer address.\r\n     */\r\n    function togglePayerExclusionFromAutoVaultFund(\r\n        address _payer\r\n    ) external onlyOwner {\r\n        payersExcludedFromAutoVaultFund[\r\n            _payer\r\n        ] = !payersExcludedFromAutoVaultFund[_payer];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to authorise an address to transfer funds.\r\n     *\r\n     * @param _address The address to authorise.\r\n     */\r\n    function toggleAuthorisedTransferrer(address _address) external onlyOwner {\r\n        authorisedTransferrers[_address] = !authorisedTransferrers[_address];\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param _amount The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 _amount) external onlyOwner {\r\n        payable(treasury).transfer(_amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function called when funds are received.\r\n     *\r\n     * @param _from The address that sent the funds.\r\n     */\r\n    function _onReceive(address _from) internal override {\r\n        // If the sender is excluded from the auto vault fund mechanism,\r\n        // then return\r\n        if (payersExcludedFromAutoVaultFund[_from]) {\r\n            return;\r\n        }\r\n\r\n        _tryFundVault();\r\n    }\r\n\r\n    function _tryFundVault() internal {\r\n        // If the treasury balance is 0, then return\r\n        if (address(this).balance == 0) {\r\n            emit LowFundWarning(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        // If the vault fund manager is not set, then return\r\n        if (vaultFundManager == IVaultFundManager(address(0))) return;\r\n\r\n        IVaultCoordinator coordinator = vaultFundManager.getCoordinator();\r\n        IVaultCoordinator.Vault memory vault = vaultFundManager\r\n            .findNextLowFundVault();\r\n\r\n        // If the manager of the vault is the zero address, then we can assume no vault needs\r\n        // funding, or if the vault has sufficient funds, then return\r\n        if (\r\n            vault.manager == address(0) ||\r\n            vault.balance > vault.lowFundThreshold\r\n        ) return;\r\n\r\n        // The amount to send is the difference between the low fund threshold\r\n        // and the vault balance, plus the receive fund offset.\r\n        // This ensures the fund is adequately topped up.\r\n        uint256 amountToSend = (vault.lowFundThreshold - vault.balance) +\r\n            vault.receiveFundOffset;\r\n\r\n        // If the amount to send is greater than the treasury balance, then\r\n        // reduce the amount to send to the treasury balance\r\n        if (amountToSend > address(this).balance) {\r\n            amountToSend = address(this).balance;\r\n        }\r\n\r\n        coordinator.deposit{value: amountToSend}(vault.manager);\r\n\r\n        // Emit a warning if the treasury balance is below the low fund warning\r\n        // threshold\r\n        if (address(this).balance < lowFundWarningThreshold) {\r\n            emit LowFundWarning(address(this).balance);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/treasury/vault/interfaces/ILegacyLotteryVaultHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title ILegacyLotteryVaultHandler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the legacy lottery vault handler.\r\n */\r\ninterface ILegacyLotteryVaultHandler {\r\n    /**\r\n     * @notice Pays the winner of the lottery.\r\n     *\r\n     * @param amount    The amount to pay the winner.\r\n     * @param winner    The address of the winner.\r\n     */\r\n    function payWinner(uint256 amount, address winner) external;\r\n}\r\n"
    },
    "contracts/treasury/vault/interfaces/IVaultCoordinator.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {IVaultRequestHandler} from \"./IVaultRequestHandler.sol\";\r\n\r\n/**\r\n * @title Vault Coordinator Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Vault Coordinator contract.\r\n */\r\ninterface IVaultCoordinator {\r\n    /**\r\n     * @notice Outlines the structure of a registered vault manager.\r\n     *\r\n     * @param isRegistered Whether or not the manager is registered.\r\n     * @param vaultIndex The index of the vault.\r\n     */\r\n    struct VaultManager {\r\n        bool isRegistered;\r\n        uint256 vaultIndex;\r\n    }\r\n\r\n    /**\r\n     * @notice Outlines the structure of a registered vault.\r\n     *\r\n     * @param manager The address of the manager.\r\n     * @param balance The balance of the vault.\r\n     * @param lowFundThreshold The low fund threshold of the vault.\r\n     * @param receiveFundOffset The receive fund offset of the vault.\r\n     * @param requestHandler The request handler of the vault.\r\n     */\r\n    struct Vault {\r\n        address manager;\r\n        uint256 balance;\r\n        uint256 lowFundThreshold;\r\n        uint256 receiveFundOffset;\r\n        IVaultRequestHandler requestHandler;\r\n    }\r\n\r\n    /**\r\n     * @notice Emitted when a vault manager is registered.\r\n     *\r\n     * @param manager The address of the manager.\r\n     * @param vaultIndex The index of the vault.\r\n     */\r\n    event VaultRegistered(address indexed manager, uint256 indexed vaultIndex);\r\n\r\n    /**\r\n     * @notice Emitted when a vault is funded.\r\n     *\r\n     * @param vaultIndex The index of the vault.\r\n     * @param amount The amount of funds the vault has.\r\n     */\r\n    event VaultFunded(uint256 indexed vaultIndex, uint256 indexed amount);\r\n\r\n    /**\r\n     * @notice Emitted when a vault balance is updated.\r\n     *\r\n     * @param vaultIndex The index of the vault.\r\n     * @param recipient The recipient of the funds.\r\n     * @param amount The amount of funds the vault has.\r\n     */\r\n    event VaultTransfer(\r\n        uint256 indexed vaultIndex,\r\n        address indexed recipient,\r\n        uint256 indexed amount\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a vault is updated.\r\n     *\r\n     * @param vaultIndex The index of the vault.\r\n     * @param lowFundThreshold The low fund threshold of the vault.\r\n     * @param receiveFundOffset The receive fund offset of the vault.\r\n     * @param requestHandler The request handler of the vault.\r\n     */\r\n    event VaultUpdated(\r\n        uint256 indexed vaultIndex,\r\n        uint256 lowFundThreshold,\r\n        uint256 receiveFundOffset,\r\n        address requestHandler\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a vault manager is unregistered.\r\n     *\r\n     * @param manager The address of the manager.\r\n     * @param vaultIndex The index of the vault.\r\n     */\r\n    event VaultUnregistered(\r\n        address indexed manager,\r\n        uint256 indexed vaultIndex\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a vault becomes low on funds.\r\n     *\r\n     * @param vaultIndex The index of the vault.\r\n     * @param amount The amount of funds the vault has.\r\n     */\r\n    event VaultLowOnFunds(uint256 indexed vaultIndex, uint256 amount);\r\n\r\n    /**\r\n     * @notice Transfers an amount of tokens to a recipient\r\n     *\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount to transfer\r\n     * @param _data The data to send with the transfer that is used\r\n     *              to validate the transfer\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes calldata _data\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Allows external sources to deposit funds into the\r\n     *         vault.\r\n     *\r\n     * @param vault The vault to deposit funds into.\r\n     */\r\n    function deposit(address vault) external payable;\r\n\r\n    /**\r\n     * @notice Retrieves a vault at an index.\r\n     *\r\n     * @param _vaultIndex The index of the vault to retrieve.\r\n     *\r\n     * @return The vault at the index.\r\n     */\r\n    function getVault(uint256 _vaultIndex) external view returns (Vault memory);\r\n\r\n    /**\r\n     * @notice Retrieves the total number of vaults.\r\n     *\r\n     * @return The total number of vaults.\r\n     */\r\n    function getTotalVaults() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/treasury/vault/interfaces/IVaultFundManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {IVaultCoordinator} from \"./IVaultCoordinator.sol\";\r\n\r\n/**\r\n * @title Vault Fund Manager Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Vault Fund Manager contract.\r\n */\r\ninterface IVaultFundManager {\r\n    /**\r\n     * @notice Emitted when a vault that is low on funds is found.\r\n     *\r\n     * @param vaultIndex The index of the vault.\r\n     */\r\n    event LowFundVaultFound(uint256 indexed vaultIndex);\r\n\r\n    /**\r\n     * @notice Retrieves a vault that has low funds.\r\n     *\r\n     * @return The vault that has low funds.\r\n     */\r\n    function findNextLowFundVault()\r\n        external\r\n        returns (IVaultCoordinator.Vault memory);\r\n\r\n    /**\r\n     * @notice Retrieves the coordinator contract.\r\n     *\r\n     * @return The coordinator contract.\r\n     */\r\n    function getCoordinator() external view returns (IVaultCoordinator);\r\n}\r\n"
    },
    "contracts/treasury/vault/interfaces/IVaultRequestHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title Vault Request Handler Interface\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Interface for the Vault Request Handler contracts.\r\n */\r\ninterface IVaultRequestHandler {\r\n    /**\r\n     * @dev Revert with an error when an incoming request\r\n     *      is invalid.\r\n     *\r\n     * @param message The error message to revert with\r\n     */\r\n    error InvalidRequest(string message);\r\n\r\n    /**\r\n     * @notice Validates a request to the vault\r\n     *\r\n     * @param _data The data to validate\r\n     */\r\n    function validateRequest(bytes calldata _data) external;\r\n}\r\n"
    },
    "contracts/treasury/vault/LegacyLotteryVaultHandler.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport {IPLAYA3ULLLottery} from \"../../lottery/interfaces/ILottery.sol\";\r\nimport {IVaultCoordinator} from \"./interfaces/IVaultCoordinator.sol\";\r\nimport {ILegacyLotteryVaultHandler} from \"./interfaces/ILegacyLotteryVaultHandler.sol\";\r\n\r\n/**\r\n * @title LegacyLotteryVaultHandler\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Handles interactions between the lottery vault that is\r\n *         now considered legacy, and the updated vault system.\r\n */\r\ncontract LegacyLotteryVaultHandler is ILegacyLotteryVaultHandler {\r\n    /// @notice The vault coordinator contract\r\n    IVaultCoordinator public coordinator;\r\n\r\n    /// @notice The lottery contract\r\n    IPLAYA3ULLLottery public lottery;\r\n\r\n    modifier onlyLottery() {\r\n        require(\r\n            msg.sender == address(lottery),\r\n            \"LegacyVaultHandler: Only lottery can call this function\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(IVaultCoordinator _coordinator, IPLAYA3ULLLottery _lottery) {\r\n        coordinator = _coordinator;\r\n        lottery = _lottery;\r\n    }\r\n\r\n    /**\r\n     * @notice Pays the winner of the lottery.\r\n     *\r\n     * @param amount    The amount to pay the winner.\r\n     * @param winner    The address of the winner.\r\n     */\r\n    function payWinner(\r\n        uint256 amount,\r\n        address winner\r\n    ) external override onlyLottery {\r\n        coordinator.transfer(winner, amount, \"\");\r\n    }\r\n}\r\n"
    },
    "contracts/treasury/vault/VaultCoordinator.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IVaultCoordinator} from \"./interfaces/IVaultCoordinator.sol\";\r\nimport {IVaultRequestHandler} from \"./interfaces/IVaultRequestHandler.sol\";\r\nimport {ITreasuryFundController} from \"../interfaces/ITreasuryFundController.sol\";\r\n\r\n/**\r\n * @title VaultCoordinator\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Coordinates the vaults and authorises requestors to\r\n *         make requests to the vaults by passing the request\r\n *         data to an associated request handler which\r\n *         validates the request.\r\n */\r\ncontract VaultCoordinator is Ownable, IVaultCoordinator {\r\n    /// @notice The treasury contract.\r\n    ITreasuryFundController public treasuryFundController;\r\n\r\n    /// @notice The total number of registered vaults.\r\n    uint256 public totalVaults;\r\n\r\n    /// @notice The currently registered vaults.\r\n    mapping(uint256 => Vault) public vaults;\r\n\r\n    /// @notice The authorised callers of the vaults.\r\n    mapping(address => VaultManager) public vaultManagers;\r\n\r\n    modifier onlyManager() {\r\n        require(\r\n            vaultManagers[msg.sender].isRegistered == true,\r\n            \"VaultCoordinator: Not authorised to call\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(ITreasuryFundController _treasuryFundController) {\r\n        treasuryFundController = _treasuryFundController;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves a vault at an index.\r\n     *\r\n     * @param _vaultIndex The index of the vault to retrieve.\r\n     *\r\n     * @return The vault at the index.\r\n     */\r\n    function getVault(\r\n        uint256 _vaultIndex\r\n    ) external view override returns (Vault memory) {\r\n        require(\r\n            _vaultIndex < totalVaults,\r\n            \"VaultCoordinator: Vault does not exist\"\r\n        );\r\n\r\n        return vaults[_vaultIndex];\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves a list of registered vaults.\r\n     *\r\n     * @return The list of registered vaults.\r\n     */\r\n    function getTotalVaults() external view override returns (uint256) {\r\n        return totalVaults;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers funds from the vault to the recipient\r\n     *\r\n     * @param _to The address to transfer to\r\n     * @param _amount The amount to transfer\r\n     * @param _data The data to send with the transfer\r\n     */\r\n    function transfer(\r\n        address _to,\r\n        uint256 _amount,\r\n        bytes calldata _data\r\n    ) external override onlyManager {\r\n        require(\r\n            _to != address(0),\r\n            \"VaultCoordinator: Cannot transfer to zero address\"\r\n        );\r\n\r\n        require(_amount > 0, \"VaultCoordinator: Cannot transfer zero amount\");\r\n\r\n        require(\r\n            _amount <= vaults[vaultManagers[msg.sender].vaultIndex].balance,\r\n            \"VaultCoordinator: Vault does not have sufficient funds\"\r\n        );\r\n\r\n        uint256 vaultIndex = vaultManagers[msg.sender].vaultIndex;\r\n\r\n        if (\r\n            vaults[vaultIndex].requestHandler !=\r\n            IVaultRequestHandler(address(0))\r\n        ) {\r\n            // Ensure that the request is valid by passing the data to the request handler\r\n            bytes memory data = abi.encode(msg.sender, _to, _amount, _data);\r\n            vaults[vaultIndex].requestHandler.validateRequest(data);\r\n        }\r\n\r\n        // Send the funds to the recipient\r\n        payable(_to).transfer(_amount);\r\n\r\n        vaults[vaultIndex].balance -= _amount;\r\n\r\n        emit VaultTransfer(vaultIndex, _to, _amount);\r\n\r\n        // If the vault is low on funds, emit an event\r\n        if (vaults[vaultIndex].balance < vaults[vaultIndex].lowFundThreshold) {\r\n            emit VaultLowOnFunds(vaultIndex, vaults[vaultIndex].balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deposits funds into a vault\r\n     *\r\n     * @param vault The vault to deposit funds into.\r\n     */\r\n    function deposit(address vault) external payable override {\r\n        require(\r\n            vaultManagers[vault].isRegistered == true,\r\n            \"VaultCoordinator: Cannot deposit funds into a vault that is not registered\"\r\n        );\r\n\r\n        uint256 vaultIndex = vaultManagers[vault].vaultIndex;\r\n\r\n        vaults[vaultIndex].balance += msg.value;\r\n\r\n        emit VaultFunded(vaultIndex, msg.value);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to set the treasury fund controller.\r\n     *\r\n     * @param _treasuryFundController The new treasury fund controller.\r\n     */\r\n    function setTreasuryFundController(\r\n        ITreasuryFundController _treasuryFundController\r\n    ) external onlyOwner {\r\n        require(\r\n            address(_treasuryFundController) != address(0),\r\n            \"VaultCoordinator: Cannot set treasury fund controller to zero address\"\r\n        );\r\n\r\n        treasuryFundController = _treasuryFundController;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds from a vault.\r\n     *\r\n     * @param _vaultIndex The index of the vault to withdraw from.\r\n     * @param _amount The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 _vaultIndex, uint256 _amount) external onlyOwner {\r\n        require(\r\n            _vaultIndex < totalVaults,\r\n            \"VaultCoordinator: Vault index out of bounds\"\r\n        );\r\n\r\n        require(\r\n            vaults[_vaultIndex].balance >= _amount,\r\n            \"VaultCoordinator: Insufficient funds\"\r\n        );\r\n\r\n        treasuryFundController.safeDeposit{value: _amount}();\r\n\r\n        vaults[_vaultIndex].balance -= _amount;\r\n\r\n        emit VaultTransfer(\r\n            _vaultIndex,\r\n            address(treasuryFundController),\r\n            _amount\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Adds a new vault to the list of vaults.\r\n     *\r\n     * @param _manager The authorised manager of the vault.\r\n     * @param _lowFundThreshold The low fund threshold of the vault.\r\n     * @param _receiveFundOffset The receive fund offset of the vault.\r\n     */\r\n    function addVault(\r\n        address _manager,\r\n        uint256 _lowFundThreshold,\r\n        uint256 _receiveFundOffset\r\n    ) external onlyOwner {\r\n        require(\r\n            _manager != address(0),\r\n            \"VaultCoordinator: Manager address cannot be 0\"\r\n        );\r\n\r\n        require(\r\n            vaultManagers[_manager].isRegistered == false,\r\n            \"VaultCoordinator: Manager already registered\"\r\n        );\r\n\r\n        vaultManagers[_manager] = VaultManager({\r\n            isRegistered: true,\r\n            vaultIndex: totalVaults\r\n        });\r\n\r\n        vaults[totalVaults] = Vault({\r\n            manager: _manager,\r\n            balance: 0,\r\n            lowFundThreshold: _lowFundThreshold,\r\n            receiveFundOffset: _receiveFundOffset,\r\n            requestHandler: IVaultRequestHandler(address(0))\r\n        });\r\n\r\n        totalVaults++;\r\n\r\n        emit VaultRegistered(_manager, totalVaults - 1);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the low fund threshold of a vault.\r\n     *\r\n     * @param _vaultIndex The index of the vault to update.\r\n     * @param _lowFundThreshold The new low fund threshold.\r\n     */\r\n    function updateLowFundThreshold(\r\n        uint256 _vaultIndex,\r\n        uint256 _lowFundThreshold\r\n    ) external onlyOwner {\r\n        require(\r\n            _vaultIndex < totalVaults,\r\n            \"VaultFundManager: Vault index out of bounds\"\r\n        );\r\n\r\n        vaults[_vaultIndex].lowFundThreshold = _lowFundThreshold;\r\n\r\n        emit VaultUpdated(\r\n            _vaultIndex,\r\n            _lowFundThreshold,\r\n            vaults[_vaultIndex].receiveFundOffset,\r\n            address(vaults[_vaultIndex].requestHandler)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the receive fund offset of a vault.\r\n     *\r\n     * @param _vaultIndex The index of the vault to update.\r\n     * @param _receiveFundOffset The new receive fund offset.\r\n     */\r\n    function updateReceiveFundOffset(\r\n        uint256 _vaultIndex,\r\n        uint256 _receiveFundOffset\r\n    ) external onlyOwner {\r\n        require(\r\n            _vaultIndex < totalVaults,\r\n            \"VaultFundManager: Vault index out of bounds\"\r\n        );\r\n\r\n        vaults[_vaultIndex].receiveFundOffset = _receiveFundOffset;\r\n\r\n        emit VaultUpdated(\r\n            _vaultIndex,\r\n            vaults[_vaultIndex].lowFundThreshold,\r\n            _receiveFundOffset,\r\n            address(vaults[_vaultIndex].requestHandler)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the request handler of a vault.\r\n     *\r\n     * @param _vaultIndex The index of the vault to update.\r\n     * @param _requestHandler The new request handler.\r\n     */\r\n    function updateRequestHandler(\r\n        uint256 _vaultIndex,\r\n        IVaultRequestHandler _requestHandler\r\n    ) external onlyOwner {\r\n        require(\r\n            _vaultIndex < totalVaults,\r\n            \"VaultFundManager: Vault index out of bounds\"\r\n        );\r\n\r\n        vaults[_vaultIndex].requestHandler = _requestHandler;\r\n\r\n        emit VaultUpdated(\r\n            _vaultIndex,\r\n            vaults[_vaultIndex].lowFundThreshold,\r\n            vaults[_vaultIndex].receiveFundOffset,\r\n            address(_requestHandler)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Removes a vault from the list of vaults.\r\n     *\r\n     * @param _vaultIndex The index of the vault to remove.\r\n     */\r\n    function removeVault(uint256 _vaultIndex) external onlyOwner {\r\n        require(\r\n            _vaultIndex < totalVaults,\r\n            \"VaultFundManager: Vault index out of bounds\"\r\n        );\r\n\r\n        require(totalVaults > 0, \"VaultFundManager: No vaults to remove\");\r\n\r\n        // Send the remaining funds to the treasury\r\n        treasuryFundController.deposit{value: vaults[_vaultIndex].balance}();\r\n\r\n        address manager = vaults[_vaultIndex].manager;\r\n\r\n        vaults[_vaultIndex] = vaults[totalVaults - 1];\r\n        vaultManagers[vaults[_vaultIndex].manager].vaultIndex = _vaultIndex;\r\n\r\n        delete vaults[totalVaults - 1];\r\n        delete vaultManagers[manager];\r\n\r\n        totalVaults--;\r\n\r\n        emit VaultUnregistered(manager, _vaultIndex);\r\n    }\r\n}\r\n"
    },
    "contracts/treasury/vault/VaultFundManager.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IVaultFundManager} from \"./interfaces/IVaultFundManager.sol\";\r\nimport {ITreasuryFundController} from \"../interfaces/ITreasuryFundController.sol\";\r\nimport {IVaultCoordinator} from \"./interfaces/IVaultCoordinator.sol\";\r\nimport {IVaultRequestHandler} from \"./interfaces/IVaultRequestHandler.sol\";\r\n\r\n/**\r\n * @title Vault Fund Manager Contract\r\n *\r\n * @author Jourdan (PLAYA3ULL)\r\n *\r\n * @notice Manages the funding of vaults by finding vaults\r\n *         that are low on funds and informing the treasury.\r\n */\r\ncontract VaultFundManager is Ownable, IVaultFundManager {\r\n    /// @notice The treasury contract.\r\n    ITreasuryFundController public treasuryFundController;\r\n\r\n    /// @notice The coordinator contract.\r\n    IVaultCoordinator public vaultCoordinator;\r\n\r\n    /// @notice The maximum search depth when finding the next low fund vault.\r\n    uint256 public maxSearchDepth = 5;\r\n\r\n    /// @notice The index of the last low fund vault.\r\n    uint256 public lastLowFundVaultIndex;\r\n\r\n    modifier onlyController() {\r\n        require(\r\n            msg.sender == address(treasuryFundController) ||\r\n                msg.sender == address(vaultCoordinator) ||\r\n                msg.sender == owner(),\r\n            \"VaultFundManager: Only controllers can call\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n        ITreasuryFundController _treasuryFundController,\r\n        IVaultCoordinator _vaultCoordinator\r\n    ) {\r\n        treasuryFundController = _treasuryFundController;\r\n        vaultCoordinator = _vaultCoordinator;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the coordinator contract.\r\n     *\r\n     * @return The coordinator contract.\r\n     */\r\n    function getCoordinator()\r\n        external\r\n        view\r\n        override\r\n        returns (IVaultCoordinator)\r\n    {\r\n        return vaultCoordinator;\r\n    }\r\n\r\n    /**\r\n     * @notice Searches for a vault that is low on funds.\r\n     *\r\n     * @return The vault that is low on funds, or an empty vault if no low fund\r\n     *         vault was found.\r\n     */\r\n    function findNextLowFundVault()\r\n        external\r\n        override\r\n        onlyController\r\n        returns (IVaultCoordinator.Vault memory)\r\n    {\r\n        uint256 totalVaults = vaultCoordinator.getTotalVaults();\r\n\r\n        if (totalVaults == 0) {\r\n            return\r\n                IVaultCoordinator.Vault(\r\n                    address(0),\r\n                    0,\r\n                    0,\r\n                    0,\r\n                    IVaultRequestHandler(address(0))\r\n                );\r\n        }\r\n\r\n        if (lastLowFundVaultIndex >= totalVaults) {\r\n            lastLowFundVaultIndex = 0;\r\n        }\r\n\r\n        uint256 vaultIndex = lastLowFundVaultIndex;\r\n        uint256 startIndex = vaultIndex;\r\n\r\n        for (uint256 i = 0; i < maxSearchDepth; i++) {\r\n            if (vaultIndex >= totalVaults) {\r\n                vaultIndex = 0;\r\n            }\r\n\r\n            if (i > 0 && vaultIndex == startIndex) {\r\n                break;\r\n            }\r\n\r\n            IVaultCoordinator.Vault memory vault = vaultCoordinator.getVault(\r\n                vaultIndex\r\n            );\r\n\r\n            if (\r\n                !treasuryFundController.isExcludedFromAutoVaultFund(\r\n                    vault.manager\r\n                ) && vault.balance < vault.lowFundThreshold\r\n            ) {\r\n                lastLowFundVaultIndex = vaultIndex;\r\n\r\n                emit LowFundVaultFound(vaultIndex);\r\n\r\n                return vault;\r\n            }\r\n\r\n            vaultIndex++;\r\n        }\r\n\r\n        lastLowFundVaultIndex = vaultIndex;\r\n\r\n        return\r\n            IVaultCoordinator.Vault(\r\n                address(0),\r\n                0,\r\n                0,\r\n                0,\r\n                IVaultRequestHandler(address(0))\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the maximum search depth when finding the next low fund\r\n     *         vault.\r\n     *\r\n     * @param _maxSearchDepth The new maximum search depth.\r\n     */\r\n    function setMaxSearchDepth(uint256 _maxSearchDepth) external onlyOwner {\r\n        maxSearchDepth = _maxSearchDepth;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the treasury fund controller.\r\n     *\r\n     * @param _treasuryFundController The new treasury fund controller.\r\n     */\r\n    function setTreasuryFundController(\r\n        ITreasuryFundController _treasuryFundController\r\n    ) external onlyOwner {\r\n        require(\r\n            address(_treasuryFundController) != address(0),\r\n            \"VaultFundManager: Cannot set treasury fund controller to zero address\"\r\n        );\r\n\r\n        treasuryFundController = _treasuryFundController;\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the vault coordinator.\r\n     *\r\n     * @param _vaultCoordinator The new vault coordinator.\r\n     */\r\n    function setVaultCoordinator(\r\n        IVaultCoordinator _vaultCoordinator\r\n    ) external onlyOwner {\r\n        require(\r\n            address(_vaultCoordinator) != address(0),\r\n            \"VaultFundManager: Cannot set vault coordinator to zero address\"\r\n        );\r\n\r\n        vaultCoordinator = _vaultCoordinator;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}