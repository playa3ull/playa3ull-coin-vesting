{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/misc/CoinVesting.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\r\npragma solidity ^0.8.19;\r\n\r\n// OpenZeppelin dependencies\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL GAMES Vesting Contract \r\n * @author @abdelhamidbakhtam, @jourdanhaines (PLAYAY3ULL), @samthompsonkennedy (PLAYA3ULL)\r\n * @notice This is a fork of https://github.com/abdelhamidbakhta/token-vesting-contracts\r\n *         To support native Ether instead of ERC20 tokens and fit in with the rest of\r\n *         the PLAYA3ULL GAMES contracts deployment process, and testing suite\r\n */\r\n\r\ncontract CoinVesting is Ownable, ReentrancyGuard {\r\n    struct VestingSchedule {\r\n        bool initialized;\r\n        // beneficiary of tokens after they are released\r\n        address beneficiary;\r\n        // cliff period in seconds\r\n        uint256 cliff;\r\n        // start time of the vesting period\r\n        uint256 start;\r\n        // duration of the vesting period in seconds\r\n        uint256 duration;\r\n        // duration of a slice period for the vesting in seconds\r\n        uint256 slicePeriodSeconds;\r\n        // whether or not the vesting is revocable\r\n        bool revocable;\r\n        // total amount of tokens to be released at the end of the vesting\r\n        uint256 amountTotal;\r\n        // amount of tokens released\r\n        uint256 released;\r\n        // whether or not the vesting has been revoked\r\n        bool revoked;\r\n    }\r\n\r\n    bytes32[] private vestingSchedulesIds;\r\n    mapping(bytes32 => VestingSchedule) private vestingSchedules;\r\n    uint256 private vestingSchedulesTotalAmount;\r\n    mapping(address => uint256) private holdersVestingCount;\r\n\r\n    /**\r\n     * @dev Reverts if the vesting schedule does not exist or has been revoked.\r\n     */\r\n    modifier onlyIfVestingScheduleNotRevoked(bytes32 vestingScheduleId) {\r\n        require(vestingSchedules[vestingScheduleId].initialized, \"CoinVesting: vesting schedule not initialized\");\r\n        require(!vestingSchedules[vestingScheduleId].revoked, \"CoinVesting: vesting schedule revoked\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a vesting contract.\r\n     */\r\n    constructor() {}\r\n\r\n    /**\r\n     * @dev This function is called for plain Ether transfers, i.e. for every call with empty calldata.\r\n     */\r\n    receive() external payable {}\r\n\r\n    /**\r\n     * @dev Fallback function is executed if none of the other functions match the function\r\n     * identifier or no data was provided with the function call.\r\n     */\r\n    fallback() external payable {}\r\n\r\n    /**\r\n     * @notice Creates a new vesting schedule for a beneficiary.\r\n     * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n     * @param _start start time of the vesting period\r\n     * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n     * @param _duration duration in seconds of the period in which the tokens will vest\r\n     * @param _slicePeriodSeconds duration of a slice period for the vesting in seconds\r\n     * @param _revocable whether the vesting is revocable or not\r\n     * @param _amount total amount of tokens to be released at the end of the vesting\r\n     */\r\n    function createVestingSchedule(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _slicePeriodSeconds,\r\n        bool _revocable,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        require(\r\n            getWithdrawableAmount() >= _amount,\r\n            \"CoinVesting: cannot create vesting schedule because not sufficient tokens\"\r\n        );\r\n        require(_duration > 0, \"CoinVesting: duration must be > 0\");\r\n        require(_amount > 0, \"CoinVesting: amount must be > 0\");\r\n        require(\r\n            _slicePeriodSeconds >= 1,\r\n            \"CoinVesting: slicePeriodSeconds must be >= 1\"\r\n        );\r\n        require(_duration >= _cliff, \"CoinVesting: duration must be >= cliff\");\r\n        bytes32 vestingScheduleId = computeNextVestingScheduleIdForHolder(\r\n            _beneficiary\r\n        );\r\n        uint256 cliff = _start + _cliff;\r\n        vestingSchedules[vestingScheduleId] = VestingSchedule(\r\n            true,\r\n            _beneficiary,\r\n            cliff,\r\n            _start,\r\n            _duration,\r\n            _slicePeriodSeconds,\r\n            _revocable,\r\n            _amount,\r\n            0,\r\n            false\r\n        );\r\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount + _amount;\r\n        vestingSchedulesIds.push(vestingScheduleId);\r\n        uint256 currentVestingCount = holdersVestingCount[_beneficiary];\r\n        holdersVestingCount[_beneficiary] = currentVestingCount + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Revokes the vesting schedule for given identifier.\r\n     * @param vestingScheduleId the vesting schedule identifier\r\n     */\r\n    function revoke(\r\n        bytes32 vestingScheduleId\r\n    ) external onlyOwner onlyIfVestingScheduleNotRevoked(vestingScheduleId) {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[\r\n            vestingScheduleId\r\n        ];\r\n        require(\r\n            vestingSchedule.revocable,\r\n            \"CoinVesting: vesting is not revocable\"\r\n        );\r\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\r\n        if (vestedAmount > 0) {\r\n            release(vestingScheduleId, vestedAmount);\r\n        }\r\n        uint256 unreleased = vestingSchedule.amountTotal -\r\n            vestingSchedule.released;\r\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - unreleased;\r\n        vestingSchedule.revoked = true;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw the specified amount if possible.\r\n     * @param amount the amount to withdraw\r\n     */\r\n    function withdraw(uint256 amount) external nonReentrant onlyOwner {\r\n        require(\r\n            getWithdrawableAmount() >= amount,\r\n            \"CoinVesting: not enough withdrawable funds\"\r\n        );\r\n        /*\r\n         * @dev Replaced owner() with msg.sender => address of WITHDRAWER_ROLE\r\n         */\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Release vested amount of tokens.\r\n     * @param vestingScheduleId the vesting schedule identifier\r\n     * @param amount the amount to release\r\n     */\r\n    function release(\r\n        bytes32 vestingScheduleId,\r\n        uint256 amount\r\n    ) public nonReentrant onlyIfVestingScheduleNotRevoked(vestingScheduleId) {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[\r\n            vestingScheduleId\r\n        ];\r\n        bool isBeneficiary = msg.sender == vestingSchedule.beneficiary;\r\n\r\n        bool isReleasor = (msg.sender == owner());\r\n        require(\r\n            isBeneficiary || isReleasor,\r\n            \"CoinVesting: only beneficiary and owner can release vested tokens\"\r\n        );\r\n        uint256 vestedAmount = _computeReleasableAmount(vestingSchedule);\r\n        require(\r\n            vestedAmount >= amount,\r\n            \"CoinVesting: cannot release tokens, not enough vested tokens\"\r\n        );\r\n        vestingSchedule.released = vestingSchedule.released + amount;\r\n        address payable beneficiaryPayable = payable(\r\n            vestingSchedule.beneficiary\r\n        );\r\n        vestingSchedulesTotalAmount = vestingSchedulesTotalAmount - amount;\r\n        payable(vestingSchedule.beneficiary).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of vesting schedules associated to a beneficiary.\r\n     * @return the number of vesting schedules\r\n     */\r\n    function getVestingSchedulesCountByBeneficiary(\r\n        address _beneficiary\r\n    ) external view returns (uint256) {\r\n        return holdersVestingCount[_beneficiary];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the vesting schedule id at the given index.\r\n     * @return the vesting id\r\n     */\r\n    function getVestingIdAtIndex(\r\n        uint256 index\r\n    ) external view returns (bytes32) {\r\n        require(\r\n            index < getVestingSchedulesCount(),\r\n            \"CoinVesting: index out of bounds\"\r\n        );\r\n        return vestingSchedulesIds[index];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the vesting schedule information for a given holder and index.\r\n     * @return the vesting schedule structure information\r\n     */\r\n    function getVestingScheduleByAddressAndIndex(\r\n        address holder,\r\n        uint256 index\r\n    ) external view returns (VestingSchedule memory) {\r\n        return\r\n            getVestingSchedule(\r\n                computeVestingScheduleIdForAddressAndIndex(holder, index)\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the total amount of vesting schedules.\r\n     * @return the total amount of vesting schedules\r\n     */\r\n    function getVestingSchedulesTotalAmount() external view returns (uint256) {\r\n        return vestingSchedulesTotalAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of vesting schedules managed by this contract.\r\n     * @return the number of vesting schedules\r\n     */\r\n    function getVestingSchedulesCount() public view returns (uint256) {\r\n        return vestingSchedulesIds.length;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes the vested amount of tokens for the given vesting schedule identifier.\r\n     * @return the vested amount\r\n     */\r\n    function computeReleasableAmount(\r\n        bytes32 vestingScheduleId\r\n    )\r\n        external\r\n        view\r\n        onlyIfVestingScheduleNotRevoked(vestingScheduleId)\r\n        returns (uint256)\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[\r\n            vestingScheduleId\r\n        ];\r\n        return _computeReleasableAmount(vestingSchedule);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the vesting schedule information for a given identifier.\r\n     * @return the vesting schedule structure information\r\n     */\r\n    function getVestingSchedule(\r\n        bytes32 vestingScheduleId\r\n    ) public view returns (VestingSchedule memory) {\r\n        return vestingSchedules[vestingScheduleId];\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens that can be withdrawn by the owner.\r\n     * @return the amount of tokens\r\n     */\r\n    function getWithdrawableAmount() public view returns (uint256) {\r\n        return address(this).balance - vestingSchedulesTotalAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the next vesting schedule identifier for a given holder address.\r\n     */\r\n    function computeNextVestingScheduleIdForHolder(\r\n        address holder\r\n    ) public view returns (bytes32) {\r\n        return\r\n            computeVestingScheduleIdForAddressAndIndex(\r\n                holder,\r\n                holdersVestingCount[holder]\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the last vesting schedule for a given holder address.\r\n     */\r\n    function getLastVestingScheduleForHolder(\r\n        address holder\r\n    ) external view returns (VestingSchedule memory) {\r\n        return\r\n            vestingSchedules[\r\n                computeVestingScheduleIdForAddressAndIndex(\r\n                    holder,\r\n                    holdersVestingCount[holder] - 1\r\n                )\r\n            ];\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the vesting schedule identifier for an address and an index.\r\n     */\r\n    function computeVestingScheduleIdForAddressAndIndex(\r\n        address holder,\r\n        uint256 index\r\n    ) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(holder, index));\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the releasable amount of tokens for a vesting schedule.\r\n     * @return the amount of releasable tokens\r\n     */\r\n    function _computeReleasableAmount(\r\n        VestingSchedule memory vestingSchedule\r\n    ) internal view returns (uint256) {\r\n        // Retrieve the current time.\r\n        uint256 currentTime = getCurrentTime();\r\n        // If the current time is before the cliff, no tokens are releasable.\r\n        if ((currentTime < vestingSchedule.cliff) || vestingSchedule.revoked) {\r\n            return 0;\r\n        }\r\n        // If the current time is after the vesting period, all tokens are releasable,\r\n        // minus the amount already released.\r\n        else if (\r\n            currentTime >= vestingSchedule.start + vestingSchedule.duration\r\n        ) {\r\n            return vestingSchedule.amountTotal - vestingSchedule.released;\r\n        }\r\n        // Otherwise, some tokens are releasable.\r\n        else {\r\n            // Compute the number of full vesting periods that have elapsed.\r\n            uint256 timeFromStart = currentTime - vestingSchedule.start;\r\n            uint256 secondsPerSlice = vestingSchedule.slicePeriodSeconds;\r\n            uint256 vestedSlicePeriods = timeFromStart / secondsPerSlice;\r\n            uint256 vestedSeconds = vestedSlicePeriods * secondsPerSlice;\r\n            // Compute the amount of tokens that are vested.\r\n            uint256 vestedAmount = (vestingSchedule.amountTotal *\r\n                vestedSeconds) / vestingSchedule.duration;\r\n            // Subtract the amount already released and return.\r\n            return vestedAmount - vestingSchedule.released;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current time.\r\n     * @return the current timestamp in seconds.\r\n     */\r\n    function getCurrentTime() internal view virtual returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}