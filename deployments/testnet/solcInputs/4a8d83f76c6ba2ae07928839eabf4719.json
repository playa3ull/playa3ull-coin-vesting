{
  "language": "Solidity",
  "sources": {
    "contracts/nft/bull/BULLNFTMinter.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./lib/MathUtils.sol\";\r\nimport \"../../oracle/price/interfaces/IPriceOracle.sol\";\r\n\r\nimport {IPLAYA3ULLNFT} from \"./interfaces/I3ULLNFT.sol\";\r\nimport {IPLAYA3ULLNFTMinterEventsAndErrors} from \"./interfaces/I3ULLNFTMinterEventsAndErrors.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games 3ULL NFT Minter Contract\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This contract contains the core minting functionality for\r\n *         ordinary users minting the 3ULL NFT tokens.\r\n *         Additionally, this contract handles the pricing data and\r\n *         model for said 3ULL NFTs.\r\n */\r\ncontract PLAYA3ULLNFTMinter is Ownable, IPLAYA3ULLNFTMinterEventsAndErrors {\r\n    /// @notice Whether users can mint from this contract.\r\n    bool public mintActive;\r\n\r\n    /// @notice The actual PLAYA3ULL NFT that is to be purchased.\r\n    IPLAYA3ULLNFT public nft;\r\n\r\n    /// @notice The interface for the Price Oracle to retrieve\r\n    ///         pricing data from.\r\n    IPriceOracle public oracle;\r\n\r\n    /// @dev The lowest price a token can be purchased for.\r\n    uint256 private price;\r\n\r\n    /// @dev The scaling factor applied to an attributes rarity when\r\n    ///      determining the price for that attribute.\r\n    uint256 private rarityScaleFactor;\r\n\r\n    constructor(address _nft, address _oracleAddress, uint256 _price) {\r\n        nft = IPLAYA3ULLNFT(_nft);\r\n        oracle = IPriceOracle(_oracleAddress);\r\n\r\n        price = _price;\r\n\r\n        mintActive = false;\r\n        rarityScaleFactor = 1025000; // 1.02500\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the base price for a category. For example,\r\n     *         if there are 10 categories, then the value returned\r\n     *         will be the `price` / 10.\r\n     *\r\n     * @return The base price for each category.\r\n     */\r\n    function getBasePrice() public view returns (uint256) {\r\n        uint256 traits = nft.getTraitLength();\r\n\r\n        return price / traits;\r\n    }\r\n\r\n    /**\r\n     * @notice Computes and returns the price for a given attribute\r\n     *         of a given trait.\r\n     *\r\n     * @param _traitId  The ID of the trait that the attribute\r\n     *                  belongs to.\r\n     * @param _attrId   The ID of the attribute to compute the price.\r\n     *\r\n     * @return The computed price of the attribute.\r\n     */\r\n    function getAttributePrice(\r\n        uint256 _traitId,\r\n        uint256 _attrId\r\n    ) public view returns (uint256) {\r\n        IPLAYA3ULLNFT.Trait memory trait = nft.getTrait(_traitId);\r\n\r\n        // The attribute is \"None\", therefore no price\r\n        if (!trait.required && _attrId == 0) {\r\n            return 0;\r\n        }\r\n\r\n        IPLAYA3ULLNFT.Attribute memory attribute = nft.getAttribute(\r\n            _traitId,\r\n            _attrId\r\n        );\r\n\r\n        uint256 maxSupply = nft.getMaxSupply();\r\n        uint256 basePrice = getBasePrice();\r\n        uint256 expectedTotal = ((maxSupply * 1e18) * attribute.rarity) / 1e18;\r\n        uint256 expectedRarityFactor = (expectedTotal * rarityScaleFactor) /\r\n            1e18;\r\n        uint256 minOneSell = uint256(MathUtils.max(attribute.numSold, 1));\r\n        uint256 normalised = MathUtils.canSub(\r\n            1e18,\r\n            ((minOneSell * 1e24) / expectedRarityFactor)\r\n        )\r\n            ? 1e18 - ((minOneSell * 1e24) / expectedRarityFactor)\r\n            : 100000000000000; // 100000000000000 = 0.0001\r\n        uint256 logOfNormal = MathUtils.abs(MathUtils.log2(int256(normalised)));\r\n\r\n        return ((basePrice *\r\n            (1e18 + logOfNormal) *\r\n            (1e18 +\r\n                ((((minOneSell * 1e36) / expectedTotal) *\r\n                    (1e18 + (1e18 - normalised))) / 1e18))) / (1e36));\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the current price of 3ULL from the Price\r\n     *         Oracle.\r\n     *\r\n     * @param _price    The USD price to get in 3ULL.\r\n     *\r\n     * @return The input price in 3ULL.\r\n     */\r\n    function getBullPrice(uint256 _price) public view returns (uint256) {\r\n        return oracle.getPriceIn(\"USDC\", \"3ULL\", _price);\r\n    }\r\n\r\n    /**\r\n     * @notice Attempts to mint a token for the given address.\r\n     *\r\n     * @param to        The receiving address of the token.\r\n     * @param traitIds  An array of indices of attributes, the\r\n     *                  length of which must be equal to the\r\n     *                  number of traits.\r\n     */\r\n    function mint(address to, uint256[] memory traitIds) external payable {\r\n        _assertMintActive();\r\n\r\n        // The total price of this NFT based on each attribute\r\n        uint256 nftPrice = 0;\r\n\r\n        // Check if the provided traits and attributes list is within the bounds of the contracts traits and attributes\r\n        for (uint8 i = 0; i < traitIds.length; ) {\r\n            IPLAYA3ULLNFT.Trait memory trait = nft.getTrait(i);\r\n            if (traitIds[i] >= trait.maxCount || traitIds[i] < 0) {\r\n                revert TraitsOutOfBounds(i, 0, trait.maxCount);\r\n            }\r\n\r\n            unchecked {\r\n                nftPrice += getAttributePrice(i, traitIds[i]);\r\n                i++;\r\n            }\r\n        }\r\n\r\n        uint256 expectedPrice = nftPrice == 0 ? 0 : getBullPrice(nftPrice);\r\n        if (msg.value != expectedPrice) {\r\n            revert InsufficientValueProvided(expectedPrice);\r\n        }\r\n\r\n        nft.mint(to, traitIds);\r\n    }\r\n\r\n    /**\r\n     * @notice Toggles whether minting is active or inactive.\r\n     */\r\n    function toggleActive() external onlyOwner {\r\n        mintActive = !mintActive;\r\n        emit ToggledMinting(mintActive);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the base expected price for when minting tokens.\r\n     *\r\n     * @param _price    The new price that is being set.\r\n     */\r\n    function setPrice(uint256 _price) external onlyOwner {\r\n        price = _price;\r\n        emit PriceUpdated(price);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the owner to withdraw deposited funds.\r\n     *\r\n     * @param amount    The amount of funds to withdraw.\r\n     */\r\n    function withdraw(uint256 amount) external onlyOwner {\r\n        _assertEnoughFunds(amount);\r\n        payable(msg.sender).transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the owner attempts to withdraw\r\n     *      more funds than the contract balance contains.\r\n     *\r\n     * @param requestedAmount   The amount that is being withdrawn from\r\n     *                          the contract.\r\n     */\r\n    function _assertEnoughFunds(uint256 requestedAmount) internal view {\r\n        if (requestedAmount > address(this).balance) {\r\n            revert NotEnoughFunds(address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if the a mint attempt occurs but\r\n     *      minting is currently inactive.\r\n     */\r\n    function _assertMintActive() internal view {\r\n        if (!mintActive) {\r\n            revert MintInactive();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/nft/bull/lib/MathUtils.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title PLAYA3ULL Games Math Utility Library\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice This library contains utility functions for calculating\r\n *         various mathematical values that Solidity does not readily\r\n *         provide.\r\n */\r\nlibrary MathUtils {\r\n    int256 internal constant SCALE = 1e18;\r\n    \r\n    ///\r\n    /// @dev Hashes given string using keccak256\r\n    ///\r\n    function _hash(string memory _string) internal pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_string));\r\n    }\r\n    \r\n    ///\r\n    /// @dev Converts bytes16 to bytes32\r\n    ///\r\n    function _bytes16ToBytes32(bytes16 data) internal pure returns (bytes32 result) {\r\n        result = bytes32 (data) & 0xFFFFFFFFFFFFFFFF000000000000000000000000000000000000000000000000 |\r\n            (bytes32 (data) & 0x0000000000000000FFFFFFFFFFFFFFFF00000000000000000000000000000000) >> 64;\r\n        result = result & 0xFFFFFFFF000000000000000000000000FFFFFFFF000000000000000000000000 |\r\n            (result & 0x00000000FFFFFFFF000000000000000000000000FFFFFFFF0000000000000000) >> 32;\r\n        result = result & 0xFFFF000000000000FFFF000000000000FFFF000000000000FFFF000000000000 |\r\n            (result & 0x0000FFFF000000000000FFFF000000000000FFFF000000000000FFFF00000000) >> 16;\r\n        result = result & 0xFF000000FF000000FF000000FF000000FF000000FF000000FF000000FF000000 |\r\n            (result & 0x00FF000000FF000000FF000000FF000000FF000000FF000000FF000000FF0000) >> 8;\r\n        result = (result & 0xF000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000) >> 4 |\r\n            (result & 0x0F000F000F000F000F000F000F000F000F000F000F000F000F000F000F000F00) >> 8;\r\n        result = bytes32 (0x3030303030303030303030303030303030303030303030303030303030303030 +\r\n            uint256 (result) +\r\n            (uint256 (result) + 0x0606060606060606060606060606060606060606060606060606060606060606 >> 4 &\r\n            0x0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F0F) * 39);\r\n    }\r\n    \r\n    ///\r\n    /// @dev Converts bytes32 to a string\r\n    ///\r\n    function _bytes32ToString(bytes32 data) internal pure returns (string memory) {\r\n        return string(abi.encodePacked(_bytes16ToBytes32(bytes16(data)), _bytes16ToBytes32(bytes16(data << 128))));\r\n    }\r\n    \r\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\r\n        if (x >= 2**128) {\r\n            x >>= 128;\r\n            msb += 128;\r\n        }\r\n        if (x >= 2**64) {\r\n            x >>= 64;\r\n            msb += 64;\r\n        }\r\n        if (x >= 2**32) {\r\n            x >>= 32;\r\n            msb += 32;\r\n        }\r\n        if (x >= 2**16) {\r\n            x >>= 16;\r\n            msb += 16;\r\n        }\r\n        if (x >= 2**8) {\r\n            x >>= 8;\r\n            msb += 8;\r\n        }\r\n        if (x >= 2**4) {\r\n            x >>= 4;\r\n            msb += 4;\r\n        }\r\n        if (x >= 2**2) {\r\n            x >>= 2;\r\n            msb += 2;\r\n        }\r\n        if (x >= 2**1) {\r\n            // No need to shift x any more.\r\n            msb += 1;\r\n        }\r\n    }\r\n    \r\n    function log2(int256 x) internal pure returns (int256 result) {\r\n        require(x > 0, \"PB MU: Input must be greater than 0!\");\r\n        unchecked {\r\n            // This works because log2(x) = -log2(1/x).\r\n            int256 sign;\r\n            if (x >= SCALE) {\r\n                sign = 1;\r\n            } else {\r\n                sign = -1;\r\n                // Do the fixed-point inversion inline to save gas. The numerator is SCALE * SCALE.\r\n                assembly {\r\n                    x := div(1000000000000000000000000000000000000, x)\r\n                }\r\n            }\r\n\r\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\r\n            uint256 n = mostSignificantBit(uint256(x / SCALE));\r\n\r\n            // The integer part of the logarithm as a signed 59.18-decimal fixed-point number. The operation can't overflow\r\n            // because n is maximum 255, SCALE is 1e18 and sign is either 1 or -1.\r\n            result = int256(n) * SCALE;\r\n\r\n            // This is y = x * 2^(-n).\r\n            int256 y = x >> n;\r\n\r\n            // If y = 1, the fractional part is zero.\r\n            if (y == SCALE) {\r\n                return result * sign;\r\n            }\r\n\r\n            // Calculate the fractional part via the iterative approximation.\r\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\r\n            for (int256 delta = int256(SCALE / 2); delta > 0; delta >>= 1) {\r\n                y = (y * y) / SCALE;\r\n\r\n                // Is y^2 > 2 and so in the range [2,4)?\r\n                if (y >= 2 * SCALE) {\r\n                    // Add the 2^(-m) factor to the logarithm.\r\n                    result += delta;\r\n\r\n                    // Corresponds to z/2 on Wikipedia.\r\n                    y >>= 1;\r\n                }\r\n            }\r\n            result *= sign;\r\n        }\r\n    }\r\n\r\n\r\n    function abs(int x) internal pure returns (uint256) {\r\n        return x >= 0 ? uint256(x) : uint256(-x);\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a <= b ? a : b;\r\n    }\r\n\r\n    function canSub(uint256 a, uint256 b) internal pure returns (bool) {\r\n        if (b > a) return (false);\r\n        return (true);\r\n    }\r\n}"
    },
    "contracts/oracle/price/interfaces/IPriceOracle.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPriceOracle\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPriceOracle contains all external functions, structs\r\n *         and events and errors for the Price Oracle.\r\n */\r\ninterface IPriceOracle {\r\n    /**\r\n     * @dev Emit an event whenever a token is set or updated.\r\n     *\r\n     * @param symbol The token symbol.\r\n     */\r\n    event TokenUpdated(string indexed symbol);\r\n\r\n    /**\r\n     * @dev Emit an event whenever a token pair's price is set\r\n     *      or updated.\r\n     *\r\n     * @param symbolA The symbol of the `from` token.\r\n     * @param symbolB The symbol of the `to`, or `in` token.\r\n     * @param price   The new price of the tokenA in tokenB.\r\n     */\r\n    event PairPriceUpdated(\r\n        string indexed symbolA,\r\n        string indexed symbolB,\r\n        uint256 price\r\n    );\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to set a token pair\r\n     *      price that is zero or less.\r\n     */\r\n    error InvalidPrice();\r\n\r\n    function getPriceIn(\r\n        string memory tokenFrom,\r\n        string memory tokenIn,\r\n        uint256 price\r\n    ) external view returns (uint256);\r\n\r\n    function getPairPrice(\r\n        string memory symbolA,\r\n        string memory symbolB\r\n    ) external view returns (uint256, uint256);\r\n}\r\n"
    },
    "contracts/nft/bull/interfaces/I3ULLNFT.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLNFT\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPLAYA3ULLNFT contains all external functions and\r\n *         structs for the 3ULL NFT.\r\n */\r\ninterface IPLAYA3ULLNFT {\r\n\r\n    /**\r\n     * @dev An NFT contains two components: a string that\r\n     *      represents that NFTs DNA, preventing any other\r\n     *      token from using the same DNA, and an array of\r\n     *      traits that the NFT is constructed from.\r\n     */\r\n    struct NFT {\r\n        string dna;\r\n        uint256[] traits;\r\n    }\r\n\r\n    /**\r\n     * @dev A trait represents the different parts of the\r\n     *      token. Each trait contains three components: \r\n     *      a name, whether it is required, and the maximum\r\n     *      number of attributes that this trait may hold.\r\n     */\r\n    struct Trait {\r\n        string name;\r\n        bool required;\r\n        uint256 maxCount;\r\n    }\r\n\r\n    /**\r\n     * @dev An attribute belongs to a trait, and represents\r\n     *      a different and unique variation of the parent\r\n     *      trait. Each attribute contains three components:\r\n     *      a name, a rarity value, and the number of this\r\n     *      attribute that has sold.\r\n     */\r\n    struct Attribute {\r\n        string name;\r\n        uint256 rarity;\r\n        uint256 numSold;\r\n    }\r\n\r\n    function getMaxSupply() external view returns (uint256);\r\n\r\n    function getTotalSupply() external view returns (uint256);\r\n\r\n    function getTraitLength() external view returns (uint256);\r\n    \r\n    function getTrait(uint256 traitId) external view returns (Trait memory);\r\n\r\n    function getAttributeLength(uint256 traitId) external view returns (uint256);\r\n\r\n    function getAttribute(uint256 traitId, uint256 attrId) external view returns (Attribute memory);\r\n\r\n    function isDNAUnique(uint256[] memory traitIds) external view returns (bool isUnique, string memory dna);\r\n\r\n    function mint(address to, uint256[] memory traitIds) external;\r\n}"
    },
    "contracts/nft/bull/interfaces/I3ULLNFTMinterEventsAndErrors.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\n/**\r\n * @title IPLAYA3ULLNFTMinterEventsAndErrors\r\n * @author Jourdan (PLAYA3ULL)\r\n * @notice IPLAYA3ULLNFTMinterEventsAndErrors contains all external events,\r\n *         and errors for the 3ULL NFT minter.\r\n */\r\ninterface IPLAYA3ULLNFTMinterEventsAndErrors {\r\n    /**\r\n     * @dev Emit an event whenever the owner updates the price.\r\n     * \r\n     * @param price `The updated price.\r\n     */\r\n    event PriceUpdated(uint256 price);\r\n\r\n    /**\r\n     * @dev Emit an event whenever the owner toggles minting on,\r\n     *      or off.\r\n     * \r\n     * @param active    Whether minting is active or inactive.\r\n     */\r\n    event ToggledMinting(bool active);\r\n\r\n    /**\r\n     * @dev Revert with an error when providing an insufficient\r\n     *      value when minting.\r\n     * \r\n     * @param expected  The expected value for mint.\r\n     */\r\n    error InsufficientValueProvided(uint256 expected);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to withdraw balance\r\n     *      that is greater than the balance of the contract.\r\n     * \r\n     * @param balance   The true balance of the contract.\r\n     */\r\n    error NotEnoughFunds(uint256 balance);\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint whilst the\r\n     *      mint is inactive.\r\n     */\r\n    error MintInactive();\r\n\r\n    /**\r\n     * @dev Revert with an error when trying to mint a token, but\r\n     *      providing incorrect trait ID bounds.\r\n     * \r\n     * @param index The index of the trait that was out of bounds.\r\n     * @param min   The minimum trait ID value.\r\n     * @param max   The maximum trait ID value.\r\n     */\r\n    error TraitsOutOfBounds(uint256 index, uint256 min, uint256 max);\r\n}"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/oracle/price/PriceOracle.sol": {
      "content": "pragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport {IPriceOracle} from \"./interfaces/IPriceOracle.sol\";\r\n\r\n/**\r\n * @title PLAYA3ULL Games Price Oracle Contract\r\n * @author Jourdan (PLAYAY3ULL)\r\n * @notice This contract is the source of truth for price\r\n *         data on the PLAYA3ULL Games blockchain\r\n */\r\ncontract PriceOracle is Ownable, IPriceOracle {\r\n    /// @notice The prices of a given pair, indexed via a key\r\n    mapping(bytes32 => uint256) public pricePairs;\r\n\r\n    /// @notice The administrators that can set prices\r\n    mapping(address => bool) public priceAdmins;\r\n\r\n    /// @dev Modifier for only allowing set addresses to set\r\n    ///      prices\r\n    modifier onlyAdmin() {\r\n        require(priceAdmins[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the price of a token from it's pair\r\n     *\r\n     * @param tokenFrom  The token to get the price from\r\n     * @param tokenIn    The token to get the price in\r\n     * @param price      The price to get in\r\n     *\r\n     * @return The given price in the token price\r\n     */\r\n    function getPriceIn(\r\n        string memory tokenFrom,\r\n        string memory tokenIn,\r\n        uint256 price\r\n    ) external view returns (uint256) {\r\n        _assertValidPrice(price);\r\n\r\n        (, uint256 priceInToFrom) = getPairPrice(tokenFrom, tokenIn);\r\n\r\n        return (price * 1e18) / priceInToFrom;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the pair price for a given token pair\r\n     *\r\n     * @param symbolA The first token of a pair\r\n     * @param symbolB The second token of a pair\r\n     *\r\n     * @return The price of tokenA in tokenB\r\n     * @return The price of tokenB in tokenA\r\n     */\r\n    function getPairPrice(\r\n        string memory symbolA,\r\n        string memory symbolB\r\n    ) public view returns (uint256, uint256) {\r\n        // Get the keys for the pairs to lookup pricing for\r\n        bytes32 pair1 = getPairKey(symbolA, symbolB);\r\n        bytes32 pair2 = getPairKey(symbolB, symbolA);\r\n\r\n        return (pricePairs[pair1], pricePairs[pair2]);\r\n    }\r\n\r\n    /**\r\n     * @notice Sets the pair price for a given token pair\r\n     *\r\n     * @param symbolA The `from` token symbol\r\n     * @param symbolB The `to`, or `in` token symbol\r\n     * @param price The new price for the pair\r\n     */\r\n    function setPairPrice(\r\n        string memory symbolA,\r\n        string memory symbolB,\r\n        uint256 price\r\n    ) external onlyAdmin {\r\n        _assertValidPrice(price);\r\n\r\n        // Construct the token pair key\r\n        bytes32 pairKey = getPairKey(symbolA, symbolB);\r\n        pricePairs[pairKey] = price;\r\n\r\n        emit PairPriceUpdated(symbolA, symbolB, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Allows an owner to toggle whether an address has admin\r\n     *         rights or not\r\n     *\r\n     * @param admin The address to toggle\r\n     */\r\n    function togglePriceAdmin(address admin) external onlyOwner {\r\n        priceAdmins[admin] = !priceAdmins[admin];\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to construct a pair key for a given token\r\n     *      pair\r\n     *\r\n     * @param symbolA The first symbol in the pair\r\n     * @param symbolB The second symbol in the pair\r\n     *\r\n     * @return The keypair hash as a bytes32\r\n     */\r\n    function getPairKey(\r\n        string memory symbolA,\r\n        string memory symbolB\r\n    ) internal pure returns (bytes32) {\r\n        bytes32 hash = keccak256(abi.encodePacked(symbolA, symbolB));\r\n        return hash;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to revert if a given price is zero or less\r\n     *\r\n     * @param price The price to verify\r\n     */\r\n    function _assertValidPrice(uint256 price) internal pure {\r\n        if (price <= 0) {\r\n            revert InvalidPrice();\r\n        }\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 20
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}